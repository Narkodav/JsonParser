; Listing generated by Microsoft (R) Optimizing Compiler Version 19.50.35721.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_03FFFJFKND@ABC@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R4Number@Json@@6B@				; Json::Number::`RTTI Complete Object Locator'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_7Number@Json@@6B@				; Json::Number::`vftable'
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R3Number@Json@@8				; Json::Number::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_7Value@Json@@6B@				; Json::Value::`vftable'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2Array@Json@@8				; Json::Array::`RTTI Base Class Array'
PUBLIC	??_R2Value@Json@@8				; Json::Value::`RTTI Base Class Array'
PUBLIC	??_R4Array@Json@@6B@				; Json::Array::`RTTI Complete Object Locator'
PUBLIC	??_R3Array@Json@@8				; Json::Array::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4Value@Json@@6B@				; Json::Value::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@Number@Json@@8			; Json::Number::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2String@Json@@8				; Json::String::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Value@Json@@8			; Json::Value::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R4String@Json@@6B@				; Json::String::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@Array@Json@@8			; Json::Array::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7Array@Json@@6B@				; Json::Array::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R2Number@Json@@8				; Json::Number::`RTTI Base Class Array'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@String@Json@@8			; Json::String::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	??_R3Value@Json@@8				; Json::Value::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7String@Json@@6B@				; Json::String::`vftable'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	??_R3String@Json@@8				; Json::String::`RTTI Class Hierarchy Descriptor'
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_N@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp__purecall:PROC
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exceptions@std@@YAHXZ:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	_purecall:PROC
;	COMDAT ??_R3String@Json@@8
rdata$r	SEGMENT
??_R3String@Json@@8 DD 00H				; Json::String::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2String@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_7String@Json@@6B@
CONST	SEGMENT
??_7String@Json@@6B@ DQ FLAT:??_R4String@Json@@6B@	; Json::String::`vftable'
	DQ	FLAT:??_EString@Json@@UEAAPEAXI@Z
	DQ	FLAT:?isArray@String@Json@@UEBA_NXZ
	DQ	FLAT:?isBool@String@Json@@UEBA_NXZ
	DQ	FLAT:?isNumber@String@Json@@UEBA_NXZ
	DQ	FLAT:?isObject@String@Json@@UEBA_NXZ
	DQ	FLAT:?isString@String@Json@@UEBA_NXZ
	DQ	FLAT:?isNull@String@Json@@UEBA_NXZ
CONST	ENDS
;	COMDAT ??_R3Value@Json@@8
rdata$r	SEGMENT
??_R3Value@Json@@8 DD 00H				; Json::Value::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2Value@Json@@8
rdata$r	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@String@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@String@Json@@8 DD imagerel ??_R0?AVString@Json@@@8 ; Json::String::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3String@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2Number@Json@@8
rdata$r	SEGMENT
??_R2Number@Json@@8 DD imagerel ??_R1A@?0A@EA@Number@Json@@8 ; Json::Number::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Value@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_7Array@Json@@6B@
CONST	SEGMENT
??_7Array@Json@@6B@ DQ FLAT:??_R4Array@Json@@6B@	; Json::Array::`vftable'
	DQ	FLAT:??_EArray@Json@@UEAAPEAXI@Z
	DQ	FLAT:?isArray@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isBool@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isNumber@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isObject@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isString@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isNull@Array@Json@@UEBA_NXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@Array@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Array@Json@@8 DD imagerel ??_R0?AVArray@Json@@@8 ; Json::Array::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Array@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4String@Json@@6B@
rdata$r	SEGMENT
??_R4String@Json@@6B@ DD 01H				; Json::String::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVString@Json@@@8
	DD	imagerel ??_R3String@Json@@8
	DD	imagerel ??_R4String@Json@@6B@
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@Value@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Value@Json@@8 DD imagerel ??_R0?AVValue@Json@@@8 ; Json::Value::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Value@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2String@Json@@8
rdata$r	SEGMENT
??_R2String@Json@@8 DD imagerel ??_R1A@?0A@EA@String@Json@@8 ; Json::String::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Value@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Number@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Number@Json@@8 DD imagerel ??_R0?AVNumber@Json@@@8 ; Json::Number::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Number@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4Value@Json@@6B@
rdata$r	SEGMENT
??_R4Value@Json@@6B@ DD 01H				; Json::Value::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVValue@Json@@@8
	DD	imagerel ??_R3Value@Json@@8
	DD	imagerel ??_R4Value@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R3Array@Json@@8
rdata$r	SEGMENT
??_R3Array@Json@@8 DD 00H				; Json::Array::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Array@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4Array@Json@@6B@
rdata$r	SEGMENT
??_R4Array@Json@@6B@ DD 01H				; Json::Array::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVArray@Json@@@8
	DD	imagerel ??_R3Array@Json@@8
	DD	imagerel ??_R4Array@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R2Value@Json@@8
rdata$r	SEGMENT
??_R2Value@Json@@8 DD imagerel ??_R1A@?0A@EA@Value@Json@@8 ; Json::Value::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2Array@Json@@8
rdata$r	SEGMENT
??_R2Array@Json@@8 DD imagerel ??_R1A@?0A@EA@Array@Json@@8 ; Json::Array::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Value@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7Value@Json@@6B@
CONST	SEGMENT
??_7Value@Json@@6B@ DQ FLAT:??_R4Value@Json@@6B@	; Json::Value::`vftable'
	DQ	FLAT:??_EValue@Json@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R3Number@Json@@8
rdata$r	SEGMENT
??_R3Number@Json@@8 DD 00H				; Json::Number::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Number@Json@@8
rdata$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_7Number@Json@@6B@
CONST	SEGMENT
??_7Number@Json@@6B@ DQ FLAT:??_R4Number@Json@@6B@	; Json::Number::`vftable'
	DQ	FLAT:??_ENumber@Json@@UEAAPEAXI@Z
	DQ	FLAT:?isArray@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isBool@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isNumber@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isObject@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isString@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isNull@Number@Json@@UEBA_NXZ
CONST	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4Number@Json@@6B@
rdata$r	SEGMENT
??_R4Number@Json@@6B@ DD 01H				; Json::Number::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVNumber@Json@@@8
	DD	imagerel ??_R3Number@Json@@8
	DD	imagerel ??_R4Number@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFFJFKND@ABC@
CONST	SEGMENT
??_C@_03FFFJFKND@ABC@ DB 'ABC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
PUBLIC	??$construct_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@$$QEAV10@@Z ; std::construct_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$addressof@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ; std::addressof<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::`scalar deleting destructor'
PUBLIC	?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocate
PUBLIC	?_Calculate_growth@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Calculate_growth
PUBLIC	?_Orphan_range@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@0@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Orphan_range
PUBLIC	??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Release
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$construct@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::construct<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Construct_in_place@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$destroy_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ; std::destroy_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$forward@AEAPEAVString@Json@@@std@@YAAEAPEAVString@Json@@AEAPEAV12@@Z ; std::forward<Json::String * &>
PUBLIC	??$forward@AEAPEAVNumber@Json@@@std@@YAAEAPEAVNumber@Json@@AEAPEAV12@@Z ; std::forward<Json::Number * &>
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::__autoclassinit2
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array
PUBLIC	?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size
PUBLIC	??1_Simple_reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Simple_reallocation_guard::~_Simple_reallocation_guard
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$exchange@PEAVNumber@Json@@$$T@std@@YAPEAVNumber@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::Number *,std::nullptr_t>
PUBLIC	??$exchange@PEAVString@Json@@$$T@std@@YAPEAVString@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::String *,std::nullptr_t>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$forward@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Uninitialized_move@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ; std::_Get_unwrapped<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > * const &>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$destroy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::destroy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Unfancy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@PEAV10@@Z ; std::_Unfancy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$forward@PEAVString@Json@@@std@@YA$$QEAPEAVString@Json@@AEAPEAV12@@Z ; std::forward<Json::String *>
PUBLIC	??$?0AEAPEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVString@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1><Json::String * &>
PUBLIC	??$forward@PEAVNumber@Json@@@std@@YA$$QEAPEAVNumber@Json@@AEAPEAV12@@Z ; std::forward<Json::Number *>
PUBLIC	??$?0AEAPEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNumber@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1><Json::Number * &>
PUBLIC	??$?0VString@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VString@Json@@@1@@Z ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::String,0>
PUBLIC	??$?0VNumber@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNumber@Json@@@1@@Z ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Number,0>
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::deallocate
PUBLIC	?max_size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size
PUBLIC	?capacity@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::capacity
PUBLIC	?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first
PUBLIC	??R?$default_delete@VNumber@Json@@@std@@QEBAXPEAVNumber@Json@@@Z ; std::default_delete<Json::Number>::operator()
PUBLIC	?get_deleter@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::get_deleter
PUBLIC	?release@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAPEAVNumber@Json@@XZ ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Get_first
PUBLIC	??R?$default_delete@VString@Json@@@std@@QEBAXPEAVString@Json@@@Z ; std::default_delete<Json::String>::operator()
PUBLIC	?get_deleter@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::get_deleter
PUBLIC	?release@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAPEAVString@Json@@XZ ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Get_first
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
PUBLIC	??$exchange@PEAVValue@Json@@$$T@std@@YAPEAVValue@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::Value *,std::nullptr_t>
PUBLIC	??$_Emplace_one_at_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_one_at_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Reallocate@$0A@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXAEA_K@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Reallocate<0>
PUBLIC	??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$?0U?$default_delete@VString@Json@@@std@@PEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VString@Json@@@1@$$QEAPEAVString@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::String>,Json::String *>
PUBLIC	??$forward@U?$default_delete@VString@Json@@@std@@@std@@YA$$QEAU?$default_delete@VString@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::String> >
PUBLIC	??$?0U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@PEAVString@Json@@@Z ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::unique_ptr<Json::String,std::default_delete<Json::String> ><std::default_delete<Json::String>,0>
PUBLIC	??$?0AEAPEBD@String@Json@@QEAA@AEAPEBD@Z	; Json::String::String<char const * &>
PUBLIC	??$forward@AEAPEBD@std@@YAAEAPEBDAEAPEBD@Z	; std::forward<char const * &>
PUBLIC	??$forward@AEAH@std@@YAAEAHAEAH@Z		; std::forward<int &>
PUBLIC	??$?0U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNumber@Json@@@1@$$QEAPEAVNumber@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Number>,Json::Number *>
PUBLIC	??$forward@U?$default_delete@VNumber@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNumber@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::Number> >
PUBLIC	??$?0U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@PEAVNumber@Json@@@Z ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::unique_ptr<Json::Number,std::default_delete<Json::Number> ><std::default_delete<Json::Number>,0>
PUBLIC	??$forward@AEA_N@std@@YAAEA_NAEA_N@Z		; std::forward<bool &>
PUBLIC	??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z ; std::forward<Json::Value *>
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??R?$default_delete@VValue@Json@@@std@@QEBAXPEAVValue@Json@@@Z ; std::default_delete<Json::Value>::operator()
PUBLIC	?get_deleter@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::get_deleter
PUBLIC	?release@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAVValue@Json@@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Get_first
PUBLIC	?push_back@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::push_back
PUBLIC	?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::reserve
PUBLIC	?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Tidy
PUBLIC	?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal
PUBLIC	??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::~unique_ptr<Json::Number,std::default_delete<Json::Number> >
PUBLIC	??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::~unique_ptr<Json::String,std::default_delete<Json::String> >
PUBLIC	??$_Get_proxy_allocator@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA?AU_Fake_allocator@0@AEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ; std::_Get_proxy_allocator<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1><>
PUBLIC	??$?0VString@Json@@U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@1@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::String,std::default_delete<Json::String>,0>
PUBLIC	??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z ; std::make_unique<Json::String,char const * &,0>
PUBLIC	??$make_unique@VNumber@Json@@AEAH$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEAH@Z ; std::make_unique<Json::Number,int &,0>
PUBLIC	??$?0VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@1@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Number,std::default_delete<Json::Number>,0>
PUBLIC	??$make_unique@VNumber@Json@@AEA_N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEA_N@Z ; std::make_unique<Json::Number,bool &,0>
PUBLIC	??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$?0U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VValue@Json@@@1@$$QEAPEAVValue@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Value>,Json::Value *>
PUBLIC	??$forward@U?$default_delete@VValue@Json@@@std@@@std@@YA$$QEAU?$default_delete@VValue@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::Value> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
PUBLIC	??C?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEBAPEAVValue@Json@@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::operator->
PUBLIC	??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	?size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::size
PUBLIC	??A?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@_K@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::operator[]
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z		; Json::Array::Array<bool,int,char const *>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$construct_at@D$$V@std@@YAPEADQEAD@Z		; std::construct_at<char>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$move@AEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ; std::move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > &>
PUBLIC	??$?0U?$default_delete@VValue@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><std::default_delete<Json::Value>,0>
PUBLIC	?__autoclassinit2@Array@Json@@QEAAX_K@Z		; Json::Array::__autoclassinit2
PUBLIC	main
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ; std::_Traits_copy_batch<std::char_traits<char>,char>
PUBLIC	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AU_Fake_allocator@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1String@Json@@UEAA@XZ				; Json::String::~String
PUBLIC	??_GString@Json@@UEAAPEAXI@Z			; Json::String::`scalar deleting destructor'
PUBLIC	?isNull@String@Json@@UEBA_NXZ			; Json::String::isNull
PUBLIC	?isString@String@Json@@UEBA_NXZ			; Json::String::isString
PUBLIC	?isObject@String@Json@@UEBA_NXZ			; Json::String::isObject
PUBLIC	?isNumber@String@Json@@UEBA_NXZ			; Json::String::isNumber
PUBLIC	?isBool@String@Json@@UEBA_NXZ			; Json::String::isBool
PUBLIC	?isArray@String@Json@@UEBA_NXZ			; Json::String::isArray
PUBLIC	??1Number@Json@@UEAA@XZ				; Json::Number::~Number
PUBLIC	??_GNumber@Json@@UEAAPEAXI@Z			; Json::Number::`scalar deleting destructor'
PUBLIC	?isNull@Number@Json@@UEBA_NXZ			; Json::Number::isNull
PUBLIC	?isString@Number@Json@@UEBA_NXZ			; Json::Number::isString
PUBLIC	?isObject@Number@Json@@UEBA_NXZ			; Json::Number::isObject
PUBLIC	?isNumber@Number@Json@@UEBA_NXZ			; Json::Number::isNumber
PUBLIC	?isBool@Number@Json@@UEBA_NXZ			; Json::Number::isBool
PUBLIC	?isArray@Number@Json@@UEBA_NXZ			; Json::Number::isArray
PUBLIC	??0Number@Json@@QEAA@N@Z			; Json::Number::Number
PUBLIC	??_GValue@Json@@UEAAPEAXI@Z			; Json::Value::`scalar deleting destructor'
PUBLIC	??0Value@Json@@QEAA@XZ				; Json::Value::Value
PUBLIC	??1Value@Json@@UEAA@XZ				; Json::Value::~Value
PUBLIC	??1Array@Json@@UEAA@XZ				; Json::Array::~Array
PUBLIC	??_GArray@Json@@UEAAPEAXI@Z			; Json::Array::`scalar deleting destructor'
PUBLIC	??AArray@Json@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@_K@Z ; Json::Array::operator[]
PUBLIC	?size@Array@Json@@QEBA_KXZ			; Json::Array::size
PUBLIC	?isNull@Array@Json@@UEBA_NXZ			; Json::Array::isNull
PUBLIC	?isString@Array@Json@@UEBA_NXZ			; Json::Array::isString
PUBLIC	?isObject@Array@Json@@UEBA_NXZ			; Json::Array::isObject
PUBLIC	?isNumber@Array@Json@@UEBA_NXZ			; Json::Array::isNumber
PUBLIC	?isBool@Array@Json@@UEBA_NXZ			; Json::Array::isBool
PUBLIC	?isArray@Array@Json@@UEBA_NXZ			; Json::Array::isArray
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::falseLiteral
PUBLIC	?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::nullLiteral
PUBLIC	?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::trueLiteral
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_EArray@Json@@UEAAPEAXI@Z:PROC		; Json::Array::`vector deleting destructor'
EXTRN	??_EValue@Json@@UEAAPEAXI@Z:PROC		; Json::Value::`vector deleting destructor'
EXTRN	??_EString@Json@@UEAAPEAXI@Z:PROC		; Json::String::`vector deleting destructor'
EXTRN	??_ENumber@Json@@UEAAPEAXI@Z:PROC		; Json::Number::`vector deleting destructor'
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN18
	DD	imagerel $LN18+36
	DD	imagerel $unwind$??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z DD imagerel $LN27
	DD	imagerel $LN27+112
	DD	imagerel $unwind$?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN58
	DD	imagerel $LN58+20
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN58+20
	DD	imagerel $LN58+110
	DD	imagerel $chain$1$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN58+110
	DD	imagerel $LN58+170
	DD	imagerel $chain$2$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN37
	DD	imagerel $LN37+60
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD imagerel $LN58
	DD	imagerel $LN58+39
	DD	imagerel $unwind$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD imagerel $LN58+39
	DD	imagerel $LN58+116
	DD	imagerel $chain$0$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD imagerel $LN58+116
	DD	imagerel $LN58+196
	DD	imagerel $chain$1$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN10
	DD	imagerel $LN10+59
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN332
	DD	imagerel $LN332+64
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN332+64
	DD	imagerel $LN332+444
	DD	imagerel $chain$3$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN332+444
	DD	imagerel $LN332+450
	DD	imagerel $chain$4$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN332+450
	DD	imagerel $LN332+456
	DD	imagerel $chain$5$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z DD imagerel $LN30
	DD	imagerel $LN30+115
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN13
	DD	imagerel $LN13+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN20
	DD	imagerel $LN20+89
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate@$0A@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXAEA_K@Z DD imagerel $LN128
	DD	imagerel $LN128+224
	DD	imagerel $unwind$??$_Reallocate@$0A@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z DD imagerel $LN35
	DD	imagerel $LN35+59
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEBD@String@Json@@QEAA@AEAPEBD@Z DD imagerel $LN133
	DD	imagerel $LN133+296
	DD	imagerel $unwind$??$?0AEAPEBD@String@Json@@QEAA@AEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN23
	DD	imagerel $LN23+89
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN34
	DD	imagerel $LN34+97
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN22
	DD	imagerel $LN22+133
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN19
	DD	imagerel $LN19+62
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN129
	DD	imagerel $LN129+29
	DD	imagerel $unwind$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN129+29
	DD	imagerel $LN129+128
	DD	imagerel $chain$0$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN129+128
	DD	imagerel $LN129+134
	DD	imagerel $chain$1$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN58
	DD	imagerel $LN58+25
	DD	imagerel $unwind$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN58+25
	DD	imagerel $LN58+102
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN58+102
	DD	imagerel $LN58+167
	DD	imagerel $chain$1$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z DD imagerel $LN140
	DD	imagerel $LN140+344
	DD	imagerel $unwind$??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z@4HA DD imagerel ?dtor$0@?0???$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VNumber@Json@@AEAH$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEAH@Z DD imagerel $LN21
	DD	imagerel $LN21+76
	DD	imagerel $unwind$??$make_unique@VNumber@Json@@AEAH$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VNumber@Json@@AEA_N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEA_N@Z DD imagerel $LN21
	DD	imagerel $LN21+79
	DD	imagerel $unwind$??$make_unique@VNumber@Json@@AEA_N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN38
	DD	imagerel $LN38+97
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN62
	DD	imagerel $LN62+25
	DD	imagerel $unwind$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN62+25
	DD	imagerel $LN62+102
	DD	imagerel $chain$0$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN62+102
	DD	imagerel $LN62+167
	DD	imagerel $chain$1$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN143
	DD	imagerel $LN143+450
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+59
	DD	imagerel $unwind$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z DD imagerel $LN529
	DD	imagerel $LN529+501
	DD	imagerel $unwind$??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$12@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA DD imagerel ?dtor$12@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA
	DD	imagerel ?dtor$12@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA+29
	DD	imagerel $unwind$?dtor$12@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN26
	DD	imagerel $LN26+92
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN45
	DD	imagerel $LN45+263
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+108
	DD	imagerel $unwind$??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+108
	DD	imagerel $unwind$??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+108
	DD	imagerel $unwind$??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN20
	DD	imagerel $LN20+23
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN46
	DD	imagerel $LN46+111
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN108
	DD	imagerel $LN108+79
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN108+79
	DD	imagerel $LN108+237
	DD	imagerel $chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN108+237
	DD	imagerel $LN108+243
	DD	imagerel $chain$1$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN108+243
	DD	imagerel $LN108+249
	DD	imagerel $chain$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN126
	DD	imagerel $LN126+281
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1String@Json@@UEAA@XZ DD imagerel $LN44
	DD	imagerel $LN44+99
	DD	imagerel $unwind$??1String@Json@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GString@Json@@UEAAPEAXI@Z DD imagerel $LN52
	DD	imagerel $LN52+132
	DD	imagerel $unwind$??_GString@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GNumber@Json@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$??_GNumber@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GValue@Json@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$??_GValue@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GArray@Json@@UEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+56
	DD	imagerel $unwind$??_GArray@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN9
	DD	imagerel $LN9+63
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN14
	DD	imagerel $LN14+63
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN22
	DD	imagerel $LN22+67
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+67
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??nullLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; ??nullLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
_DATA	SEGMENT
?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 074H ; Json::Parser::trueLiteral
	DB	072H
	DB	075H
	DB	065H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DQ	0000000000000004H
	DQ	000000000000000fH
_DATA	ENDS
;	COMDAT ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
_DATA	SEGMENT
?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 06eH ; Json::Parser::nullLiteral
	DB	075H
	DB	06cH
	DB	06cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DQ	0000000000000004H
	DQ	000000000000000fH
_DATA	ENDS
;	COMDAT ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
_DATA	SEGMENT
?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 066H ; Json::Parser::falseLiteral
	DB	061H
	DB	06cH
	DB	073H
	DB	065H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DQ	0000000000000005H
	DQ	000000000000000fH
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GArray@Json@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GValue@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GNumber@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GString@Json@@UEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1String@Json@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 020021H
	DD	047400H
	DD	imagerel $LN108
	DD	imagerel $LN108+79
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 021H
	DD	imagerel $LN108
	DD	imagerel $LN108+79
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 020521H
	DD	047405H
	DD	imagerel $LN108
	DD	imagerel $LN108+79
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 050a01H
	DD	0e006420aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DB 06H
	DB	'V'
	DB	00H
	DB	'X'
	DB	02H
	DB	'1', 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DB 02H
	DB	0aH
	DD	imagerel ??1Array@Json@@UEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$main DB 028H
	DD	imagerel $stateUnwindMap$main
	DD	imagerel $ip2state$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	041919H
	DD	0c340aH
	DD	07006920aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$main
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$12@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z DB 0eH
	DB	'd'
	DB	02H
	DB	0e0H
	DB	04H
	DB	'^'
	DB	06H
	DB	'@'
	DB	08H
	DB	'^'
	DB	0aH
	DB	'8'
	DB	0cH
	DB	0d0H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z DB 010H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA
	DB	02aH
	DD	imagerel ??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
	DB	050H
	DB	032H
	DD	imagerel ??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	036H
	DD	imagerel ?dtor$12@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA
	DB	05aH
	DD	imagerel ??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z
	DD	imagerel $ip2state$??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z DD 070d11H
	DD	0f009c20dH
	DD	07005e007H
	DD	050036004H
	DD	03002H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0cH
	DB	09cH
	DB	00H
	DB	'h'
	DB	02H
	DB	0c8H
	DB	06H
	DB	0f2H
	DB	04H
	DB	'L'
	DB	00H
	DB	'P'
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	085H, 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0aH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 061719H
	DD	0c3417H
	DD	0e0135217H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN62
	DD	imagerel $LN62+25
	DD	imagerel $unwind$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 020521H
	DD	076405H
	DD	imagerel $LN62
	DD	imagerel $LN62+25
	DD	imagerel $unwind$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VNumber@Json@@AEA_N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEA_N@Z DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VNumber@Json@@AEAH$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEAH@Z DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z DB 08H
	DB	'L'
	DB	00H
	DB	'Q', 02H
	DB	02H
	DB	0eaH
	DB	00H
	DB	':'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z
	DD	imagerel $ip2state$??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z DD 0a1611H
	DD	0f5416H
	DD	0e3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN58
	DD	imagerel $LN58+25
	DD	imagerel $unwind$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD 020521H
	DD	076405H
	DD	imagerel $LN58
	DD	imagerel $LN58+25
	DD	imagerel $unwind$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN129
	DD	imagerel $LN129+29
	DD	imagerel $unwind$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 020521H
	DD	077405H
	DD	imagerel $LN129
	DD	imagerel $LN129+29
	DD	imagerel $unwind$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'h'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 04H
	DB	'X'
	DB	00H
	DB	'\'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEBD@String@Json@@QEAA@AEAPEBD@Z DD 081001H
	DD	0e3410H
	DD	0f00c5210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate@$0A@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXAEA_K@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD 060021H
	DD	04d400H
	DD	057400H
	DD	0f5400H
	DD	imagerel $LN332
	DD	imagerel $LN332+64
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD 021H
	DD	imagerel $LN332
	DD	imagerel $LN332+64
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD 08a421H
	DD	0664a4H
	DD	04d41cH
	DD	057411H
	DD	0f5405H
	DD	imagerel $LN332
	DD	imagerel $LN332+64
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD 050c01H
	DD	0f008620cH
	DD	0c004e006H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD 021H
	DD	imagerel $LN58
	DD	imagerel $LN58+39
	DD	imagerel $unwind$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD 020521H
	DD	096405H
	DD	imagerel $LN58
	DD	imagerel $LN58+39
	DD	imagerel $unwind$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0700be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN58
	DD	imagerel $LN58+20
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 040e21H
	DD	08740eH
	DD	073405H
	DD	imagerel $LN58
	DD	imagerel $LN58+20
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??trueLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; ??trueLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??falseLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; ??falseLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, rdx

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 183  :     return __builtin_is_constant_evaluated();

	xor	al, al

; 184  : }

	ret	0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 68   :         _Data._What = _Message;
; 69   :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@

; 66   :         : _Data()

	mov	QWORD PTR [rcx+16], 0

; 133  :     {

	mov	QWORD PTR [rcx], rax

; 134  :     }

	mov	rax, rcx

; 68   :         _Data._What = _Message;

	mov	QWORD PTR [rcx+8], rdx

; 134  :     }

	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN13@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 68   :         _Data._What = _Message;

	lea	rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rax

; 144  :     {

	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rcx], rax

; 145  :     }

	mov	rax, rcx
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN18@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN18@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 111  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
	sub	rsp, 72					; 00000048H

; 112  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 73   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	vpxor	xmm0, xmm0, xmm0
	mov	QWORD PTR [rbx], rcx
	lea	rdx, QWORD PTR [rbx+8]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 73   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	vpxor	xmm0, xmm0, xmm0
	mov	QWORD PTR [rbx], rcx
	lea	rdx, QWORD PTR [rbx+8]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 8
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 140  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr$ = 8
_Bytes$ = 16
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 205  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 206  :     _Bytes += _Non_user_size;

	add	QWORD PTR [rdx], 39			; 00000027H

; 207  : 
; 208  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR [rcx]

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rdx, QWORD PTR [rax-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rdx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN3@Adjust_man

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	QWORD PTR [rcx], rdx

; 225  : }

	ret	0
$LN3@Adjust_man:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN5@Adjust_man:
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1196 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1198 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1462 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	rax, rcx
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1465 :     _CONSTEXPR20 void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 573  : [[noreturn]] inline void _Xlen_string() {

$LN4:
	sub	rsp, 40					; 00000028H

; 574  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen_strin:
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rdx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 102  : }

	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isArray@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isArray@Array@Json@@UEBA_NXZ PROC			; Json::Array::isArray, COMDAT

; 73   : 		bool isArray() const override { return true; }

	mov	al, 1
	ret	0
?isArray@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isBool@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isBool@Array@Json@@UEBA_NXZ PROC			; Json::Array::isBool, COMDAT

; 74   : 		bool isBool() const override { return false; }

	xor	al, al
	ret	0
?isBool@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isNumber@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNumber@Array@Json@@UEBA_NXZ PROC			; Json::Array::isNumber, COMDAT

; 75   : 		bool isNumber() const override { return false; }

	xor	al, al
	ret	0
?isNumber@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isObject@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isObject@Array@Json@@UEBA_NXZ PROC			; Json::Array::isObject, COMDAT

; 76   : 		bool isObject() const override { return false; }

	xor	al, al
	ret	0
?isObject@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isString@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isString@Array@Json@@UEBA_NXZ PROC			; Json::Array::isString, COMDAT

; 77   : 		bool isString() const override { return false; }

	xor	al, al
	ret	0
?isString@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isNull@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNull@Array@Json@@UEBA_NXZ PROC			; Json::Array::isNull, COMDAT

; 78   : 		bool isNull() const override { return false; }

	xor	al, al
	ret	0
?isNull@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isNull
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?size@Array@Json@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@Array@Json@@QEBA_KXZ PROC				; Json::Array::size, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1915 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 3
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h

; 83   : 		size_t size() const { return m_values.size(); };

	ret	0
?size@Array@Json@@QEBA_KXZ ENDP				; Json::Array::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ??AArray@Json@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@_K@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??AArray@Json@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@_K@Z PROC ; Json::Array::operator[], COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1934 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rax+rdx*8]
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h

; 87   : 		};

	ret	0
??AArray@Json@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@_K@Z ENDP ; Json::Array::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GArray@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GArray@Json@@UEAAPEAXI@Z PROC			; Json::Array::`scalar deleting destructor', COMDAT
$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx
	add	rcx, 8
	call	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
	test	bl, 1
	je	SHORT $LN13@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GArray@Json@@UEAAPEAXI@Z ENDP			; Json::Array::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1Array@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Array@Json@@UEAA@XZ PROC				; Json::Array::~Array, COMDAT
	add	rcx, 8
	jmp	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
??1Array@Json@@UEAA@XZ ENDP				; Json::Array::~Array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Value.h
;	COMDAT ??1Value@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Value@Json@@UEAA@XZ PROC				; Json::Value::~Value, COMDAT

; 18   : 		virtual ~Value() = default;

	ret	0
??1Value@Json@@UEAA@XZ ENDP				; Json::Value::~Value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Value.h
;	COMDAT ??0Value@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Value@Json@@QEAA@XZ PROC				; Json::Value::Value, COMDAT

; 17   : 		Value() = default;

	lea	rax, OFFSET FLAT:??_7Value@Json@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0Value@Json@@QEAA@XZ ENDP				; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GValue@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GValue@Json@@UEAAPEAXI@Z PROC			; Json::Value::`scalar deleting destructor', COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN5@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GValue@Json@@UEAAPEAXI@Z ENDP			; Json::Value::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ??0Number@Json@@QEAA@N@Z
_TEXT	SEGMENT
this$ = 8
value$ = 16
??0Number@Json@@QEAA@N@Z PROC				; Json::Number::Number, COMDAT

; 13   : 		Number(double value) : Value(), m_value(value) {};

	lea	rax, OFFSET FLAT:??_7Number@Json@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	vmovsd	QWORD PTR [rcx+8], xmm1
	ret	0
??0Number@Json@@QEAA@N@Z ENDP				; Json::Number::Number
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isArray@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isArray@Number@Json@@UEBA_NXZ PROC			; Json::Number::isArray, COMDAT

; 15   : 		bool isArray() const override { return false; }

	xor	al, al
	ret	0
?isArray@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isBool@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isBool@Number@Json@@UEBA_NXZ PROC			; Json::Number::isBool, COMDAT

; 16   : 		bool isBool() const override { return false; }

	xor	al, al
	ret	0
?isBool@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isNumber@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNumber@Number@Json@@UEBA_NXZ PROC			; Json::Number::isNumber, COMDAT

; 17   : 		bool isNumber() const override { return true; }

	mov	al, 1
	ret	0
?isNumber@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isObject@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isObject@Number@Json@@UEBA_NXZ PROC			; Json::Number::isObject, COMDAT

; 18   : 		bool isObject() const override { return false; }

	xor	al, al
	ret	0
?isObject@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isString@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isString@Number@Json@@UEBA_NXZ PROC			; Json::Number::isString, COMDAT

; 19   : 		bool isString() const override { return false; }

	xor	al, al
	ret	0
?isString@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isNull@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNull@Number@Json@@UEBA_NXZ PROC			; Json::Number::isNull, COMDAT

; 20   : 		bool isNull() const override { return false; }

	xor	al, al
	ret	0
?isNull@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isNull
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GNumber@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GNumber@Json@@UEAAPEAXI@Z PROC			; Json::Number::`scalar deleting destructor', COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN5@scalar
	mov	edx, 16
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GNumber@Json@@UEAAPEAXI@Z ENDP			; Json::Number::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1Number@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Number@Json@@UEAA@XZ PROC				; Json::Number::~Number, COMDAT
	ret	0
??1Number@Json@@UEAA@XZ ENDP				; Json::Number::~Number
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isArray@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isArray@String@Json@@UEBA_NXZ PROC			; Json::String::isArray, COMDAT

; 19   : 		bool isArray() const override { return false; }

	xor	al, al
	ret	0
?isArray@String@Json@@UEBA_NXZ ENDP			; Json::String::isArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isBool@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isBool@String@Json@@UEBA_NXZ PROC			; Json::String::isBool, COMDAT

; 20   : 		bool isBool() const override { return false; }

	xor	al, al
	ret	0
?isBool@String@Json@@UEBA_NXZ ENDP			; Json::String::isBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isNumber@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNumber@String@Json@@UEBA_NXZ PROC			; Json::String::isNumber, COMDAT

; 21   : 		bool isNumber() const override { return false; }

	xor	al, al
	ret	0
?isNumber@String@Json@@UEBA_NXZ ENDP			; Json::String::isNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isObject@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isObject@String@Json@@UEBA_NXZ PROC			; Json::String::isObject, COMDAT

; 22   : 		bool isObject() const override { return false; }

	xor	al, al
	ret	0
?isObject@String@Json@@UEBA_NXZ ENDP			; Json::String::isObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isString@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isString@String@Json@@UEBA_NXZ PROC			; Json::String::isString, COMDAT

; 23   : 		bool isString() const override { return true; }

	mov	al, 1
	ret	0
?isString@String@Json@@UEBA_NXZ ENDP			; Json::String::isString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isNull@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNull@String@Json@@UEBA_NXZ PROC			; Json::String::isNull, COMDAT

; 24   : 		bool isNull() const override { return false; }

	xor	al, al
	ret	0
?isNull@String@Json@@UEBA_NXZ ENDP			; Json::String::isNull
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??_GString@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GString@Json@@UEAAPEAXI@Z PROC			; Json::String::`scalar deleting destructor', COMDAT
$LN52:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
	mov	rbx, rcx

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+32]
	cmp	rdx, 15

; 3169 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN28@scalar

; 3170 :             _ASAN_STRING_REMOVE(*this);
; 3171 :             auto& _Al = _Getal();
; 3172 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR [rcx+8]

; 902  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN44@scalar

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN35@scalar

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN36@scalar
$LN35@scalar:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN44@scalar:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rax
$LN36@scalar:

; 293  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN28@scalar:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 3176 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+24], 0

; 3177 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+32], 15

; 3178 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3179 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+8], 0
	test	dil, 1
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN49@scalar:
??_GString@Json@@UEAAPEAXI@Z ENDP			; Json::String::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??1String@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1String@Json@@UEAA@XZ PROC				; Json::String::~String, COMDAT
$LN44:
	push	rbx
	sub	rsp, 32					; 00000020H

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+32]
	mov	rbx, rcx
	cmp	rdx, 15

; 3169 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN22@String

; 3170 :             _ASAN_STRING_REMOVE(*this);
; 3171 :             auto& _Al = _Getal();
; 3172 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR [rcx+8]

; 902  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN37@String

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN29@String

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN30@String
$LN29@String:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN37@String:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rax
$LN30@String:

; 293  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@String:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 3176 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+24], 0

; 3177 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+32], 15

; 3178 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3179 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+8], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN41@String:
??1String@Json@@UEAA@XZ ENDP				; Json::String::~String
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 818  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN126:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	edi, edi

; 818  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	rbx, rcx

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rdi

; 818  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	r14, rdx

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rdi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 530  :             return __builtin_strlen(_First);

	mov	rcx, rdx
	call	strlen
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 931  :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 530  :             return __builtin_strlen(_First);

	mov	rsi, rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 931  :         if (_Count > max_size()) {

	cmp	rax, rbp
	ja	$LN123@basic_stri

; 933  :         }
; 934  : 
; 935  :         auto& _Al     = _Getal();
; 936  :         auto _Alproxy = _STD _Get_proxy_allocator(_Al);
; 937  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 938  : 
; 939  :         if (_Count <= _Small_string_capacity) {

	cmp	rax, 15
	ja	SHORT $LN21@basic_stri
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 940  :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 941  :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbx
	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 948  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rsi+rbx], dil

; 949  :             } else { // _Strat == _Construct_strategy::_From_string
; 950  : #ifdef _INSERT_STRING_ANNOTATION
; 951  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 952  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 953  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 954  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 955  :             }
; 956  : 
; 957  :             _Proxy._Release();
; 958  :             return;

	jmp	$LN19@basic_stri
$LN21@basic_stri:

; 2885 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rax, 15

; 2886 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	cmp	rax, rbp
	jbe	SHORT $LN37@basic_stri

; 2887 :             return _Max;

	mov	rax, -9223372036854775769		; 8000000000000027H
$LN62@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN63@basic_stri
	mov	ecx, 5
	int	41					; 00000029H
$LN37@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 875  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 231  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN54@basic_stri

; 232  :         return nullptr;
; 233  :     }
; 234  : 
; 235  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 236  :     if (_STD is_constant_evaluated()) {
; 237  :         return _Traits::_Allocate(_Bytes);
; 238  :     }
; 239  : #endif // _HAS_CXX20
; 240  : 
; 241  : #ifdef __cpp_aligned_new
; 242  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 243  :         size_t _Passed_align = _Align;
; 244  : #if defined(_M_IX86) || defined(_M_X64)
; 245  :         if (_Bytes >= _Big_allocation_threshold) {
; 246  :             // boost the alignment of big allocations to help autovectorization
; 247  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 248  :         }
; 249  : #endif // defined(_M_IX86) || defined(_M_X64)
; 250  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 251  :     } else
; 252  : #endif // defined(__cpp_aligned_new)
; 253  :     {
; 254  : #if defined(_M_IX86) || defined(_M_X64)
; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN57@basic_stri

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN124@basic_stri
	jmp	SHORT $LN62@basic_stri
$LN63@basic_stri:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 257  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN54@basic_stri
$LN57@basic_stri:

; 140  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN54@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 963  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rbx], rdi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 965  :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 966  :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 972  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rsi+rdi], 0
$LN19@basic_stri:

; 820  :     }

	mov	rbp, QWORD PTR [rsp+88]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN123@basic_stri:

; 932  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN124@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN121@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 978  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 495  : 
; 496  :         value_type _Buf[_BUF_SIZE];
; 497  :         pointer _Ptr;
; 498  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 499  : 
; 500  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }
; 512  :     };
; 513  :     _Bxty _Bx;
; 514  : 
; 515  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 516  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 495  : 
; 496  :         value_type _Buf[_BUF_SIZE];
; 497  :         pointer _Ptr;
; 498  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 499  : 
; 500  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }
; 512  :     };
; 513  :     _Bxty _Bx;
; 514  : 
; 515  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 516  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	rax, rcx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 518  :         // find length of null-terminated string
; 519  : #if _HAS_CXX17
; 520  : #ifdef __cpp_char8_t
; 521  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 522  : #if _HAS_U8_INTRINSICS
; 523  :             return __builtin_u8strlen(_First);
; 524  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 525  :             return _Primary_char_traits::length(_First);
; 526  : #endif // ^^^ no u8 intrinsics ^^^
; 527  :         } else
; 528  : #endif // defined(__cpp_char8_t)
; 529  :         {
; 530  :             return __builtin_strlen(_First);

	jmp	strlen
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1133 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1134 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1135 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1136 : 
; 1137 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1138 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1139 :             _Xlength_error("size is too long for _Size_type");
; 1140 :         }
; 1141 :     }
; 1142 : 
; 1143 :     return static_cast<_Size_type>(_Len);

	mov	rax, rcx

; 1144 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
this$ = 80
_Arg$ = 88
_Count$ = 96
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 921  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN108:
	push	rbx
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 40					; 00000028H

; 922  :         auto& _My_data = _Mypair._Myval2;
; 923  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 924  : 
; 925  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 926  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 927  :         } else {
; 928  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cvptr<_Char_or_ptr>::value);
; 929  :         }
; 930  : 
; 931  :         if (_Count > max_size()) {

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	mov	rbx, r8
	mov	rbp, rdx
	mov	r14, rcx
	cmp	r8, rsi
	ja	$LN105@Construct

; 933  :         }
; 934  : 
; 935  :         auto& _Al     = _Getal();
; 936  :         auto _Alproxy = _STD _Get_proxy_allocator(_Al);
; 937  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 938  : 
; 939  :         if (_Count <= _Small_string_capacity) {

	cmp	rbx, 15
	ja	SHORT $LN3@Construct

; 940  :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rbx

; 941  :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 948  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rbx+r14], 0

; 979  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN3@Construct:

; 2885 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rbx
	mov	QWORD PTR [rsp+32], rdi
	or	rax, 15

; 2886 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	cmp	rax, rsi
	jbe	SHORT $LN19@Construct

; 2887 :             return _Max;

	mov	rax, -9223372036854775769		; 8000000000000027H
$LN44@Construct:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN45@Construct
	mov	ecx, 5
	int	41					; 00000029H
$LN19@Construct:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rsi, rax
	cmp	rax, rcx
	cmovb	rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 875  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 231  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN37@Construct

; 232  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN36@Construct
$LN37@Construct:

; 233  :     }
; 234  : 
; 235  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 236  :     if (_STD is_constant_evaluated()) {
; 237  :         return _Traits::_Allocate(_Bytes);
; 238  :     }
; 239  : #endif // _HAS_CXX20
; 240  : 
; 241  : #ifdef __cpp_aligned_new
; 242  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 243  :         size_t _Passed_align = _Align;
; 244  : #if defined(_M_IX86) || defined(_M_X64)
; 245  :         if (_Bytes >= _Big_allocation_threshold) {
; 246  :             // boost the alignment of big allocations to help autovectorization
; 247  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 248  :         }
; 249  : #endif // defined(_M_IX86) || defined(_M_X64)
; 250  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 251  :     } else
; 252  : #endif // defined(__cpp_aligned_new)
; 253  :     {
; 254  : #if defined(_M_IX86) || defined(_M_X64)
; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN39@Construct

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN106@Construct
	jmp	SHORT $LN44@Construct
$LN45@Construct:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 257  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN36@Construct
$LN39@Construct:

; 140  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN36@Construct:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 963  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [r14], rdi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 965  :         _My_data._Mysize = _Count;

	mov	QWORD PTR [r14+16], rbx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 966  :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [r14+24], rsi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 972  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0
	mov	rdi, QWORD PTR [rsp+32]

; 979  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN105@Construct:

; 932  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN106@Construct:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN103@Construct:
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Capacity$ = 56
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 873  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN46:
	push	rbx
	sub	rsp, 32					; 00000020H

; 874  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 875  :         ++_Capacity; // Take null terminator into consideration

	add	QWORD PTR [rdx], 1
	mov	rbx, rdx
	mov	rcx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 231  :     if (_Bytes == 0) {

	jne	SHORT $LN12@Allocate_f

; 232  :         return nullptr;

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 895  :         --_Capacity;

	dec	QWORD PTR [rdx]

; 897  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN12@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN14@Allocate_f

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN44@Allocate_f

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN20@Allocate_f
	mov	ecx, 5
	int	41					; 00000029H
$LN20@Allocate_f:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 895  :         --_Capacity;

	dec	QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 897  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN14@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 140  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 895  :         --_Capacity;

	dec	QWORD PTR [rbx]

; 897  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN44@Allocate_f:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN42@Allocate_f:
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2285 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 2286 :         const size_type _Storage_max = // can always store small string
; 2287 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2288 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 2289 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2290 :         );
; 2291 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3197 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3198 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1563 :         return *this;

	mov	rax, rcx

; 1564 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 750  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 751  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 78   : }

	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3193 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3194 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1559 :         return *this;

	mov	rax, rcx

; 1560 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AU_Fake_allocator@0@AEBV?$allocator@D@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AU_Fake_allocator@0@AEBV?$allocator@D@0@@Z PROC ; std::_Get_proxy_allocator<std::allocator<char> >, COMDAT

; 1517 :     return {};

	xor	al, al

; 1518 : }

	ret	0
??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AU_Fake_allocator@0@AEBV?$allocator@D@0@@Z ENDP ; std::_Get_proxy_allocator<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z PROC ; std::_Traits_copy_batch<std::char_traits<char>,char>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ENDP ; std::_Traits_copy_batch<std::char_traits<char>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 184  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 185  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 186  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 187  :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 188  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 189  : #if _HAS_CXX20
; 190  :         if (_STD is_constant_evaluated()) {
; 191  :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 192  :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 193  :                 _First1[_Idx] = _First2[_Idx];
; 194  :             }
; 195  : 
; 196  :             return _First1;
; 197  :         }
; 198  : #endif // _HAS_CXX20
; 199  : 
; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 201  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 202  : 
; 203  :         return _First1;

	mov	rax, rbx

; 204  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 571  :         _Left = _Right;

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al

; 572  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??__E?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$di	SEGMENT
??__E?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic initializer for 'Json::Parser::nullLiteral'', COMDAT

; 43   : 		static inline const std::string nullLiteral = "null";

	lea	rcx, OFFSET FLAT:??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Parser::nullLiteral''
	jmp	atexit
??__E?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic initializer for 'Json::Parser::nullLiteral''
text$di	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??__E?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$di	SEGMENT
??__E?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic initializer for 'Json::Parser::trueLiteral'', COMDAT

; 44   : 		static inline const std::string trueLiteral = "true";

	lea	rcx, OFFSET FLAT:??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Parser::trueLiteral''
	jmp	atexit
??__E?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic initializer for 'Json::Parser::trueLiteral''
text$di	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??__E?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$di	SEGMENT
??__E?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic initializer for 'Json::Parser::falseLiteral'', COMDAT

; 45   : 		static inline const std::string falseLiteral = "false";

	lea	rcx, OFFSET FLAT:??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Parser::falseLiteral''
	jmp	atexit
??__E?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic initializer for 'Json::Parser::falseLiteral''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$yd	SEGMENT
??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic atexit destructor for 'Json::Parser::falseLiteral'', COMDAT
	sub	rsp, 40					; 00000028H

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 3169 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@falseLiter

; 3170 :             _ASAN_STRING_REMOVE(*this);
; 3171 :             auto& _Al = _Getal();
; 3172 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B

; 902  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@falseLiter

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN28@falseLiter

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN29@falseLiter
$LN28@falseLiter:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN36@falseLiter:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rax
$LN29@falseLiter:

; 293  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@falseLiter:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 3176 :         _My_data._Mysize = 0;

	mov	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, 0

; 3177 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 3178 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3179 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN37@falseLiter:
??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic atexit destructor for 'Json::Parser::falseLiteral''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$yd	SEGMENT
??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic atexit destructor for 'Json::Parser::trueLiteral'', COMDAT
	sub	rsp, 40					; 00000028H

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 3169 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@trueLitera

; 3170 :             _ASAN_STRING_REMOVE(*this);
; 3171 :             auto& _Al = _Getal();
; 3172 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B

; 902  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@trueLitera

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN28@trueLitera

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN29@trueLitera
$LN28@trueLitera:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN36@trueLitera:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rax
$LN29@trueLitera:

; 293  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@trueLitera:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 3176 :         _My_data._Mysize = 0;

	mov	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, 0

; 3177 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 3178 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3179 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN37@trueLitera:
??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic atexit destructor for 'Json::Parser::trueLiteral''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$yd	SEGMENT
??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic atexit destructor for 'Json::Parser::nullLiteral'', COMDAT
	sub	rsp, 40					; 00000028H

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24
	cmp	rdx, 15

; 3169 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN21@nullLitera

; 3170 :             _ASAN_STRING_REMOVE(*this);
; 3171 :             auto& _Al = _Getal();
; 3172 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B

; 902  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@nullLitera

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN28@nullLitera

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN29@nullLitera
$LN28@nullLitera:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN36@nullLitera:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rax
$LN29@nullLitera:

; 293  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@nullLitera:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 3176 :         _My_data._Mysize = 0;

	mov	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, 0

; 3177 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 3178 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3179 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN37@nullLitera:
??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic atexit destructor for 'Json::Parser::nullLiteral''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp
;	COMDAT main
_TEXT	SEGMENT
arr$ = 32
__$ArrayPad$ = 64
main	PROC						; COMDAT

; 7    : {

$LN45:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	vpxor	xmm0, xmm0, xmm0
	vmovups	YMMWORD PTR arr$[rsp], ymm0

; 8    : 	//Json::Document doc;
; 9    : 	//try
; 10   : 	//{
; 11   : 	//	doc = Json::Parser::parseFile("test.json");
; 12   : 	//	std::cout << doc.roots().size() << std::endl;
; 13   : 	//}
; 14   : 	//catch (const std::exception& e)
; 15   : 	//{
; 16   : 	//	std::cerr << e.what() << std::endl;
; 17   : 	//}
; 18   : 
; 19   : 	//try
; 20   : 	//{
; 21   : 	//	std::cout << doc.roots().size() << std::endl;
; 22   : 	//	assert(doc.roots().size() == 3)
; 23   : 	//}
; 24   : 	//catch (const std::exception& e)
; 25   : 	//{
; 26   : 	//	std::cerr << e.what() << std::endl;
; 27   : 	//}
; 28   : 
; 29   : 	//Json::Root root = { Json::Object() };
; 30   : 
; 31   : 	Json::Array arr = { true, 1, "ABC" };

	lea	rcx, QWORD PTR arr$[rsp]
	vzeroupper
	call	??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z	; Json::Array::Array<bool,int,char const *>
	npad	1

; 33   : 	for(size_t i = 0; i < arr.size(); i++)

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1915 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR arr$[rsp+16]
	mov	rcx, QWORD PTR arr$[rsp+8]
	sub	rax, rcx
	sar	rax, 3
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp

; 33   : 	for(size_t i = 0; i < arr.size(); i++)

	test	rax, rax
	je	$LN3@main
	npad	3
$LL4@main:

; 34   : 		std::cout << arr[i]->isBool() << " " << arr[i]->isNumber() << " " << arr[i]->isString() << std::endl;

	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	movzx	edx, al
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_N@Z
	mov	rcx, rax
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rbx, rax
	mov	rcx, QWORD PTR arr$[rsp+8]
	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	rdx, QWORD PTR [rcx]
	call	QWORD PTR [rdx+24]
	movzx	edx, al
	mov	rcx, rbx
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_N@Z
	mov	rcx, rax
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rbx, rax
	mov	rcx, QWORD PTR arr$[rsp+8]
	mov	rcx, QWORD PTR [rcx+rdi*8]
	mov	rdx, QWORD PTR [rcx]
	call	QWORD PTR [rdx+40]
	movzx	edx, al
	mov	rcx, rbx
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_N@Z
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 33   : 	for(size_t i = 0; i < arr.size(); i++)

	inc	rdi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1915 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR arr$[rsp+16]
	mov	rcx, QWORD PTR arr$[rsp+8]
	sub	rax, rcx
	sar	rax, 3
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp

; 33   : 	for(size_t i = 0; i < arr.size(); i++)

	cmp	rdi, rax
	jb	$LL4@main
$LN3@main:
	lea	rcx, QWORD PTR arr$[rsp+8]
	call	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >

; 35   : 
; 36   : 	return 0;

	xor	eax, eax

; 37   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
arr$ = 32
__$ArrayPad$ = 64
main$dtor$0 PROC
	lea	rcx, QWORD PTR arr$[rdx]
	jmp	??1Array@Json@@UEAA@XZ
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@Array@Json@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@Array@Json@@QEAAX_K@Z PROC		; Json::Array::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	vmovups	YMMWORD PTR [rcx], ymm0
	vzeroupper
	ret	0
?__autoclassinit2@Array@Json@@QEAAX_K@Z ENDP		; Json::Array::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$?0U?$default_delete@VValue@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0U?$default_delete@VValue@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><std::default_delete<Json::Value>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3415 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VValue@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><std::default_delete<Json::Value>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$move@AEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z PROC ; std::move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > &>, COMDAT

; 1521 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1522 : }

	ret	0
??$move@AEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2314 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN26:
	sub	rsp, 40					; 00000028H

; 2315 : #if _HAS_CXX23
; 2316 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2317 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2318 :         _Count                  = _Allocated;
; 2319 :         return _Ptr;
; 2320 :     } else
; 2321 : #endif // _HAS_CXX23
; 2322 :     {
; 2323 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 231  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN6@Allocate_a

; 232  :         return nullptr;

	xor	eax, eax

; 2324 :     }
; 2325 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Allocate_a:

; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@Allocate_a

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN25@Allocate_a

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN14@Allocate_a
	mov	ecx, 5
	int	41					; 00000029H
$LN14@Allocate_a:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2324 :     }
; 2325 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@Allocate_a:
	add	rsp, 40					; 00000028H

; 140  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN25@Allocate_a:

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN23@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 73   :     return _Ptr;

	mov	rax, rcx

; 74   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$construct_at@D$$V@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@D$$V@std@@YAPEADQEAD@Z PROC		; std::construct_at<char>, COMDAT

; 509  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 510  : }

	ret	0
??$construct_at@D$$V@std@@YAPEADQEAD@Z ENDP		; std::construct_at<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 516  : #if _HAS_CXX20
; 517  :     if (_STD is_constant_evaluated()) {
; 518  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 519  :     } else
; 520  : #endif // _HAS_CXX20
; 521  :     {
; 522  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 523  :     }
; 524  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z
_TEXT	SEGMENT
$T128 = 32
$T32 = 32
$T66 = 32
$T100 = 32
$T38 = 40
$T72 = 48
this$GSCopy$ = 56
$T35 = 64
$T69 = 72
$T124 = 80
this$ = 160
<values_0>$dead$ = 168
<values_1>$dead$ = 176
<values_2>$dead$ = 184
??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z PROC		; Json::Array::Array<bool,int,char const *>, COMDAT

; 60   : 		Array(Types... values) : Value()

$LN529:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 104				; 00000068H
	mov	r14, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	xor	ebp, ebp

; 61   : 		{

	lea	rax, OFFSET FLAT:??_7Array@Json@@6B@
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rbp
	mov	QWORD PTR [rcx+16], rbp
	mov	QWORD PTR [rcx+24], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 140  :         return ::operator new(_Bytes);

	mov	ecx, 24
	call	??2@YAPEAX_K@Z				; operator new
	mov	r10, rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1662 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r8, QWORD PTR [r14+16]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2004 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	mov	rcx, QWORD PTR [r14+8]

; 1853 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	rdx, rax

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, r8
	je	SHORT $LN63@Array
	npad	6
$LL64@Array:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx], rax

; 1865 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+8]

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 8
	cmp	rcx, r8
	jne	SHORT $LL64@Array
$LN63@Array:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1668 :         _Change_array(_Newvec, _Size, _Newcapacity);

	mov	r9d, 3
	xor	r8d, r8d
	mov	rdx, r10
	lea	rcx, QWORD PTR [r14+8]
	call	?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T32[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	lea	rdi, OFFSET FLAT:??_7Number@Json@@6B@
	mov	QWORD PTR [rax], rdi
	mov	r15, 4607182418800017408		; 3ff0000000000000H
	mov	QWORD PTR [rax+8], r15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T35[rsp], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR $T38[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r14+16]
	cmp	rdx, QWORD PTR [r14+24]
	je	SHORT $LN173@Array
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rsi, rbp
	mov	QWORD PTR $T38[rsp], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 869  :         ++_Mylast;

	add	QWORD PTR [r14+16], 8

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN172@Array
$LN173@Array:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T38[rsp]
	lea	rcx, QWORD PTR [r14+8]
	call	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
	mov	rsi, QWORD PTR $T38[rsp]
$LN172@Array:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T66[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rax+8], r15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T69[rsp], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR $T72[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r14+16]
	cmp	rdx, QWORD PTR [r14+24]
	je	SHORT $LN242@Array
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdi, rbp
	mov	QWORD PTR $T72[rsp], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 869  :         ++_Mylast;

	add	QWORD PTR [r14+16], 8

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN241@Array
$LN242@Array:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T72[rsp]
	lea	rcx, QWORD PTR [r14+8]
	call	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
	mov	rdi, QWORD PTR $T72[rsp]
$LN241@Array:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 40					; 00000028H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdx, rax
	mov	QWORD PTR $T100[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	lea	rax, OFFSET FLAT:??_7String@Json@@6B@
	mov	QWORD PTR [rdx], rax
	vpxor	xmm0, xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rdx+8], xmm0

; 940  :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rdx+24], 3

; 941  :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdx+32], 15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_03FFFJFKND@ABC@
	mov	WORD PTR [rdx+8], ax
	movzx	eax, BYTE PTR ??_C@_03FFFJFKND@ABC@+2
	mov	BYTE PTR [rdx+10], al
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 948  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rdx+11], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T124[rsp], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR $T128[rsp], rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR [r14+16]
	cmp	rax, QWORD PTR [r14+24]
	je	SHORT $LN401@Array
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rcx, rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rax], rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 869  :         ++_Mylast;

	add	QWORD PTR [r14+16], 8

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN400@Array
$LN401@Array:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T128[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR [r14+8]
	call	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
	mov	rcx, QWORD PTR $T128[rsp]
$LN400@Array:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3455 :         if (_Mypair._Myval2) {

	test	rcx, rcx
	je	SHORT $LN443@Array

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
	npad	1
$LN443@Array:

; 3455 :         if (_Mypair._Myval2) {

	test	rdi, rdi
	je	SHORT $LN461@Array

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rdi]
	mov	edx, 1
	mov	rcx, rdi
	call	QWORD PTR [rax]
	npad	1
$LN461@Array:

; 3455 :         if (_Mypair._Myval2) {

	test	rsi, rsi
	je	SHORT $LN479@Array

; 3338 :         delete _Ptr;

	mov	r8, QWORD PTR [rsi]
	mov	edx, 1
	mov	rcx, rsi
	call	QWORD PTR [r8]
	npad	1
$LN479@Array:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h

; 64   : 		}

	mov	rax, r14
	add	rsp, 104				; 00000068H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
??$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z ENDP		; Json::Array::Array<bool,int,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T128 = 32
$T32 = 32
$T66 = 32
$T100 = 32
$T38 = 40
$T72 = 48
this$GSCopy$ = 56
$T35 = 64
$T69 = 72
$T124 = 80
this$ = 160
<values_0>$dead$ = 168
<values_1>$dead$ = 176
<values_2>$dead$ = 184
?dtor$0@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA PROC ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 8
	jmp	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
?dtor$0@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA ENDP ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T128 = 32
$T32 = 32
$T66 = 32
$T100 = 32
$T38 = 40
$T72 = 48
this$GSCopy$ = 56
$T35 = 64
$T69 = 72
$T124 = 80
this$ = 160
<values_0>$dead$ = 168
<values_1>$dead$ = 176
<values_2>$dead$ = 184
?dtor$1@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA PROC ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$1
	lea	rcx, QWORD PTR $T35[rdx]
	jmp	??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::~unique_ptr<Json::Number,std::default_delete<Json::Number> >
?dtor$1@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA ENDP ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T128 = 32
$T32 = 32
$T66 = 32
$T100 = 32
$T38 = 40
$T72 = 48
this$GSCopy$ = 56
$T35 = 64
$T69 = 72
$T124 = 80
this$ = 160
<values_0>$dead$ = 168
<values_1>$dead$ = 176
<values_2>$dead$ = 184
?dtor$2@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA PROC ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$2
	lea	rcx, QWORD PTR $T38[rdx]
	jmp	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
?dtor$2@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA ENDP ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T128 = 32
$T32 = 32
$T66 = 32
$T100 = 32
$T38 = 40
$T72 = 48
this$GSCopy$ = 56
$T35 = 64
$T69 = 72
$T124 = 80
this$ = 160
<values_0>$dead$ = 168
<values_1>$dead$ = 176
<values_2>$dead$ = 184
?dtor$3@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA PROC ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$3
	lea	rcx, QWORD PTR $T69[rdx]
	jmp	??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::~unique_ptr<Json::Number,std::default_delete<Json::Number> >
?dtor$3@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA ENDP ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T128 = 32
$T32 = 32
$T66 = 32
$T100 = 32
$T38 = 40
$T72 = 48
this$GSCopy$ = 56
$T35 = 64
$T69 = 72
$T124 = 80
this$ = 160
<values_0>$dead$ = 168
<values_1>$dead$ = 176
<values_2>$dead$ = 184
?dtor$4@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA PROC ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$4
	lea	rcx, QWORD PTR $T72[rdx]
	jmp	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
?dtor$4@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA ENDP ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T128 = 32
$T32 = 32
$T66 = 32
$T100 = 32
$T38 = 40
$T72 = 48
this$GSCopy$ = 56
$T35 = 64
$T69 = 72
$T124 = 80
this$ = 160
<values_0>$dead$ = 168
<values_1>$dead$ = 176
<values_2>$dead$ = 184
?dtor$12@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA PROC ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$12
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR $T100[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$12@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA ENDP ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T128 = 32
$T32 = 32
$T66 = 32
$T100 = 32
$T38 = 40
$T72 = 48
this$GSCopy$ = 56
$T35 = 64
$T69 = 72
$T124 = 80
this$ = 160
<values_0>$dead$ = 168
<values_1>$dead$ = 176
<values_2>$dead$ = 184
?dtor$5@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA PROC ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$5
	lea	rcx, QWORD PTR $T124[rdx]
	jmp	??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::~unique_ptr<Json::String,std::default_delete<Json::String> >
?dtor$5@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA ENDP ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T128 = 32
$T32 = 32
$T66 = 32
$T100 = 32
$T38 = 40
$T72 = 48
this$GSCopy$ = 56
$T35 = 64
$T69 = 72
$T124 = 80
this$ = 160
<values_0>$dead$ = 168
<values_1>$dead$ = 176
<values_2>$dead$ = 184
?dtor$6@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA PROC ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$6
	lea	rcx, QWORD PTR $T128[rdx]
	jmp	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
?dtor$6@?0???$?0_NHPEBD@Array@Json@@QEAA@_NHPEBD@Z@4HA ENDP ; `Json::Array::Array<bool,int,char const *>'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xiosbase
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 80
_State$ = 88
_Val$dead$ = 88
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 768  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

$LN143:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx

; 769  :     // insert NTBS into char stream
; 770  :     using _Elem = char;
; 771  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 772  : 
; 773  :     ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx

; 775  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	rax, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xiosbase

; 278  :         return _Wide;

	mov	rdi, QWORD PTR [rdx+rcx+40]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp

; 775  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	cmp	rdi, 2
	jl	SHORT $LN17@operator
	dec	rdi
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	edi, edi
$LN18@operator:

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	r14, rsi
	mov	QWORD PTR _Ok$[rsp], rsi

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rcx, QWORD PTR [rdx+rcx+72]

; 71   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN92@operator

; 72   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN92@operator:

; 91   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	jne	SHORT $LN86@operator

; 92   :                 _Ok = false;

	mov	BYTE PTR _Ok$[rsp+8], al

; 93   :                 return;

	jmp	SHORT $LN85@operator
$LN86@operator:

; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rsi+80]

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

	test	rcx, rcx
	je	SHORT $LN88@operator
	cmp	rcx, rsi
	je	SHORT $LN88@operator

; 99   :                 return;
; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	mov	BYTE PTR _Ok$[rsp+8], al
	jmp	SHORT $LN85@operator
$LN88@operator:

; 98   :                 _Ok = true;

	mov	BYTE PTR _Ok$[rsp+8], 1
	mov	al, 1
$LN85@operator:

; 776  :     const typename _Myos::sentry _Ok(_Ostr);
; 777  : 
; 778  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN8@operator

; 779  :         _State |= ios_base::badbit;

	mov	ebx, 4

; 780  :     } else { // state okay, insert

	jmp	$LN22@operator
$LN8@operator:

; 781  :         _TRY_IO_BEGIN
; 782  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	rdx, QWORD PTR [rsi]
	movsxd	rax, DWORD PTR [rdx+4]
	mov	ecx, DWORD PTR [rax+rsi+24]
	and	ecx, 448				; 000001c0H
	cmp	ecx, 64					; 00000040H
	je	SHORT $LN129@operator
	npad	7
$LL4@operator:

; 783  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	rdi, rdi
	jle	SHORT $LN131@operator

; 784  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN140@operator

; 783  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	rdi
	jmp	SHORT $LL4@operator
$LN131@operator:

; 785  :                     _State |= ios_base::badbit; // insertion failed, quit
; 786  :                     break;
; 787  :                 }
; 788  :             }
; 789  :         }
; 790  : 
; 791  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	mov	rdx, QWORD PTR [rsi]
$LN129@operator:
	movsxd	rcx, DWORD PTR [rdx+4]
	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5@
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	cmp	rax, 1
	jne	SHORT $LN140@operator
	npad	5
$LL7@operator:

; 792  :             _State |= ios_base::badbit;
; 793  :         }
; 794  : 
; 795  :         if (_State == ios_base::goodbit) {
; 796  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	rdi, rdi
	jle	SHORT $LN6@operator

; 797  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN140@operator

; 792  :             _State |= ios_base::badbit;
; 793  :         }
; 794  : 
; 795  :         if (_State == ios_base::goodbit) {
; 796  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	rdi
	jmp	SHORT $LL7@operator
$LN140@operator:

; 798  :                     _State |= ios_base::badbit; // insertion failed, quit
; 799  :                     break;
; 800  :                 }
; 801  :             }
; 802  :         }
; 803  : 
; 804  :         _Ostr.width(0);

	mov	ebx, 4
	mov	DWORD PTR _State$[rsp], ebx
$LN6@operator:
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

	mov	QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
	jmp	SHORT $LN22@operator
$LN23@operator:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xiosbase
	mov	rsi, QWORD PTR _Ostr$[rsp]
	mov	ebx, DWORD PTR _State$[rsp]
	mov	r14, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp

; 808  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1

; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

	call	QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

	test	eax, eax
	jne	SHORT $LN25@operator

; 117  :                 this->_Myostr._Osfx();

	mov	rcx, r14
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN25@operator:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [r14]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+r14+72]

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN138@operator

; 79   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN138@operator:

; 809  :     return _Ostr;
; 810  : }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 80
_State$ = 88
_Val$dead$ = 88
?dtor$11@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$11
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$11@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 80
_State$ = 88
_Val$dead$ = 88
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 80
_State$ = 88
_Val$dead$ = 88
?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$17

; 805  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$17
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1012 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1013 :     _Ostr.put(_Ostr.widen('\n'));

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	dl, 10
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
	movzx	edx, al
	mov	rcx, rbx
	call	QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 1014 :     _Ostr.flush();

	mov	rcx, rbx
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1015 :     return _Ostr;

	mov	rax, rbx

; 1016 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??A?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@_K@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::operator[], COMDAT

; 1928 :         auto& _My_data = _Mypair._Myval2;
; 1929 : #if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
; 1930 :         _STL_VERIFY(
; 1931 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1932 : #endif
; 1933 : 
; 1934 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1935 :     }

	ret	0
??A?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@_K@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::size, COMDAT

; 1914 :         auto& _My_data = _Mypair._Myval2;
; 1915 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1916 :     }

	ret	0
?size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 829  :     _CONSTEXPR20 ~vector() noexcept {

$LN62:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]

; 829  :     _CONSTEXPR20 ~vector() noexcept {

	mov	rdi, rcx

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	$LN5@vector
	mov	QWORD PTR [rsp+56], rsi

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN10@vector
$LL11@vector:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN29@vector

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN29@vector:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rsi
	jne	SHORT $LL11@vector
$LN10@vector:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN53@vector

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN42@vector

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN43@vector
$LN42@vector:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN53@vector:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx
$LN43@vector:

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 2095 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 2096 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 2097 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN5@vector:

; 830  :         _Tidy();
; 831  : #if _ITERATOR_DEBUG_LEVEL != 0
; 832  :         auto _Alproxy = _STD _Get_proxy_allocator(_Getal());
; 833  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 834  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 835  :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN59@vector:
??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 671  :         _Mypair._Myval2._Alloc_proxy(_STD _Get_proxy_allocator(_Getal()));
; 672  :     }

	mov	rax, rcx
	ret	0
??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??C?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEBAPEAVValue@Json@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEBAPEAVValue@Json@@XZ PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::operator->, COMDAT

; 3482 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3483 :     }

	ret	0
??C?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEBAPEAVValue@Json@@XZ ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >, COMDAT

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3456 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3457 :         }
; 3458 : 
; 3459 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3460 :         if constexpr (is_pointer_v<pointer>) {
; 3461 :             if (!_STD _Is_constant_evaluated()) {
; 3462 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3463 :                 _Mypair._Myval2 = _Tombstone;
; 3464 :             }
; 3465 :         }
; 3466 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3467 :     }

	ret	0
??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15
	seta	al

; 454  :     }

	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Requested$ = 8
_Old$dead$ = 16
_Max$ = 24
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2885 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rcx, 15
	cmp	rcx, r8

; 2886 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN9@Calculate_

; 2887 :             return _Max;
; 2888 :         }
; 2889 : 
; 2890 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	lea	rax, QWORD PTR [r8-7]
	cmp	rax, 15
	jb	SHORT $LN9@Calculate_

; 2892 :         }
; 2893 : 
; 2894 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, 22
	cmp	rcx, rax
	cmovb	rcx, rax
	mov	rax, rcx

; 2895 :     }

	ret	0
$LN9@Calculate_:

; 2891 :             return _Max;

	mov	rax, r8

; 2895 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1432 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 1432 :     _CONSTEXPR20 ~basic_string() noexcept {

	mov	rbx, rcx

; 453  :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 3169 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN17@basic_stri

; 3170 :             _ASAN_STRING_REMOVE(*this);
; 3171 :             auto& _Al = _Getal();
; 3172 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR [rcx]

; 902  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN31@basic_stri

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN24@basic_stri

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN25@basic_stri
$LN24@basic_stri:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN31@basic_stri:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rax
$LN25@basic_stri:

; 293  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN17@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 3176 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 3177 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 3178 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3179 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 1433 :         _Tidy_deallocate();
; 1434 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1435 :         auto _Alproxy            = _STD _Get_proxy_allocator(_Getal());
; 1436 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1437 :         _Mypair._Myval2._Myproxy = nullptr;
; 1438 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1439 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1440 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN35@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VValue@Json@@@std@@@std@@YA$$QEAU?$default_delete@VValue@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VValue@Json@@@std@@@std@@YA$$QEAU?$default_delete@VValue@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::Value> >, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@U?$default_delete@VValue@Json@@@std@@@std@@YA$$QEAU?$default_delete@VValue@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::Value> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VValue@Json@@@1@$$QEAPEAVValue@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VValue@Json@@@1@$$QEAPEAVValue@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Value>,Json::Value *>, COMDAT

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VValue@Json@@@1@$$QEAPEAVValue@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Value>,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1534 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &>, COMDAT

; 509  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 510  : }

	ret	0
??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$make_unique@VNumber@Json@@AEA_N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEA_N@Z
_TEXT	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
<_Args_0>$ = 72
??$make_unique@VNumber@Json@@AEA_N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEA_N@Z PROC ; std::make_unique<Json::Number,bool &,0>, COMDAT

; 3658 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN21:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	mov	rbx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	movzx	ecx, BYTE PTR [rbx]

; 3660 : }

	mov	rbx, QWORD PTR [rsp+72]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, ecx
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	vmovsd	QWORD PTR [rax+8], xmm0
	lea	rcx, OFFSET FLAT:??_7Number@Json@@6B@
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T2[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	mov	QWORD PTR [rax], rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdi], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	rax, rdi

; 3660 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@VNumber@Json@@AEA_N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEA_N@Z ENDP ; std::make_unique<Json::Number,bool &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$?0VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@1@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Number,std::default_delete<Json::Number>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3423 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@1@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Number,std::default_delete<Json::Number>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$make_unique@VNumber@Json@@AEAH$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEAH@Z
_TEXT	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
<_Args_0>$ = 72
??$make_unique@VNumber@Json@@AEAH$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEAH@Z PROC ; std::make_unique<Json::Number,int &,0>, COMDAT

; 3658 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN21:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	mov	rbx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, DWORD PTR [rbx]

; 3660 : }

	mov	rbx, QWORD PTR [rsp+72]
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Number@Json@@6B@
	vmovsd	QWORD PTR [rax+8], xmm0
	mov	QWORD PTR [rax], rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdi], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T2[rsp], rax
	mov	rax, rdi

; 3660 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@VNumber@Json@@AEAH$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@AEAH@Z ENDP ; std::make_unique<Json::Number,int &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z
_TEXT	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 96
<_Args_0>$ = 104
??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z PROC ; std::make_unique<Json::String,char const * &,0>, COMDAT

; 3658 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN140:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx
	mov	r14, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 40					; 00000028H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r15, rax
	mov	QWORD PTR $T2[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	lea	rax, OFFSET FLAT:??_7String@Json@@6B@
	mov	QWORD PTR [r15], rax
	mov	r12, QWORD PTR [rbx]
	vpxor	xmm0, xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [r15+8], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [r15+24], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [r15+32], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 530  :             return __builtin_strlen(_First);

	mov	rcx, r12
	call	strlen
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 931  :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	cmp	rax, rbp
	ja	$LN137@make_uniqu

; 933  :         }
; 934  : 
; 935  :         auto& _Al     = _Getal();
; 936  :         auto _Alproxy = _STD _Get_proxy_allocator(_Al);
; 937  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 938  : 
; 939  :         if (_Count <= _Small_string_capacity) {

	cmp	rax, 15
	ja	SHORT $LN34@make_uniqu

; 940  :             _My_data._Mysize = _Count;

	mov	QWORD PTR [r15+24], rax

; 941  :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [r15+32], 15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rax
	mov	rdx, r12
	lea	rcx, QWORD PTR [r15+8]
	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 948  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [r15+rdi+8], 0

; 949  :             } else { // _Strat == _Construct_strategy::_From_string
; 950  : #ifdef _INSERT_STRING_ANNOTATION
; 951  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 952  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 953  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 954  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 955  :             }
; 956  : 
; 957  :             _Proxy._Release();
; 958  :             return;

	jmp	$LN32@make_uniqu
$LN34@make_uniqu:

; 2885 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rax, 15

; 2886 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	cmp	rax, rbp
	jbe	SHORT $LN50@make_uniqu

; 2887 :             return _Max;

	mov	rax, -9223372036854775769		; 8000000000000027H
$LN75@make_uniqu:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN76@make_uniqu
	mov	ecx, 5
	int	41					; 00000029H
$LN50@make_uniqu:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rbp, rax
	mov	ecx, 22
	cmp	rax, rcx
	cmovb	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 875  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 231  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN68@make_uniqu

; 232  :         return nullptr;

	xor	ebx, ebx
	jmp	SHORT $LN67@make_uniqu
$LN68@make_uniqu:

; 233  :     }
; 234  : 
; 235  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 236  :     if (_STD is_constant_evaluated()) {
; 237  :         return _Traits::_Allocate(_Bytes);
; 238  :     }
; 239  : #endif // _HAS_CXX20
; 240  : 
; 241  : #ifdef __cpp_aligned_new
; 242  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 243  :         size_t _Passed_align = _Align;
; 244  : #if defined(_M_IX86) || defined(_M_X64)
; 245  :         if (_Bytes >= _Big_allocation_threshold) {
; 246  :             // boost the alignment of big allocations to help autovectorization
; 247  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 248  :         }
; 249  : #endif // defined(_M_IX86) || defined(_M_X64)
; 250  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 251  :     } else
; 252  : #endif // defined(__cpp_aligned_new)
; 253  :     {
; 254  : #if defined(_M_IX86) || defined(_M_X64)
; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN70@make_uniqu

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN138@make_uniqu
	jmp	SHORT $LN75@make_uniqu
$LN76@make_uniqu:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 257  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN67@make_uniqu
$LN70@make_uniqu:

; 140  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN67@make_uniqu:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 963  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [r15+8], rbx

; 964  : 
; 965  :         _My_data._Mysize = _Count;

	mov	QWORD PTR [r15+24], rdi

; 966  :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [r15+32], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	mov	rdx, r12
	mov	rcx, rbx
	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 972  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0
$LN32@make_uniqu:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r14], r15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3659 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	rax, r14

; 3660 : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN137@make_uniqu:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 932  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN138@make_uniqu:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN135@make_uniqu:
??$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z ENDP ; std::make_unique<Json::String,char const * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 96
<_Args_0>$ = 104
?dtor$0@?0???$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z@4HA PROC ; `std::make_unique<Json::String,char const * &,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$make_unique@VString@Json@@AEAPEBD$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@AEAPEBD@Z@4HA ENDP ; `std::make_unique<Json::String,char const * &,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$?0VString@Json@@U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0VString@Json@@U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@1@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::String,std::default_delete<Json::String>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3423 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0VString@Json@@U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@1@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::String,std::default_delete<Json::String>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_proxy_allocator@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA?AU_Fake_allocator@0@AEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Get_proxy_allocator@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA?AU_Fake_allocator@0@AEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Get_proxy_allocator<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1517 :     return {};

	xor	al, al

; 1518 : }

	ret	0
??$_Get_proxy_allocator@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA?AU_Fake_allocator@0@AEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Get_proxy_allocator<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::~unique_ptr<Json::String,std::default_delete<Json::String> >, COMDAT

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3456 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3457 :         }
; 3458 : 
; 3459 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3460 :         if constexpr (is_pointer_v<pointer>) {
; 3461 :             if (!_STD _Is_constant_evaluated()) {
; 3462 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3463 :                 _Mypair._Myval2 = _Tombstone;
; 3464 :             }
; 3465 :         }
; 3466 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3467 :     }

	ret	0
??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::~unique_ptr<Json::String,std::default_delete<Json::String> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::~unique_ptr<Json::Number,std::default_delete<Json::Number> >, COMDAT

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3456 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3457 :         }
; 3458 : 
; 3459 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3460 :         if constexpr (is_pointer_v<pointer>) {
; 3461 :             if (!_STD _Is_constant_evaluated()) {
; 3462 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3463 :                 _Mypair._Myval2 = _Tombstone;
; 3464 :             }
; 3465 :         }
; 3466 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3467 :     }

	ret	0
??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::~unique_ptr<Json::Number,std::default_delete<Json::Number> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal, COMDAT

; 2227 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2228 :     }

	ret	0
?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Tidy, COMDAT

; 2081 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN58:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2082 :         auto& _Al         = _Getal();
; 2083 :         auto& _My_data    = _Mypair._Myval2;
; 2084 :         pointer& _Myfirst = _My_data._Myfirst;
; 2085 :         pointer& _Mylast  = _My_data._Mylast;
; 2086 :         pointer& _Myend   = _My_data._Myend;
; 2087 : 
; 2088 :         _My_data._Orphan_all();
; 2089 : 
; 2090 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rcx
	test	rbx, rbx
	je	$LN2@Tidy
	mov	QWORD PTR [rsp+56], rsi

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN7@Tidy
$LL8@Tidy:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN26@Tidy

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN26@Tidy:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rsi
	jne	SHORT $LL8@Tidy
$LN7@Tidy:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN49@Tidy

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN39@Tidy

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN40@Tidy
$LN39@Tidy:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN49@Tidy:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx
$LN40@Tidy:

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 2095 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 2096 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 2097 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN2@Tidy:

; 2098 :         }
; 2099 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN55@Tidy:
?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$dead$ = 56
?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::reserve, COMDAT

; 1723 :     _CONSTEXPR20 void reserve(_CRT_GUARDOVERFLOW size_type _Newcapacity) {

$LN129:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rbx+16]
	sub	rax, rcx
	sar	rax, 3

; 1724 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1725 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	rax, 3
	jae	SHORT $LN102@reserve
	mov	QWORD PTR [rsp+56], rdi

; 1649 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rbx+8]
	sub	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 140  :         return ::operator new(_Bytes);

	mov	ecx, 24
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1649 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rdi, 3
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 140  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1662 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rcx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1853 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	r10, rax

; 2004 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	mov	rdx, QWORD PTR [rbx]

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rdx, rcx
	je	SHORT $LN39@reserve
	xor	r8d, r8d
	npad	7
$LL40@reserve:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1865 :         ++_Last;

	lea	r10, QWORD PTR [r10+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], r8
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rdx, 8

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r10-8], r9

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rdx, rcx
	jne	SHORT $LL40@reserve
$LN39@reserve:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1668 :         _Change_array(_Newvec, _Size, _Newcapacity);

	mov	r9d, 3
	mov	r8, rdi
	mov	rdx, rax
	mov	rcx, rbx
	call	?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array
	mov	rdi, QWORD PTR [rsp+56]
$LN102@reserve:

; 1726 :             if (_Newcapacity > max_size()) {
; 1727 :                 _Xlength();
; 1728 :             }
; 1729 : 
; 1730 :             _Reallocate<_Reallocation_policy::_At_least>(_Newcapacity);
; 1731 :         }
; 1732 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?reserve@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?push_back@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::push_back, COMDAT

; 844  :         if (_Mylast != _My_data._Myend) {

	mov	r9, QWORD PTR [rcx+8]
	cmp	r9, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rdx]

; 861  :         } else {
; 862  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 863  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 864  :             _ASAN_VECTOR_RELEASE_GUARD;
; 865  :         }
; 866  : 
; 867  :         _Orphan_range(_Mylast, _Mylast);
; 868  :         _Ty& _Result = *_Mylast;
; 869  :         ++_Mylast;

	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [r9], rax
	add	QWORD PTR [rcx+8], 8

; 937  :         // insert by moving into element at end, provide strong guarantee
; 938  :         _Emplace_one_at_back(_STD move(_Val));
; 939  :     }

	ret	0
$LN4@push_back:

; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, r9
	jmp	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
?push_back@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Get_first, COMDAT

; 1559 :         return *this;

	mov	rax, rcx

; 1560 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ?release@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAVValue@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAVValue@Json@@XZ PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3495 :     }

	ret	0
?release@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAVValue@Json@@XZ ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::get_deleter, COMDAT

; 3470 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3471 :     }

	ret	0
?get_deleter@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??R?$default_delete@VValue@Json@@@std@@QEBAXPEAVValue@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VValue@Json@@@std@@QEBAXPEAVValue@Json@@@Z PROC ; std::default_delete<Json::Value>::operator(), COMDAT

; 3336 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3337 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3338 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3339 :     }

	ret	0
??R?$default_delete@VValue@Json@@@std@@QEBAXPEAVValue@Json@@@Z ENDP ; std::default_delete<Json::Value>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 123  :             return _Ok;

	movzx	eax, BYTE PTR [rcx+8]

; 124  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 107  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN19:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 108  : #if !_HAS_EXCEPTIONS
; 109  :             const bool _Zero_uncaught_exceptions = true;
; 110  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

	call	QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

	test	eax, eax
	jne	SHORT $LN2@sentry

; 117  :                 this->_Myostr._Osfx();

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN2@sentry:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rdx+72]

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN16@sentry

; 79   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN16@sentry:

; 118  :             }
; 119  :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN22:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	QWORD PTR [rcx], rdx

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [r8+rdx+72]

; 71   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN8@sentry

; 72   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN8@sentry:

; 91   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN1@sentry

; 92   :                 _Ok = false;
; 93   :                 return;
; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rbx+80]

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

	test	rcx, rcx
	je	SHORT $LN4@sentry
	cmp	rcx, rbx
	je	SHORT $LN4@sentry

; 99   :                 return;
; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	jmp	SHORT $LN1@sentry
$LN4@sentry:

; 98   :                 _Ok = true;

	mov	al, 1
$LN1@sentry:

; 104  :         }

	mov	BYTE PTR [rdi+8], al
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Ostr$ = 56
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3166 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN34:
	push	rbx
	sub	rsp, 32					; 00000020H

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 3166 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	mov	rbx, rcx

; 453  :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 3167 :         auto& _My_data = _Mypair._Myval2;
; 3168 :         _My_data._Orphan_all();
; 3169 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN14@Tidy_deall

; 3170 :             _ASAN_STRING_REMOVE(*this);
; 3171 :             auto& _Al = _Getal();
; 3172 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR [rcx]

; 902  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Tidy_deall

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN21@Tidy_deall

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN22@Tidy_deall
$LN21@Tidy_deall:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN27@Tidy_deall:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rax
$LN22@Tidy_deall:

; 293  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN14@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 3176 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 3177 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 3178 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3179 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 3180 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN31@Tidy_deall:
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 599  :         return static_cast<int_type>(EOF);

	mov	eax, -1

; 600  :     }

	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 591  :         return _Left == _Right;

	cmp	ecx, edx
	sete	al

; 592  :     }

	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 992  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H

; 231  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 232  :         return nullptr;

	xor	eax, eax

; 993  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 994  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 995  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@allocate:

; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN22@allocate

; 140  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN12@allocate
	mov	ecx, 5
	int	41					; 00000029H
$LN12@allocate:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 993  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 994  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 995  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@allocate:

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 993  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 994  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 995  :     }

	add	rsp, 40					; 00000028H

; 140  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN22@allocate:

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN20@allocate:
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Value *>, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@AEA_N@std@@YAAEA_NAEA_N@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEA_N@std@@YAAEA_NAEA_N@Z PROC		; std::forward<bool &>, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@AEA_N@std@@YAAEA_NAEA_N@Z ENDP		; std::forward<bool &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$?0U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@PEAVNumber@Json@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@PEAVNumber@Json@@@Z PROC ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::unique_ptr<Json::Number,std::default_delete<Json::Number> ><std::default_delete<Json::Number>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3399 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@PEAVNumber@Json@@@Z ENDP ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::unique_ptr<Json::Number,std::default_delete<Json::Number> ><std::default_delete<Json::Number>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VNumber@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNumber@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VNumber@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNumber@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::Number> >, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@U?$default_delete@VNumber@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNumber@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::Number> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNumber@Json@@@1@$$QEAPEAVNumber@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNumber@Json@@@1@$$QEAPEAVNumber@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Number>,Json::Number *>, COMDAT

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNumber@Json@@@1@$$QEAPEAVNumber@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Number>,Json::Number *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@AEAH@std@@YAAEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAH@std@@YAAEAHAEAH@Z PROC			; std::forward<int &>, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@AEAH@std@@YAAEAHAEAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@AEAPEBD@std@@YAAEAPEBDAEAPEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEBD@std@@YAAEAPEBDAEAPEBD@Z PROC		; std::forward<char const * &>, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@AEAPEBD@std@@YAAEAPEBDAEAPEBD@Z ENDP		; std::forward<char const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ??$?0AEAPEBD@String@Json@@QEAA@AEAPEBD@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 96
value$ = 104
??$?0AEAPEBD@String@Json@@QEAA@AEAPEBD@Z PROC		; Json::String::String<char const * &>, COMDAT

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

$LN133:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	lea	rax, OFFSET FLAT:??_7String@Json@@6B@
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	ebx, ebx
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	mov	r15, QWORD PTR [rdx]
	mov	r14, rcx
	vpxor	xmm0, xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx+8], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+24], rbx

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+32], rbx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 530  :             return __builtin_strlen(_First);

	mov	rcx, r15
	call	strlen
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 931  :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 530  :             return __builtin_strlen(_First);

	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 931  :         if (_Count > max_size()) {

	cmp	rax, rbp
	ja	$LN130@String

; 933  :         }
; 934  : 
; 935  :         auto& _Al     = _Getal();
; 936  :         auto _Alproxy = _STD _Get_proxy_allocator(_Al);
; 937  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 938  : 
; 939  :         if (_Count <= _Small_string_capacity) {

	cmp	rax, 15
	ja	SHORT $LN27@String
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 940  :             _My_data._Mysize = _Count;

	mov	QWORD PTR [r14+24], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 941  :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [r14+32], 15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	rcx, QWORD PTR [r14+8]
	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 948  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [r14+rdi+8], bl

; 949  :             } else { // _Strat == _Construct_strategy::_From_string
; 950  : #ifdef _INSERT_STRING_ANNOTATION
; 951  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 952  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 953  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 954  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 955  :             }
; 956  : 
; 957  :             _Proxy._Release();
; 958  :             return;

	jmp	$LN25@String
$LN27@String:

; 2885 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rax, 15

; 2886 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	cmp	rax, rbp
	jbe	SHORT $LN43@String

; 2887 :             return _Max;

	mov	rax, -9223372036854775769		; 8000000000000027H
$LN68@String:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN69@String
	mov	ecx, 5
	int	41					; 00000029H
$LN43@String:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 875  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 231  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN60@String

; 232  :         return nullptr;
; 233  :     }
; 234  : 
; 235  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 236  :     if (_STD is_constant_evaluated()) {
; 237  :         return _Traits::_Allocate(_Bytes);
; 238  :     }
; 239  : #endif // _HAS_CXX20
; 240  : 
; 241  : #ifdef __cpp_aligned_new
; 242  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 243  :         size_t _Passed_align = _Align;
; 244  : #if defined(_M_IX86) || defined(_M_X64)
; 245  :         if (_Bytes >= _Big_allocation_threshold) {
; 246  :             // boost the alignment of big allocations to help autovectorization
; 247  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 248  :         }
; 249  : #endif // defined(_M_IX86) || defined(_M_X64)
; 250  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 251  :     } else
; 252  : #endif // defined(__cpp_aligned_new)
; 253  :     {
; 254  : #if defined(_M_IX86) || defined(_M_X64)
; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN63@String

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN131@String
	jmp	SHORT $LN68@String
$LN69@String:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 257  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN60@String
$LN63@String:

; 140  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN60@String:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 963  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [r14+8], rbx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 965  :         _My_data._Mysize = _Count;

	mov	QWORD PTR [r14+24], rdi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 966  :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [r14+32], rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp

; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 972  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0
$LN25@String:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	mov	rbx, QWORD PTR [rsp+112]
	mov	rax, r14
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN130@String:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring

; 932  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN131@String:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN128@String:
??$?0AEAPEBD@String@Json@@QEAA@AEAPEBD@Z ENDP		; Json::String::String<char const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$?0U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@PEAVString@Json@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@PEAVString@Json@@@Z PROC ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::unique_ptr<Json::String,std::default_delete<Json::String> ><std::default_delete<Json::String>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3399 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@PEAVString@Json@@@Z ENDP ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::unique_ptr<Json::String,std::default_delete<Json::String> ><std::default_delete<Json::String>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VString@Json@@@std@@@std@@YA$$QEAU?$default_delete@VString@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VString@Json@@@std@@@std@@YA$$QEAU?$default_delete@VString@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::String> >, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@U?$default_delete@VString@Json@@@std@@@std@@YA$$QEAU?$default_delete@VString@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::String> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0U?$default_delete@VString@Json@@@std@@PEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VString@Json@@@1@$$QEAPEAVString@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VString@Json@@@std@@PEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VString@Json@@@1@$$QEAPEAVString@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::String>,Json::String *>, COMDAT

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VString@Json@@@std@@PEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VString@Json@@@1@$$QEAPEAVString@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::String>,Json::String *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1102 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN35:

; 1106 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN32@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1102 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN22@Destroy_ra

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN22@Destroy_ra:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1107 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1108 :         }
; 1109 :     }
; 1110 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN32@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??$_Reallocate@$0A@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXAEA_K@Z
_TEXT	SEGMENT
this$ = 64
_Newcapacity$ = 72
??$_Reallocate@$0A@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXAEA_K@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Reallocate<0>, COMDAT

; 1642 :     _CONSTEXPR20 void _Reallocate(size_type& _Newcapacity) {

$LN128:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1649 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, rcx
	mov	rbp, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 121  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 2323 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1642 :     _CONSTEXPR20 void _Reallocate(size_type& _Newcapacity) {

	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 121  :         if (_Count > _Max_possible) {

	cmp	rcx, rax
	ja	$LN117@Reallocate

; 122  :             _Throw_bad_array_new_length(); // multiply overflow
; 123  :         }
; 124  :     }
; 125  : 
; 126  :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rcx*8]

; 231  :     if (_Bytes == 0) {

	xor	r14d, r14d
	test	rcx, rcx
	jne	SHORT $LN13@Reallocate

; 232  :         return nullptr;

	mov	ecx, r14d
	jmp	SHORT $LN12@Reallocate
$LN13@Reallocate:

; 233  :     }
; 234  : 
; 235  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 236  :     if (_STD is_constant_evaluated()) {
; 237  :         return _Traits::_Allocate(_Bytes);
; 238  :     }
; 239  : #endif // _HAS_CXX20
; 240  : 
; 241  : #ifdef __cpp_aligned_new
; 242  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 243  :         size_t _Passed_align = _Align;
; 244  : #if defined(_M_IX86) || defined(_M_X64)
; 245  :         if (_Bytes >= _Big_allocation_threshold) {
; 246  :             // boost the alignment of big allocations to help autovectorization
; 247  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 248  :         }
; 249  : #endif // defined(_M_IX86) || defined(_M_X64)
; 250  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 251  :     } else
; 252  : #endif // defined(__cpp_aligned_new)
; 253  :     {
; 254  : #if defined(_M_IX86) || defined(_M_X64)
; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN15@Reallocate

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN117@Reallocate

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN21@Reallocate
	mov	ecx, 5
	int	41					; 00000029H
$LN21@Reallocate:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 257  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Reallocate
$LN15@Reallocate:

; 140  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax
$LN12@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1662 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r11, QWORD PTR [rbx+8]
	sub	rdi, rbp
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2004 :     auto _UFirst      = _STD _Get_unwrapped(_First);

	mov	rdx, QWORD PTR [rbx]

; 1853 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1649 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rdi, 3
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rdx, r11
	je	SHORT $LN32@Reallocate
$LL33@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1865 :         ++_Last;

	lea	r10, QWORD PTR [r10+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], r14
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rdx, 8

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r10-8], rax

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rdx, r11
	jne	SHORT $LL33@Reallocate
$LN32@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 1668 :         _Change_array(_Newvec, _Size, _Newcapacity);

	mov	r9, QWORD PTR [rsi]
	mov	rdx, rcx
	mov	rcx, rbx
	mov	r8, rdi

; 1669 :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi

; 1668 :         _Change_array(_Newvec, _Size, _Newcapacity);

	jmp	?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array
$LN117@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN125@Reallocate:
??$_Reallocate@$0A@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXAEA_K@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Reallocate<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??$_Emplace_one_at_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_one_at_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 840  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 841  :         auto& _My_data   = _Mypair._Myval2;
; 842  :         pointer& _Mylast = _My_data._Mylast;
; 843  : 
; 844  :         if (_Mylast != _My_data._Myend) {

	mov	r9, QWORD PTR [rcx+8]
	cmp	r9, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rdx]

; 861  :         } else {
; 862  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 863  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 864  :             _ASAN_VECTOR_RELEASE_GUARD;
; 865  :         }
; 866  : 
; 867  :         _Orphan_range(_Mylast, _Mylast);
; 868  :         _Ty& _Result = *_Mylast;

	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [r9], rax
	mov	rax, QWORD PTR [rcx+8]

; 869  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 849  :     }

	ret	0
$LN2@Emplace_on:

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, r9
	jmp	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
??$_Emplace_one_at_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_one_at_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$exchange@PEAVValue@Json@@$$T@std@@YAPEAVValue@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVValue@Json@@$$T@std@@YAPEAVValue@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::Value *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVValue@Json@@$$T@std@@YAPEAVValue@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::Value *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >, COMDAT

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1534 : }

	ret	0
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 117  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 118  : 
; 119  :     if constexpr (_Overflow_is_possible) {
; 120  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 121  :         if (_Count > _Max_possible) {
; 122  :             _Throw_bad_array_new_length(); // multiply overflow
; 123  :         }
; 124  :     }
; 125  : 
; 126  :     return _Count * _Ty_size;

	mov	rax, rcx

; 127  : }

	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 229  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN20:
	sub	rsp, 40					; 00000028H

; 230  :     // allocate _Bytes
; 231  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN2@Allocate

; 232  :         return nullptr;

	xor	eax, eax

; 256  :             // boost the alignment of big allocations to help autovectorization
; 257  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 258  :         }
; 259  : #endif // defined(_M_IX86) || defined(_M_X64)
; 260  :         return _Traits::_Allocate(_Bytes);
; 261  :     }
; 262  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@Allocate:

; 233  :     }
; 234  : 
; 235  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 236  :     if (_STD is_constant_evaluated()) {
; 237  :         return _Traits::_Allocate(_Bytes);
; 238  :     }
; 239  : #endif // _HAS_CXX20
; 240  : 
; 241  : #ifdef __cpp_aligned_new
; 242  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 243  :         size_t _Passed_align = _Align;
; 244  : #if defined(_M_IX86) || defined(_M_X64)
; 245  :         if (_Bytes >= _Big_allocation_threshold) {
; 246  :             // boost the alignment of big allocations to help autovectorization
; 247  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 248  :         }
; 249  : #endif // defined(_M_IX86) || defined(_M_X64)
; 250  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 251  :     } else
; 252  : #endif // defined(__cpp_aligned_new)
; 253  :     {
; 254  : #if defined(_M_IX86) || defined(_M_X64)
; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN19@Allocate

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN10@Allocate
	mov	ecx, 5
	int	41					; 00000029H
$LN10@Allocate:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 256  :             // boost the alignment of big allocations to help autovectorization
; 257  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 258  :         }
; 259  : #endif // defined(_M_IX86) || defined(_M_X64)
; 260  :         return _Traits::_Allocate(_Bytes);
; 261  :     }
; 262  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Allocate:
	add	rsp, 40					; 00000028H

; 140  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN19@Allocate:

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN17@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Get_first, COMDAT

; 1559 :         return *this;

	mov	rax, rcx

; 1560 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ?release@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAPEAVString@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAPEAVString@Json@@XZ PROC ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3495 :     }

	ret	0
?release@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAPEAVString@Json@@XZ ENDP ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ PROC ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::get_deleter, COMDAT

; 3470 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3471 :     }

	ret	0
?get_deleter@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ ENDP ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??R?$default_delete@VString@Json@@@std@@QEBAXPEAVString@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VString@Json@@@std@@QEBAXPEAVString@Json@@@Z PROC ; std::default_delete<Json::String>::operator(), COMDAT

; 3336 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3337 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3338 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3339 :     }

	ret	0
??R?$default_delete@VString@Json@@@std@@QEBAXPEAVString@Json@@@Z ENDP ; std::default_delete<Json::String>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Get_first, COMDAT

; 1559 :         return *this;

	mov	rax, rcx

; 1560 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ?release@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAPEAVNumber@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAPEAVNumber@Json@@XZ PROC ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3495 :     }

	ret	0
?release@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAPEAVNumber@Json@@XZ ENDP ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ PROC ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::get_deleter, COMDAT

; 3470 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3471 :     }

	ret	0
?get_deleter@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ ENDP ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??R?$default_delete@VNumber@Json@@@std@@QEBAXPEAVNumber@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VNumber@Json@@@std@@QEBAXPEAVNumber@Json@@@Z PROC ; std::default_delete<Json::Number>::operator(), COMDAT

; 3336 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3337 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3338 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3339 :     }

	ret	0
??R?$default_delete@VNumber@Json@@@std@@QEBAXPEAVNumber@Json@@@Z ENDP ; std::default_delete<Json::Number>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first, COMDAT

; 1559 :         return *this;

	mov	rax, rcx

; 1560 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Xlength, COMDAT

; 2183 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2184 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?capacity@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::capacity, COMDAT

; 1923 :         auto& _My_data = _Mypair._Myval2;
; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1925 :     }

	ret	0
?capacity@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?max_size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size, COMDAT

; 1919 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1920 :     }

	ret	0
?max_size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z PROC ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::deallocate, COMDAT

; 987  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 988  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	r8, QWORD PTR [r8*8]

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rdx, rcx
	sub	rdx, 8
	cmp	rdx, 31
	ja	SHORT $LN11@deallocate

; 206  :     _Bytes += _Non_user_size;

	add	r8, 39					; 00000027H

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN11@deallocate:

; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN15@deallocate:

; 987  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 988  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rdx

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN16@deallocate:
?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z ENDP ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??0?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 978  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN12:
	sub	rsp, 40					; 00000028H

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rdx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rdx+72]

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
	mov	rbx, rcx

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [r8+rdx+72]

; 71   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN9@Sentry_bas

; 72   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
$LN9@Sentry_bas:

; 73   :             }
; 74   :         }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }

	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Old_ptr$ = 16
_Capacity$ = 24
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 901  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 902  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	r8
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN19@Deallocate

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rdx, rcx
	sub	rdx, 8
	cmp	rdx, 31
	ja	SHORT $LN14@Deallocate

; 206  :     _Bytes += _Non_user_size;

	add	r8, 39					; 00000027H

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@Deallocate:

; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN19@Deallocate:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rdx

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN20@Deallocate:
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$?0VNumber@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNumber@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0VNumber@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNumber@Json@@@1@@Z PROC ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Number,0>, COMDAT

; 3334 :     _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0VNumber@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNumber@Json@@@1@@Z ENDP ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Number,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??$?0VString@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VString@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0VString@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VString@Json@@@1@@Z PROC ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::String,0>, COMDAT

; 3334 :     _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0VString@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VString@Json@@@1@@Z ENDP ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::String,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0AEAPEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNumber@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNumber@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1><Json::Number * &>, COMDAT

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNumber@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1><Json::Number * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@PEAVNumber@Json@@@std@@YA$$QEAPEAVNumber@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVNumber@Json@@@std@@YA$$QEAPEAVNumber@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Number *>, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@PEAVNumber@Json@@@std@@YA$$QEAPEAVNumber@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Number *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0AEAPEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVString@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVString@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1><Json::String * &>, COMDAT

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVString@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1><Json::String * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@PEAVString@Json@@@std@@YA$$QEAPEAVString@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVString@Json@@@std@@YA$$QEAPEAVString@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::String *>, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@PEAVString@Json@@@std@@YA$$QEAPEAVString@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::String *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Unfancy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@PEAV10@@Z PROC ; std::_Unfancy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 73   :     return _Ptr;

	mov	rax, rcx

; 74   : }

	ret	0
??$_Unfancy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$destroy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::destroy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rdx]
	test	rcx, rcx
	je	SHORT $LN16@destroy

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN16@destroy:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 747  :     }

	ret	0
??$destroy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::destroy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 2314 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN30:
	sub	rsp, 40					; 00000028H

; 2315 : #if _HAS_CXX23
; 2316 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2317 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2318 :         _Count                  = _Allocated;
; 2319 :         return _Ptr;
; 2320 :     } else
; 2321 : #endif // _HAS_CXX23
; 2322 :     {
; 2323 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 121  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN26@Allocate_a

; 122  :             _Throw_bad_array_new_length(); // multiply overflow
; 123  :         }
; 124  :     }
; 125  : 
; 126  :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rcx*8]

; 231  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN10@Allocate_a

; 232  :         return nullptr;

	xor	eax, eax

; 2324 :     }
; 2325 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@Allocate_a:

; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN12@Allocate_a

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN26@Allocate_a

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN18@Allocate_a
	mov	ecx, 5
	int	41					; 00000029H
$LN18@Allocate_a:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2324 :     }
; 2325 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN12@Allocate_a:
	add	rsp, 40					; 00000028H

; 140  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN26@Allocate_a:

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > * const &>, COMDAT

; 1446 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1447 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1448 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1449 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1450 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1451 :     } else {
; 1452 :         return static_cast<_Iter&&>(_It);
; 1453 :     }
; 1454 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
??$_Uninitialized_move@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1997 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rax, r8

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN69@Uninitiali
	xor	r9d, r9d
	npad	5
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], r9
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 8

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rax], r8

; 1865 :         ++_Last;

	add	rax, 8

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	jne	SHORT $LL4@Uninitiali
$LN69@Uninitiali:

; 2019 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 2020 :     }
; 2021 : 
; 2022 :     return _Backout._Release();
; 2023 : }

	ret	0
??$_Uninitialized_move@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 853  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 854  :         auto& _My_data   = _Mypair._Myval2;
; 855  :         pointer& _Mylast = _My_data._Mylast;
; 856  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 857  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 858  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 859  :             _ASAN_VECTOR_MODIFY(1);
; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx+8]

; 861  :         } else {
; 862  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 863  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 864  :             _ASAN_VECTOR_RELEASE_GUARD;
; 865  :         }
; 866  : 
; 867  :         _Orphan_range(_Mylast, _Mylast);
; 868  :         _Ty& _Result = *_Mylast;

	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [r8], rax
	mov	rax, QWORD PTR [rcx+8]

; 869  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 870  : 
; 871  :         return _Result;
; 872  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 96
_Whereptr$ = 104
<_Val_0>$ = 112
??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 875  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN332:
	push	rbx
	push	r12
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H

; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	r15, QWORD PTR [rcx]
	mov	r12, r8

; 885  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rcx+8]

; 886  : 
; 887  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	sub	r9, r15
	mov	rbx, rdx
	sar	r9, 3
	mov	r14, rcx
	cmp	r9, r8
	je	$LN330@Emplace_re

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, r15
	mov	QWORD PTR [rsp+120], rbp
	sar	rcx, 3

; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+40], rdi
	shr	rdx, 1
	sub	rax, rdx
	mov	QWORD PTR [rsp+32], r13
	cmp	rcx, rax
	ja	$LN310@Emplace_re

; 889  :         }
; 890  : 
; 891  :         const size_type _Newsize = _Oldsize + 1;

	lea	r13, QWORD PTR [r9+1]

; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rcx+rdx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 121  :         if (_Count > _Max_possible) {

	mov	rbp, r13
	cmp	rax, r13
	cmovae	rbp, rax
	cmp	rbp, r8
	ja	$LN310@Emplace_re

; 122  :             _Throw_bad_array_new_length(); // multiply overflow
; 123  :         }
; 124  :     }
; 125  : 
; 126  :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rbp*8]

; 231  :     if (_Bytes == 0) {

	xor	r9d, r9d
	test	rcx, rcx
	jne	SHORT $LN23@Emplace_re

; 232  :         return nullptr;

	mov	edi, r9d
	jmp	SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 233  :     }
; 234  : 
; 235  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 236  :     if (_STD is_constant_evaluated()) {
; 237  :         return _Traits::_Allocate(_Bytes);
; 238  :     }
; 239  : #endif // _HAS_CXX20
; 240  : 
; 241  : #ifdef __cpp_aligned_new
; 242  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 243  :         size_t _Passed_align = _Align;
; 244  : #if defined(_M_IX86) || defined(_M_X64)
; 245  :         if (_Bytes >= _Big_allocation_threshold) {
; 246  :             // boost the alignment of big allocations to help autovectorization
; 247  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 248  :         }
; 249  : #endif // defined(_M_IX86) || defined(_M_X64)
; 250  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 251  :     } else
; 252  : #endif // defined(__cpp_aligned_new)
; 253  :     {
; 254  : #if defined(_M_IX86) || defined(_M_X64)
; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN25@Emplace_re

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN310@Emplace_re

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN31@Emplace_re
	mov	ecx, 5
	int	41					; 00000029H
$LN31@Emplace_re:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 257  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN328@Emplace_re
$LN25@Emplace_re:

; 140  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN328@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	xor	r9d, r9d
$LN22@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r12]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 903  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rdx, rdi
	mov	QWORD PTR [rsp+48], rsi
	mov	rsi, rbx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r12], r9
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	sub	rsi, r15
	sar	rsi, 3
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdi+rsi*8], rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 903  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	r8, QWORD PTR [r14+8]
	mov	rcx, QWORD PTR [r14]
	cmp	rbx, r8
	jne	SHORT $LN3@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, r8
	je	SHORT $LN59@Emplace_re
	npad	9
$LL60@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1865 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], r9
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 8

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx-8], rax

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, r8
	jne	SHORT $LL60@Emplace_re
$LN59@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 909  :         } else { // provide basic guarantee

	lea	rsi, QWORD PTR [rsi*8]
	jmp	SHORT $LN312@Emplace_re
$LN3@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	je	SHORT $LN117@Emplace_re
	npad	10
$LL118@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1865 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], r9
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 8

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx-8], rax

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	jne	SHORT $LL118@Emplace_re
$LN117@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 912  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rdx, QWORD PTR [r14+8]
	lea	rsi, QWORD PTR [rsi*8]
	lea	rcx, QWORD PTR [rsi+8]
	add	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rdx
	je	SHORT $LN312@Emplace_re
	npad	1
$LL176@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1865 :         ++_Last;

	lea	rcx, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx], r9
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 8

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx-8], rax

; 2018 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rdx
	jne	SHORT $LL176@Emplace_re
$LN312@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 916  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbp
	mov	r8, r13
	mov	rdx, rdi
	mov	rcx, r14
	call	?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array
	mov	rbp, QWORD PTR [rsp+120]

; 917  :         return _Newvec + _Whereoff;

	lea	rax, QWORD PTR [rsi+rdi]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+40]
	mov	r13, QWORD PTR [rsp+32]

; 918  :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r12
	pop	rbx
	ret	0
$LN330@Emplace_re:

; 888  :             _Xlength();

	call	?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Xlength
	int	3
$LN310@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN327@Emplace_re:
??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 186  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN10:
	sub	rsp, 40					; 00000028H

; 187  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN9@Allocate_m

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 191  :     }
; 192  : 
; 193  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN3@Allocate_m
	mov	ecx, 5
	int	41					; 00000029H
$LN3@Allocate_m:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 197  : 
; 198  : #ifdef _DEBUG
; 199  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 200  : #endif // defined(_DEBUG)
; 201  :     return _Ptr;
; 202  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN9@Allocate_m:

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN7@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$exchange@PEAVString@Json@@$$T@std@@YAPEAVString@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVString@Json@@$$T@std@@YAPEAVString@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::String *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVString@Json@@$$T@std@@YAPEAVString@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::String *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$exchange@PEAVNumber@Json@@$$T@std@@YAPEAVNumber@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVNumber@Json@@$$T@std@@YAPEAVNumber@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::Number *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVNumber@Json@@$$T@std@@YAPEAVNumber@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::Number *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 8
_Bytes$ = 16
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 266  :     // deallocate storage allocated by _Allocate
; 267  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 268  :     if (_STD is_constant_evaluated()) {
; 269  :         ::operator delete(_Ptr);
; 270  :         return;
; 271  :     }
; 272  : #endif // _HAS_CXX20
; 273  : 
; 274  : #ifdef __cpp_aligned_new
; 275  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 276  :         size_t _Passed_align = _Align;
; 277  : #if defined(_M_IX86) || defined(_M_X64)
; 278  :         if (_Bytes >= _Big_allocation_threshold) {
; 279  :             // boost the alignment of big allocations to help autovectorization
; 280  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 281  :         }
; 282  : #endif // defined(_M_IX86) || defined(_M_X64)
; 283  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 284  :     } else
; 285  : #endif // defined(__cpp_aligned_new)
; 286  :     {
; 287  : #if defined(_M_IX86) || defined(_M_X64)
; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN8@Deallocate

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	mov	rcx, rax
$LN9@Deallocate:

; 289  :             // boost the alignment of big allocations to help autovectorization
; 290  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 291  :         }
; 292  : #endif // defined(_M_IX86) || defined(_M_X64)
; 293  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Deallocate:

; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN11@Deallocate:
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 325  :     if constexpr (is_array_v<_Ty>) {
; 326  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 327  :     } else {
; 328  :         _Obj.~_Ty();
; 329  :     }
; 330  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??1_Simple_reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Simple_reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Simple_reallocation_guard::~_Simple_reallocation_guard, COMDAT

; 637  :             if (_New_begin != nullptr) {

	mov	rdx, QWORD PTR [rcx+8]
	test	rdx, rdx
	je	SHORT $LN8@Simple_rea
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rax*8]

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN20@Simple_rea

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rdx, rcx
	sub	rdx, 8
	cmp	rdx, 31
	ja	SHORT $LN15@Simple_rea

; 206  :     _Bytes += _Non_user_size;

	add	rax, 39					; 00000027H

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, rax
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN15@Simple_rea:

; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN20@Simple_rea:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rdx

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, rax
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Simple_rea:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 640  :         }

	ret	0
$LN21@Simple_rea:
??1_Simple_reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Simple_reallocation_guard::~_Simple_reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size, COMDAT

; 750  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 751  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal, COMDAT

; 2231 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2232 :     }

	ret	0
?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array, COMDAT

; 2059 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

$LN58:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2060 :         // orphan all iterators, discard old array, acquire new array
; 2061 :         auto& _Al         = _Getal();
; 2062 :         auto& _My_data    = _Mypair._Myval2;
; 2063 :         pointer& _Myfirst = _My_data._Myfirst;
; 2064 :         pointer& _Mylast  = _My_data._Mylast;
; 2065 :         pointer& _Myend   = _My_data._Myend;
; 2066 : 
; 2067 :         _My_data._Orphan_all();
; 2068 : 
; 2069 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, r9
	mov	r15, r8
	mov	r14, rdx
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN32@Change_arr
	mov	QWORD PTR [rsp+72], rsi

; 2070 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN7@Change_arr
$LL8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN26@Change_arr

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN26@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rsi
	jne	SHORT $LL8@Change_arr
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN49@Change_arr

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN39@Change_arr

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	add	rdx, 39					; 00000027H
	jmp	SHORT $LN40@Change_arr
$LN39@Change_arr:

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN49@Change_arr:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx
$LN40@Change_arr:

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax
	call	??3@YAXPEAX_K@Z				; operator delete
$LN32@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 2079 :     }

	mov	rbx, QWORD PTR [rsp+80]
	lea	rax, QWORD PTR [r14+r15*8]
	mov	QWORD PTR [rdi], r14
	mov	QWORD PTR [rdi+8], rax
	lea	rax, QWORD PTR [r14+rbp*8]
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN55@Change_arr:
?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rdx, rcx
	sub	rdx, 8
	cmp	rdx, 31
	ja	SHORT $LN11@deallocate

; 206  :     _Bytes += _Non_user_size;

	add	r8, 39					; 00000027H

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN11@deallocate:

; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN15@deallocate:

; 987  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 988  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, rdx

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN16@deallocate:
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	xor	eax, eax
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@AEAPEAVNumber@Json@@@std@@YAAEAPEAVNumber@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVNumber@Json@@@std@@YAAEAPEAVNumber@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Number * &>, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@AEAPEAVNumber@Json@@@std@@YAAEAPEAVNumber@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Number * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$forward@AEAPEAVString@Json@@@std@@YAAEAPEAVString@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVString@Json@@@std@@YAAEAPEAVString@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::String * &>, COMDAT

; 1510 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1511 : }

	ret	0
??$forward@AEAPEAVString@Json@@@std@@YAAEAPEAVString@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::String * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$destroy_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z PROC ; std::destroy_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN14@destroy_at

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN14@destroy_at:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 343  : }

	ret	0
??$destroy_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ENDP ; std::destroy_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 1864 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r8], rax

; 1865 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1866 :     }

	ret	0
??$_Emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$_Construct_in_place@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z PROC ; std::_Construct_in_place<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 515  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	rax, QWORD PTR [rdx]

; 516  : #if _HAS_CXX20
; 517  :     if (_STD is_constant_evaluated()) {
; 518  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 519  :     } else
; 520  : #endif // _HAS_CXX20
; 521  :     {
; 522  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 523  :     }
; 524  : }

	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z ENDP ; std::_Construct_in_place<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$construct@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::construct<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx], rax

; 733  : #if _HAS_CXX20
; 734  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 735  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 736  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 737  : #endif // ^^^ !_HAS_CXX20 ^^^
; 738  :     }

	ret	0
??$construct@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::construct<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 116  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 117  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 118  : 
; 119  :     if constexpr (_Overflow_is_possible) {
; 120  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 121  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 123  :         }
; 124  :     }
; 125  : 
; 126  :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx*8]

; 127  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 122  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Release, COMDAT

; 1869 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1870 :         return _Last;
; 1871 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1858 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN37:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1859 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1106 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Uninitiali
$LL7@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN25@Uninitiali

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN25@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL7@Uninitiali
$LN6@Uninitiali:

; 1860 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1853 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first, COMDAT

; 1563 :         return *this;

	mov	rax, rcx

; 1564 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Reallocation_guard::~_Reallocation_guard, COMDAT

; 620  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

$LN58:
	push	rsi
	sub	rsp, 32					; 00000020H

; 621  :             if (_New_begin != nullptr) {

	cmp	QWORD PTR [rcx+8], 0
	mov	rsi, rcx
	je	$LN32@Reallocati
	mov	QWORD PTR [rsp+56], rbx

; 622  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rbx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+64], rdi
	mov	rdi, QWORD PTR [rcx+32]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN7@Reallocati
	npad	5
$LL8@Reallocati:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN26@Reallocati

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN26@Reallocati:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1106 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL8@Reallocati
$LN7@Reallocati:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 623  :                 _Al.deallocate(_New_begin, _New_capacity);

	mov	rcx, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+56]
	lea	rdx, QWORD PTR [rax*8]

; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN49@Reallocati

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN39@Reallocati

; 206  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 625  :         }

	add	rsp, 32					; 00000020H
	pop	rsi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 293  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN39@Reallocati:

; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	ecx, 5
	int	41					; 00000029H
$LN49@Reallocati:

; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 625  :         }

	add	rsp, 32					; 00000020H
	pop	rsi
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 293  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN32@Reallocati:
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector

; 625  :         }

	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN55@Reallocati:
??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@0@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Orphan_range, COMDAT

; 2223 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@0@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Calculate_growth, COMDAT

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 2012 :             return _Max; // geometric growth would overflow
; 2013 :         }
; 2014 : 
; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 2016 : 
; 2017 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 2018 :             return _Newsize; // geometric growth would be insufficient
; 2019 :         }
; 2020 : 
; 2021 :         return _Geometric; // geometric growth is sufficient
; 2022 :     }

	ret	0
?_Calculate_growth@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z PROC ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocate, COMDAT

; 992  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN27:
	sub	rsp, 40					; 00000028H

; 121  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN23@allocate

; 122  :             _Throw_bad_array_new_length(); // multiply overflow
; 123  :         }
; 124  :     }
; 125  : 
; 126  :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 231  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN8@allocate

; 232  :         return nullptr;

	xor	eax, eax

; 993  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 994  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 995  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN8@allocate:

; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN10@allocate

; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 189  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN23@allocate

; 140  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN16@allocate
	mov	ecx, 5
	int	41					; 00000029H
$LN16@allocate:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 993  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 994  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 995  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN10@allocate:
	add	rsp, 40					; 00000028H

; 140  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN23@allocate:

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN25@allocate:
?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z ENDP ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\memory
;	COMDAT ??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::`scalar deleting destructor', COMDAT
$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3455 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN14@scalar

; 3338 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN14@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1534 : }

	ret	0
??$addressof@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$construct_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@$$QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@$$QEAV10@@Z PROC ; std::construct_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility

; 509  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 510  : }

	ret	0
??$construct_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@$$QEAV10@@Z ENDP ; std::construct_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
END
