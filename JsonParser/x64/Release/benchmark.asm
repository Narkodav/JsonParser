; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35211.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	??_C@_0BH@DPNNDOEK@invalid?5stoul?5argument@	; `string'
PUBLIC	??_C@_0BM@MOLGGFGJ@stoul?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0BG@LNNHAOEF@invalid?5stod?5argument@	; `string'
PUBLIC	??_C@_0BL@PPHDABKE@stod?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_07DCLBNMLN@generic@			; `string'
PUBLIC	??_C@_06FHFOAHML@system@			; `string'
PUBLIC	??_C@_0BB@PFCEIHCG@File?5not?5found?3?5@	; `string'
PUBLIC	??_C@_0P@DKBFGACC@?5iterations?4?4?4@		; `string'
PUBLIC	??_C@_06BIDGLIKJ@?5with?5@			; `string'
PUBLIC	??_C@_0O@GIEEEDME@Benchmarking?5@		; `string'
PUBLIC	??_C@_0BA@IMHBNKKK@Failed?5to?5open?5@		; `string'
PUBLIC	??_C@_06LCIDCBMH@?5bytes@			; `string'
PUBLIC	??_C@_0M@KFCNOOOB@File?5size?3?5@		; `string'
PUBLIC	??_C@_0BK@CGECCDED@Parse?5error?5on?5iteration?5@ ; `string'
PUBLIC	??_C@_03DKJEPNJL@?5ms@				; `string'
PUBLIC	??_C@_0N@LGHPBDLJ@Total?5time?3?5@		; `string'
PUBLIC	??_C@_0BJ@DGPEJFHC@Average?5time?5per?5parse?3?5@ ; `string'
PUBLIC	??_C@_05OPOMHMMM@?5MB?1s@			; `string'
PUBLIC	??_C@_0N@CLDCHGEI@Throughput?3?5@		; `string'
PUBLIC	??_C@_0BE@CEEEFPFP@Parses?5per?5second?3?5@	; `string'
PUBLIC	??_C@_0O@DJOCHAI@Parse?5error?3?5@		; `string'
PUBLIC	??_C@_04KGNIJDJC@?5?N?$LMs@			; `string'
PUBLIC	??_C@_0BO@OECEGPPP@?$DN?$DN?$DN?5JSON?5Parser?5Benchmark?5?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0BA@DPKMFFGL@tests?1test?4json@		; `string'
PUBLIC	??_C@_0BL@OLMDAAM@tests?1test_edge_cases?4json@	; `string'
PUBLIC	??_C@_0O@LLNAIOEN@simple?5object@		; `string'
PUBLIC	??_C@_0BB@KHKLOMNG@?$HL?$CCkey?$CC?3?5?$CCvalue?$CC?$HN@ ; `string'
PUBLIC	??_C@_0N@PEMCCABF@simple?5array@		; `string'
PUBLIC	??_C@_0BA@PLDJKHGB@?$FL1?0?52?0?53?0?54?0?55?$FN@ ; `string'
PUBLIC	??_C@_06EBGNBFIA@number@			; `string'
PUBLIC	??_C@_07GNGCELP@42?45e10@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string@			; `string'
PUBLIC	??_C@_0O@MHBFGJKG@?$CChello?5world?$CC@		; `string'
PUBLIC	??_C@_0P@PFMECINC@complex?5object@		; `string'
PUBLIC	??_C@_0LM@GKIIEDNC@?$HL?6?5?5?5?5?5?5?5?5?$CCname?$CC?3?5?$CCJohn?$CC?0?6?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0BE@HCHBDOOD@Benchmark?5complete?$CB@	; `string'
PUBLIC	??_C@_0BG@LNPEEPID@JSON?5parsing?5failed?3?5@	; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_C@_0BH@HJFABALL@Invalid?5value?5syntax?3?5@	; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0BA@IDEJNKDC@Duplicate?5key?3?5@		; `string'
PUBLIC	??_C@_0P@JPNLNIKK@Endless?5object@		; `string'
PUBLIC	??_C@_0CD@DNDGJFLJ@No?5name?5separator?5after?5object?5@ ; `string'
PUBLIC	??_C@_0CG@LKKKBDCI@No?5value?5separator?5after?5object@ ; `string'
PUBLIC	??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@	; `string'
PUBLIC	??_C@_0O@ELDHGBOG@Endless?5array@		; `string'
PUBLIC	??_C@_0CF@PAAGCNKK@No?5value?5separator?5after?5array?5@ ; `string'
PUBLIC	??_C@_0BG@GELOLNAM@Invalid?5string?5syntax@	; `string'
PUBLIC	??_C@_0BK@GDBLDPAM@Invalid?5bool?5true?5literal@ ; `string'
PUBLIC	??_C@_0BL@MHJMKGJM@Invalid?5bool?5false?5literal@ ; `string'
PUBLIC	??_C@_0BF@GONMNCPG@Invalid?5null?5literal@	; `string'
PUBLIC	??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@	; `string'
PUBLIC	??_C@_0BG@PEGDFFCL@Endless?5block?5comment@	; `string'
PUBLIC	??_C@_0BN@LPMKJIHG@Unterminated?5escape?5sequence@ ; `string'
PUBLIC	??_C@_0BH@JICOIFBC@Invalid?5unicode?5escape@	; `string'
PUBLIC	??_C@_0BL@KLIDEEPE@Invalid?5escape?5sequence?3?5?2@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ ; `string'
PUBLIC	??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ ; `string'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Bool@Json@@8				; Json::Bool::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2Null@Json@@8				; Json::Null::`RTTI Base Class Array'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R4Number@Json@@6B@				; Json::Number::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_TI4?AVsystem_error@std@@
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_7Bool@Json@@6B@				; Json::Bool::`vftable'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_7Number@Json@@6B@				; Json::Number::`vftable'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R3Number@Json@@8				; Json::Number::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3Object@Json@@8				; Json::Object::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_7Value@Json@@6B@				; Json::Value::`vftable'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2Array@Json@@8				; Json::Array::`RTTI Base Class Array'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R2Value@Json@@8				; Json::Value::`RTTI Base Class Array'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R4Array@Json@@6B@				; Json::Array::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	?numberStartCharacters@Parser@Json@@2V?$array@E$0M@@std@@B ; Json::Parser::numberStartCharacters
PUBLIC	?whitespaceCharacters@Parser@Json@@2V?$array@E$03@std@@B ; Json::Parser::whitespaceCharacters
PUBLIC	_CTA2?AVbad_cast@std@@
PUBLIC	?_Unknown_error@?6??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_System_error_category::message'::`7'::_Unknown_error
PUBLIC	??_R3Array@Json@@8				; Json::Array::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R0?AVNull@Json@@@8				; Json::Null `RTTI Type Descriptor'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
PUBLIC	??_R1A@?0A@EA@Bool@Json@@8			; Json::Bool::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Value@Json@@6B@				; Json::Value::`RTTI Complete Object Locator'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@Number@Json@@8			; Json::Number::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2String@Json@@8				; Json::String::`RTTI Base Class Array'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Object@Json@@8			; Json::Object::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	_TI2?AVbad_cast@std@@
PUBLIC	_CTA4?AVsystem_error@std@@
PUBLIC	??_7Object@Json@@6B@				; Json::Object::`vftable'
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static
PUBLIC	??_R4Null@Json@@6B@				; Json::Null::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@Value@Json@@8			; Json::Value::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R3Bool@Json@@8				; Json::Bool::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_R3Null@Json@@8				; Json::Null::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4Bool@Json@@6B@				; Json::Bool::`RTTI Complete Object Locator'
PUBLIC	??_R4String@Json@@6B@				; Json::String::`RTTI Complete Object Locator'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@Array@Json@@8			; Json::Array::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7Null@Json@@6B@				; Json::Null::`vftable'
PUBLIC	??_7Array@Json@@6B@				; Json::Array::`vftable'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	?_Min_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@2_KB ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Min_buckets
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R2Number@Json@@8				; Json::Number::`RTTI Base Class Array'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@Null@Json@@8			; Json::Null::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@String@Json@@8			; Json::String::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3Value@Json@@8				; Json::Value::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4Object@Json@@6B@				; Json::Object::`RTTI Complete Object Locator'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_7String@Json@@6B@				; Json::String::`vftable'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	??_R2Object@Json@@8				; Json::Object::`RTTI Base Class Array'
PUBLIC	??_R3String@Json@@8				; Json::String::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_K@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAPEAD0PEAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp__get_stream_buffer_pointers:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_MapViewOfFile:PROC
EXTRN	__imp__Query_perf_counter:PROC
EXTRN	__imp_fsetpos:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp_CreateFileMappingA:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp_fgetpos:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp__lock_file:PROC
EXTRN	__std_system_error_allocate_message:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp__unlock_file:PROC
EXTRN	_Init_thread_header:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp__purecall:PROC
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	__imp_fgetc:PROC
EXTRN	atexit:PROC
EXTRN	__imp_UnmapViewOfFile:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	_Init_thread_footer:PROC
EXTRN	__imp_?_Syserror_map@std@@YAPEBDH@Z:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z:PROC
EXTRN	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:QWORD
EXTRN	__imp_?_Winerror_map@std@@YAHH@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Id_cnt@id@locale@std@@0HA:DWORD
EXTRN	__imp_?_Xinvalid_argument@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exceptions@std@@YAHXZ:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__imp__Query_perf_frequency:PROC
EXTRN	__imp_fclose:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__imp_strtod:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp__invoke_watson:PROC
EXTRN	_Init_thread_epoch:DWORD
EXTRN	__std_system_error_deallocate_message:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_fputc:PROC
EXTRN	__imp_GetFileSizeEx:PROC
EXTRN	_purecall:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD imagerel ??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3String@Json@@8
rdata$r	SEGMENT
??_R3String@Json@@8 DD 00H				; Json::String::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2String@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2Object@Json@@8
rdata$r	SEGMENT
??_R2Object@Json@@8 DD imagerel ??_R1A@?0A@EA@Object@Json@@8 ; Json::Object::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Value@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7String@Json@@6B@
CONST	SEGMENT
??_7String@Json@@6B@ DQ FLAT:??_R4String@Json@@6B@	; Json::String::`vftable'
	DQ	FLAT:??_EString@Json@@UEAAPEAXI@Z
	DQ	FLAT:?isArray@String@Json@@UEBA_NXZ
	DQ	FLAT:?isBool@String@Json@@UEBA_NXZ
	DQ	FLAT:?isNumber@String@Json@@UEBA_NXZ
	DQ	FLAT:?isObject@String@Json@@UEBA_NXZ
	DQ	FLAT:?isString@String@Json@@UEBA_NXZ
	DQ	FLAT:?isNull@String@Json@@UEBA_NXZ
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DQ FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DQ	FLAT:??_Esystem_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD imagerel ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R4Object@Json@@6B@
rdata$r	SEGMENT
??_R4Object@Json@@6B@ DD 01H				; Json::Object::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVObject@Json@@@8
	DD	imagerel ??_R3Object@Json@@8
	DD	imagerel ??_R4Object@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R3Value@Json@@8
rdata$r	SEGMENT
??_R3Value@Json@@8 DD 00H				; Json::Value::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2Value@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@String@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@String@Json@@8 DD imagerel ??_R0?AVString@Json@@@8 ; Json::String::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3String@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DQ FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DQ	FLAT:??_E_System_error_category@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_System_error_category@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0_System_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Null@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Null@Json@@8 DD imagerel ??_R0?AVNull@Json@@@8 ; Json::Null::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Null@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_cast@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 01H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	imagerel ??_R3bad_cast@std@@8
	DD	imagerel ??_R4bad_cast@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2Number@Json@@8
rdata$r	SEGMENT
??_R2Number@Json@@8 DD imagerel ??_R1A@?0A@EA@Number@Json@@8 ; Json::Number::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Value@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD imagerel ??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD imagerel ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ?_Min_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@2_KB
CONST	SEGMENT
?_Min_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@2_KB DQ 0000000000000008H ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Min_buckets
CONST	ENDS
;	COMDAT ??_7Array@Json@@6B@
CONST	SEGMENT
??_7Array@Json@@6B@ DQ FLAT:??_R4Array@Json@@6B@	; Json::Array::`vftable'
	DQ	FLAT:??_EArray@Json@@UEAAPEAXI@Z
	DQ	FLAT:?isArray@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isBool@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isNumber@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isObject@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isString@Array@Json@@UEBA_NXZ
	DQ	FLAT:?isNull@Array@Json@@UEBA_NXZ
CONST	ENDS
;	COMDAT ??_7Null@Json@@6B@
CONST	SEGMENT
??_7Null@Json@@6B@ DQ FLAT:??_R4Null@Json@@6B@		; Json::Null::`vftable'
	DQ	FLAT:??_ENull@Json@@UEAAPEAXI@Z
	DQ	FLAT:?isArray@Null@Json@@UEBA_NXZ
	DQ	FLAT:?isBool@Null@Json@@UEBA_NXZ
	DQ	FLAT:?isNumber@Null@Json@@UEBA_NXZ
	DQ	FLAT:?isObject@Null@Json@@UEBA_NXZ
	DQ	FLAT:?isString@Null@Json@@UEBA_NXZ
	DQ	FLAT:?isNull@Null@Json@@UEBA_NXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@Array@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Array@Json@@8 DD imagerel ??_R0?AVArray@Json@@@8 ; Json::Array::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Array@Json@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	0b0H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4String@Json@@6B@
rdata$r	SEGMENT
??_R4String@Json@@6B@ DD 01H				; Json::String::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVString@Json@@@8
	DD	imagerel ??_R3String@Json@@8
	DD	imagerel ??_R4String@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R4Bool@Json@@6B@
rdata$r	SEGMENT
??_R4Bool@Json@@6B@ DD 01H				; Json::Bool::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVBool@Json@@@8
	DD	imagerel ??_R3Bool@Json@@8
	DD	imagerel ??_R4Bool@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R3Null@Json@@8
rdata$r	SEGMENT
??_R3Null@Json@@8 DD 00H				; Json::Null::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Null@Json@@8
rdata$r	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DQ FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DQ	FLAT:??_E_System_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3Bool@Json@@8
rdata$r	SEGMENT
??_R3Bool@Json@@8 DD 00H				; Json::Bool::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Bool@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0b0H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Value@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Value@Json@@8 DD imagerel ??_R0?AVValue@Json@@@8 ; Json::Value::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Value@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4Null@Json@@6B@
rdata$r	SEGMENT
??_R4Null@Json@@6B@ DD 01H				; Json::Null::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVNull@Json@@@8
	DD	imagerel ??_R3Null@Json@@8
	DD	imagerel ??_R4Null@Json@@6B@
rdata$r	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B DQ FLAT:??_7_System_error_category@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static
	DQ	0000000000000007H
_DATA	ENDS
;	COMDAT ??_7Object@Json@@6B@
CONST	SEGMENT
??_7Object@Json@@6B@ DQ FLAT:??_R4Object@Json@@6B@	; Json::Object::`vftable'
	DQ	FLAT:??_EObject@Json@@UEAAPEAXI@Z
	DQ	FLAT:?isArray@Object@Json@@UEBA_NXZ
	DQ	FLAT:?isBool@Object@Json@@UEBA_NXZ
	DQ	FLAT:?isNumber@Object@Json@@UEBA_NXZ
	DQ	FLAT:?isObject@Object@Json@@UEBA_NXZ
	DQ	FLAT:?isString@Object@Json@@UEBA_NXZ
	DQ	FLAT:?isNull@Object@Json@@UEBA_NXZ
CONST	ENDS
;	COMDAT _CTA4?AVsystem_error@std@@
xdata$x	SEGMENT
_CTA4?AVsystem_error@std@@ DD 04H
	DD	imagerel _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI2?AVbad_cast@std@@
xdata$x	SEGMENT
_TI2?AVbad_cast@std@@ DD 00H
	DD	imagerel ??1bad_cast@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Object@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Object@Json@@8 DD imagerel ??_R0?AVObject@Json@@@8 ; Json::Object::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Object@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD imagerel ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2String@Json@@8
rdata$r	SEGMENT
??_R2String@Json@@8 DD imagerel ??_R1A@?0A@EA@String@Json@@8 ; Json::String::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Value@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Number@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Number@Json@@8 DD imagerel ??_R0?AVNumber@Json@@@8 ; Json::Number::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Number@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DQ FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DQ	FLAT:??_Ebad_cast@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD imagerel ??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4Value@Json@@6B@
rdata$r	SEGMENT
??_R4Value@Json@@6B@ DD 01H				; Json::Value::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVValue@Json@@@8
	DD	imagerel ??_R3Value@Json@@8
	DD	imagerel ??_R4Value@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Bool@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Bool@Json@@8 DD imagerel ??_R0?AVBool@Json@@@8 ; Json::Bool::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Bool@Json@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0system_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R0?AVNull@Json@@@8
data$rs	SEGMENT
??_R0?AVNull@Json@@@8 DQ FLAT:??_7type_info@@6B@	; Json::Null `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVNull@Json@@', 00H
data$rs	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD imagerel ??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3Array@Json@@8
rdata$r	SEGMENT
??_R3Array@Json@@8 DD 00H				; Json::Array::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Array@Json@@8
rdata$r	ENDS
;	COMDAT ?_Unknown_error@?6??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Unknown_error@?6??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 075H ; `std::_System_error_category::message'::`7'::_Unknown_error
	DB	06eH
	DB	06bH
	DB	06eH
	DB	06fH
	DB	077H
	DB	06eH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT _CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
_CTA2?AVbad_cast@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ?whitespaceCharacters@Parser@Json@@2V?$array@E$03@std@@B
CONST	SEGMENT
?whitespaceCharacters@Parser@Json@@2V?$array@E$03@std@@B DB 020H ; Json::Parser::whitespaceCharacters
	DB	09H
	DB	0dH
	DB	0aH
CONST	ENDS
;	COMDAT ?numberStartCharacters@Parser@Json@@2V?$array@E$0M@@std@@B
CONST	SEGMENT
?numberStartCharacters@Parser@Json@@2V?$array@E$0M@@std@@B DB 030H ; Json::Parser::numberStartCharacters
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02bH
	DB	02dH
CONST	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Array@Json@@6B@
rdata$r	SEGMENT
??_R4Array@Json@@6B@ DD 01H				; Json::Array::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVArray@Json@@@8
	DD	imagerel ??_R3Array@Json@@8
	DD	imagerel ??_R4Array@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$rs	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2Value@Json@@8
rdata$r	SEGMENT
??_R2Value@Json@@8 DD imagerel ??_R1A@?0A@EA@Value@Json@@8 ; Json::Value::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R2Array@Json@@8
rdata$r	SEGMENT
??_R2Array@Json@@8 DD imagerel ??_R1A@?0A@EA@Array@Json@@8 ; Json::Array::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Value@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD imagerel ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B DQ FLAT:??_7_Generic_error_category@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static
	DQ	0000000000000003H
_DATA	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 01H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	imagerel ??_R3system_error@std@@8
	DD	imagerel ??_R4system_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_7Value@Json@@6B@
CONST	SEGMENT
??_7Value@Json@@6B@ DQ FLAT:??_R4Value@Json@@6B@	; Json::Value::`vftable'
	DQ	FLAT:??_EValue@Json@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R3Object@Json@@8
rdata$r	SEGMENT
??_R3Object@Json@@8 DD 00H				; Json::Object::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Object@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3Number@Json@@8
rdata$r	SEGMENT
??_R3Number@Json@@8 DD 00H				; Json::Number::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Number@Json@@8
rdata$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$rs	SEGMENT
??_R0?AV_System_error_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_System_error_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7Number@Json@@6B@
CONST	SEGMENT
??_7Number@Json@@6B@ DQ FLAT:??_R4Number@Json@@6B@	; Json::Number::`vftable'
	DQ	FLAT:??_ENumber@Json@@UEAAPEAXI@Z
	DQ	FLAT:?isArray@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isBool@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isNumber@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isObject@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isString@Number@Json@@UEBA_NXZ
	DQ	FLAT:?isNull@Number@Json@@UEBA_NXZ
CONST	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD imagerel ??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$rs	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DQ FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DQ	FLAT:??_E_Generic_error_category@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_Generic_error_category@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 01H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Generic_error_category@std@@@8
	DD	imagerel ??_R3_Generic_error_category@std@@8
	DD	imagerel ??_R4_Generic_error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD imagerel ??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 01H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	imagerel ??_R3_System_error@std@@8
	DD	imagerel ??_R4_System_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_7Bool@Json@@6B@
CONST	SEGMENT
??_7Bool@Json@@6B@ DQ FLAT:??_R4Bool@Json@@6B@		; Json::Bool::`vftable'
	DQ	FLAT:??_EBool@Json@@UEAAPEAXI@Z
	DQ	FLAT:?isArray@Bool@Json@@UEBA_NXZ
	DQ	FLAT:?isBool@Bool@Json@@UEBA_NXZ
	DQ	FLAT:?isNumber@Bool@Json@@UEBA_NXZ
	DQ	FLAT:?isObject@Bool@Json@@UEBA_NXZ
	DQ	FLAT:?isString@Bool@Json@@UEBA_NXZ
	DQ	FLAT:?isNull@Bool@Json@@UEBA_NXZ
CONST	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 01H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_System_error_category@std@@@8
	DD	imagerel ??_R3_System_error_category@std@@8
	DD	imagerel ??_R4_System_error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT _TI4?AVsystem_error@std@@
xdata$x	SEGMENT
_TI4?AVsystem_error@std@@ DD 00H
	DD	imagerel ??1system_error@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA4?AVsystem_error@std@@
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4Number@Json@@6B@
rdata$r	SEGMENT
??_R4Number@Json@@6B@ DD 01H				; Json::Number::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVNumber@Json@@@8
	DD	imagerel ??_R3Number@Json@@8
	DD	imagerel ??_R4Number@Json@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD imagerel ??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD imagerel ??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_System_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2Null@Json@@8
rdata$r	SEGMENT
??_R2Null@Json@@8 DD imagerel ??_R1A@?0A@EA@Null@Json@@8 ; Json::Null::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Value@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R2Bool@Json@@8
rdata$r	SEGMENT
??_R2Bool@Json@@8 DD imagerel ??_R1A@?0A@EA@Bool@Json@@8 ; Json::Bool::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Value@Json@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
CONST	SEGMENT
??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ DB 'invalid hash bucket '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@ DB 'unordered_map/set t'
	DB	'oo long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KLIDEEPE@Invalid?5escape?5sequence?3?5?2@
CONST	SEGMENT
??_C@_0BL@KLIDEEPE@Invalid?5escape?5sequence?3?5?2@ DB 'Invalid escape se'
	DB	'quence: \', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JICOIFBC@Invalid?5unicode?5escape@
CONST	SEGMENT
??_C@_0BH@JICOIFBC@Invalid?5unicode?5escape@ DB 'Invalid unicode escape', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LPMKJIHG@Unterminated?5escape?5sequence@
CONST	SEGMENT
??_C@_0BN@LPMKJIHG@Unterminated?5escape?5sequence@ DB 'Unterminated escap'
	DB	'e sequence', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PEGDFFCL@Endless?5block?5comment@
CONST	SEGMENT
??_C@_0BG@PEGDFFCL@Endless?5block?5comment@ DB 'Endless block comment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
CONST	SEGMENT
??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@ DB 'Invalid comment syntax', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GONMNCPG@Invalid?5null?5literal@
CONST	SEGMENT
??_C@_0BF@GONMNCPG@Invalid?5null?5literal@ DB 'Invalid null literal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MHJMKGJM@Invalid?5bool?5false?5literal@
CONST	SEGMENT
??_C@_0BL@MHJMKGJM@Invalid?5bool?5false?5literal@ DB 'Invalid bool false '
	DB	'literal', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GDBLDPAM@Invalid?5bool?5true?5literal@
CONST	SEGMENT
??_C@_0BK@GDBLDPAM@Invalid?5bool?5true?5literal@ DB 'Invalid bool true li'
	DB	'teral', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GELOLNAM@Invalid?5string?5syntax@
CONST	SEGMENT
??_C@_0BG@GELOLNAM@Invalid?5string?5syntax@ DB 'Invalid string syntax', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PAAGCNKK@No?5value?5separator?5after?5array?5@
CONST	SEGMENT
??_C@_0CF@PAAGCNKK@No?5value?5separator?5after?5array?5@ DB 'No value sep'
	DB	'arator after array value', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ELDHGBOG@Endless?5array@
CONST	SEGMENT
??_C@_0O@ELDHGBOG@Endless?5array@ DB 'Endless array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@
CONST	SEGMENT
??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@ DB 'Invalid object syntax'
	DB	': ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LKKKBDCI@No?5value?5separator?5after?5object@
CONST	SEGMENT
??_C@_0CG@LKKKBDCI@No?5value?5separator?5after?5object@ DB 'No value sepa'
	DB	'rator after object value', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DNDGJFLJ@No?5name?5separator?5after?5object?5@
CONST	SEGMENT
??_C@_0CD@DNDGJFLJ@No?5name?5separator?5after?5object?5@ DB 'No name sepa'
	DB	'rator after object key', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JPNLNIKK@Endless?5object@
CONST	SEGMENT
??_C@_0P@JPNLNIKK@Endless?5object@ DB 'Endless object', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDEJNKDC@Duplicate?5key?3?5@
CONST	SEGMENT
??_C@_0BA@IDEJNKDC@Duplicate?5key?3?5@ DB 'Duplicate key: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HJFABALL@Invalid?5value?5syntax?3?5@
CONST	SEGMENT
??_C@_0BH@HJFABALL@Invalid?5value?5syntax?3?5@ DB 'Invalid value syntax: '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LNPEEPID@JSON?5parsing?5failed?3?5@
CONST	SEGMENT
??_C@_0BG@LNPEEPID@JSON?5parsing?5failed?3?5@ DB 'JSON parsing failed: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HCHBDOOD@Benchmark?5complete?$CB@
CONST	SEGMENT
??_C@_0BE@HCHBDOOD@Benchmark?5complete?$CB@ DB 'Benchmark complete!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LM@GKIIEDNC@?$HL?6?5?5?5?5?5?5?5?5?$CCname?$CC?3?5?$CCJohn?$CC?0?6?5?5?5?5?5@
CONST	SEGMENT
??_C@_0LM@GKIIEDNC@?$HL?6?5?5?5?5?5?5?5?5?$CCname?$CC?3?5?$CCJohn?$CC?0?6?5?5?5?5?5@ DB '{'
	DB	0aH, '        "name": "John",', 0aH, '        "age": 30,', 0aH
	DB	'        "scores": [95.5, 87, 92.3e-1],', 0aH, '        "addre'
	DB	'ss": {', 0aH, '            "street": "123 Main St",', 0aH, ' '
	DB	'           "city": "Anytown"', 0aH, '        }', 0aH, '    }', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PFMECINC@complex?5object@
CONST	SEGMENT
??_C@_0P@PFMECINC@complex?5object@ DB 'complex object', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MHBFGJKG@?$CChello?5world?$CC@
CONST	SEGMENT
??_C@_0O@MHBFGJKG@?$CChello?5world?$CC@ DB '"hello world"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string@
CONST	SEGMENT
??_C@_06ICGJLFIM@string@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GNGCELP@42?45e10@
CONST	SEGMENT
??_C@_07GNGCELP@42?45e10@ DB '42.5e10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBGNBFIA@number@
CONST	SEGMENT
??_C@_06EBGNBFIA@number@ DB 'number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLDJKHGB@?$FL1?0?52?0?53?0?54?0?55?$FN@
CONST	SEGMENT
??_C@_0BA@PLDJKHGB@?$FL1?0?52?0?53?0?54?0?55?$FN@ DB '[1, 2, 3, 4, 5]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PEMCCABF@simple?5array@
CONST	SEGMENT
??_C@_0N@PEMCCABF@simple?5array@ DB 'simple array', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KHKLOMNG@?$HL?$CCkey?$CC?3?5?$CCvalue?$CC?$HN@
CONST	SEGMENT
??_C@_0BB@KHKLOMNG@?$HL?$CCkey?$CC?3?5?$CCvalue?$CC?$HN@ DB '{"key": "val'
	DB	'ue"}', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LLNAIOEN@simple?5object@
CONST	SEGMENT
??_C@_0O@LLNAIOEN@simple?5object@ DB 'simple object', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OLMDAAM@tests?1test_edge_cases?4json@
CONST	SEGMENT
??_C@_0BL@OLMDAAM@tests?1test_edge_cases?4json@ DB 'tests/test_edge_cases'
	DB	'.json', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPKMFFGL@tests?1test?4json@
CONST	SEGMENT
??_C@_0BA@DPKMFFGL@tests?1test?4json@ DB 'tests/test.json', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OECEGPPP@?$DN?$DN?$DN?5JSON?5Parser?5Benchmark?5?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0BO@OECEGPPP@?$DN?$DN?$DN?5JSON?5Parser?5Benchmark?5?$DN?$DN?$DN@ DB '='
	DB	'== JSON Parser Benchmark ===', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KGNIJDJC@?5?N?$LMs@
CONST	SEGMENT
??_C@_04KGNIJDJC@?5?N?$LMs@ DB ' ', 0ceH, 0bcH, 's', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJOCHAI@Parse?5error?3?5@
CONST	SEGMENT
??_C@_0O@DJOCHAI@Parse?5error?3?5@ DB 'Parse error: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CEEEFPFP@Parses?5per?5second?3?5@
CONST	SEGMENT
??_C@_0BE@CEEEFPFP@Parses?5per?5second?3?5@ DB 'Parses per second: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLDCHGEI@Throughput?3?5@
CONST	SEGMENT
??_C@_0N@CLDCHGEI@Throughput?3?5@ DB 'Throughput: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OPOMHMMM@?5MB?1s@
CONST	SEGMENT
??_C@_05OPOMHMMM@?5MB?1s@ DB ' MB/s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DGPEJFHC@Average?5time?5per?5parse?3?5@
CONST	SEGMENT
??_C@_0BJ@DGPEJFHC@Average?5time?5per?5parse?3?5@ DB 'Average time per pa'
	DB	'rse: ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LGHPBDLJ@Total?5time?3?5@
CONST	SEGMENT
??_C@_0N@LGHPBDLJ@Total?5time?3?5@ DB 'Total time: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DKJEPNJL@?5ms@
CONST	SEGMENT
??_C@_03DKJEPNJL@?5ms@ DB ' ms', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CGECCDED@Parse?5error?5on?5iteration?5@
CONST	SEGMENT
??_C@_0BK@CGECCDED@Parse?5error?5on?5iteration?5@ DB 'Parse error on iter'
	DB	'ation ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KFCNOOOB@File?5size?3?5@
CONST	SEGMENT
??_C@_0M@KFCNOOOB@File?5size?3?5@ DB 'File size: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LCIDCBMH@?5bytes@
CONST	SEGMENT
??_C@_06LCIDCBMH@?5bytes@ DB ' bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IMHBNKKK@Failed?5to?5open?5@
CONST	SEGMENT
??_C@_0BA@IMHBNKKK@Failed?5to?5open?5@ DB 'Failed to open ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GIEEEDME@Benchmarking?5@
CONST	SEGMENT
??_C@_0O@GIEEEDME@Benchmarking?5@ DB 'Benchmarking ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BIDGLIKJ@?5with?5@
CONST	SEGMENT
??_C@_06BIDGLIKJ@?5with?5@ DB ' with ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DKBFGACC@?5iterations?4?4?4@
CONST	SEGMENT
??_C@_0P@DKBFGACC@?5iterations?4?4?4@ DB ' iterations...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PFCEIHCG@File?5not?5found?3?5@
CONST	SEGMENT
??_C@_0BB@PFCEIHCG@File?5not?5found?3?5@ DB 'File not found: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system@
CONST	SEGMENT
??_C@_06FHFOAHML@system@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PPHDABKE@stod?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0BL@PPHDABKE@stod?5argument?5out?5of?5range@ DB 'stod argument out '
	DB	'of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LNNHAOEF@invalid?5stod?5argument@
CONST	SEGMENT
??_C@_0BG@LNNHAOEF@invalid?5stod?5argument@ DB 'invalid stod argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MOLGGFGJ@stoul?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0BM@MOLGGFGJ@stoul?5argument?5out?5of?5range@ DB 'stoul argument ou'
	DB	't of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DPNNDOEK@invalid?5stoul?5argument@
CONST	SEGMENT
??_C@_0BH@DPNNDOEK@invalid?5stoul?5argument@ DB 'invalid stoul argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@QEAAXXZ ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Orphan_non_end
PUBLIC	??0_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Range_eraser::_Range_eraser
PUBLIC	?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Range_eraser::_Bump_erased
PUBLIC	??1_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Range_eraser::~_Range_eraser
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_erase
PUBLIC	?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::clear
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBAAEBMXZ ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::clear
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Unchecked_begin
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1>::_Get_first
PUBLIC	??$exchange@PEAVValue@Json@@$$T@std@@YAPEAVValue@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::Value *,std::nullptr_t>
PUBLIC	??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z ; std::forward<Json::Value *>
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,0>
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?get_deleter@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::get_deleter
PUBLIC	?release@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAVValue@Json@@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first
PUBLIC	?_Do_hash@?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Do_hash
PUBLIC	??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_end
PUBLIC	?bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::bucket
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Min_load_factor_buckets
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Max_bucket_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEBAAEBU?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Get_first
PUBLIC	?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::max_size
PUBLIC	?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@QEAU32@00@Z ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Unchecked_splice
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::operator++
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator==
PUBLIC	??0_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Clear_guard::_Clear_guard
PUBLIC	??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Clear_guard::~_Clear_guard
PUBLIC	?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::max_size
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEBQEAU12@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * const &>
PUBLIC	??$forward@AEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * const &>
PUBLIC	??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@AEBV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
PUBLIC	??$forward@AEAPEAVNumber@Json@@@std@@YAAEAPEAVNumber@Json@@AEAPEAV12@@Z ; std::forward<Json::Number * &>
PUBLIC	??$forward@AEAPEAVNull@Json@@@std@@YAAEAPEAVNull@Json@@AEAPEAV12@@Z ; std::forward<Json::Null * &>
PUBLIC	??$forward@AEAPEAVBool@Json@@@std@@YAAEAPEAVBool@Json@@AEAPEAV12@@Z ; std::forward<Json::Bool * &>
PUBLIC	??$forward@AEAPEAVArray@Json@@@std@@YAAEAPEAVArray@Json@@AEAPEAV12@@Z ; std::forward<Json::Array * &>
PUBLIC	??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@QEAU10@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$forward@AEAPEAVObject@Json@@@std@@YAAEAPEAVObject@Json@@AEAPEAV12@@Z ; std::forward<Json::Object * &>
PUBLIC	??$?0U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VValue@Json@@@1@$$QEAPEAVValue@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Value>,Json::Value *>
PUBLIC	??$forward@U?$default_delete@VValue@Json@@@std@@@std@@YA$$QEAU?$default_delete@VValue@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::Value> >
PUBLIC	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::__autoclassinit2
PUBLIC	??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::`scalar deleting destructor'
PUBLIC	??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator()
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocate
PUBLIC	?capacity@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::capacity
PUBLIC	?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::bucket_count
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::max_load_factor
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Desired_grow_bucket_count
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Forced_rehash
PUBLIC	??R?$_Conditionally_enabled_hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$00@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Conditionally_enabled_hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,1>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Get_first
PUBLIC	?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::max_size
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Release
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * const &>
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > const >
PUBLIC	??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z		; std::_Get_size_of_n<56>
PUBLIC	??$exchange@PEAVArray@Json@@$$T@std@@YAPEAVArray@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::Array *,std::nullptr_t>
PUBLIC	??$exchange@PEAVObject@Json@@$$T@std@@YAPEAVObject@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::Object *,std::nullptr_t>
PUBLIC	??$exchange@PEAVBool@Json@@$$T@std@@YAPEAVBool@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::Bool *,std::nullptr_t>
PUBLIC	??$exchange@PEAVNull@Json@@$$T@std@@YAPEAVNull@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::Null *,std::nullptr_t>
PUBLIC	??$exchange@PEAVNumber@Json@@$$T@std@@YAPEAVNumber@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::Number *,std::nullptr_t>
PUBLIC	??$exchange@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::nullptr_t>
PUBLIC	??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * &>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * &>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *>
PUBLIC	??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@@Z ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$_Emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$move@AEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ; std::move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > &>
PUBLIC	??$construct_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@$$QEAV10@@Z ; std::construct_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$addressof@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ; std::addressof<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$forward@PEAVNumber@Json@@@std@@YA$$QEAPEAVNumber@Json@@AEAPEAV12@@Z ; std::forward<Json::Number *>
PUBLIC	??$?0AEAPEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNumber@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1><Json::Number * &>
PUBLIC	??$forward@PEAVNull@Json@@@std@@YA$$QEAPEAVNull@Json@@AEAPEAV12@@Z ; std::forward<Json::Null *>
PUBLIC	??$?0AEAPEAVNull@Json@@@?$_Compressed_pair@U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNull@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Null>,Json::Null *,1>::_Compressed_pair<std::default_delete<Json::Null>,Json::Null *,1><Json::Null * &>
PUBLIC	??$forward@PEAVBool@Json@@@std@@YA$$QEAPEAVBool@Json@@AEAPEAV12@@Z ; std::forward<Json::Bool *>
PUBLIC	??$?0AEAPEAVBool@Json@@@?$_Compressed_pair@U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVBool@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Bool>,Json::Bool *,1>::_Compressed_pair<std::default_delete<Json::Bool>,Json::Bool *,1><Json::Bool * &>
PUBLIC	??$forward@AEAPEAVString@Json@@@std@@YAAEAPEAVString@Json@@AEAPEAV12@@Z ; std::forward<Json::String * &>
PUBLIC	??$forward@PEAVArray@Json@@@std@@YA$$QEAPEAVArray@Json@@AEAPEAV12@@Z ; std::forward<Json::Array *>
PUBLIC	??$?0AEAPEAVArray@Json@@@?$_Compressed_pair@U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVArray@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Array>,Json::Array *,1>::_Compressed_pair<std::default_delete<Json::Array>,Json::Array *,1><Json::Array * &>
PUBLIC	??$forward@PEAVObject@Json@@@std@@YA$$QEAPEAVObject@Json@@AEAPEAV12@@Z ; std::forward<Json::Object *>
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0AEAPEAVObject@Json@@@?$_Compressed_pair@U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVObject@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Object>,Json::Object *,1>::_Compressed_pair<std::default_delete<Json::Object>,Json::Object *,1><Json::Object * &>
PUBLIC	??$?0VNumber@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNumber@Json@@@1@@Z ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Number,0>
PUBLIC	??$?0VNull@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNull@Json@@@1@@Z ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Null,0>
PUBLIC	??$?0VBool@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VBool@Json@@@1@@Z ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Bool,0>
PUBLIC	??$?0VArray@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VArray@Json@@@1@@Z ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Array,0>
PUBLIC	??$?0VObject@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VObject@Json@@@1@@Z ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Object,0>
PUBLIC	??$?0U?$default_delete@VValue@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><std::default_delete<Json::Value>,0>
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >
PUBLIC	??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::__autoclassinit2
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?max_size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size
PUBLIC	?_Calculate_growth@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@0@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Orphan_range
PUBLIC	??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_KQEAU32@1@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Insert_new_node_before
PUBLIC	?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAXXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Check_max_size
PUBLIC	?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Check_rehash_required_1
PUBLIC	?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Rehash_for_1
PUBLIC	?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::end
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Make_iter
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >::allocate
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >
PUBLIC	??R?$default_delete@VArray@Json@@@std@@QEBAXPEAVArray@Json@@@Z ; std::default_delete<Json::Array>::operator()
PUBLIC	?get_deleter@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAAEAU?$default_delete@VArray@Json@@@2@XZ ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::get_deleter
PUBLIC	?release@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAPEAVArray@Json@@XZ ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@$00@std@@QEAAAEAU?$default_delete@VArray@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::Array>,Json::Array *,1>::_Get_first
PUBLIC	??R?$default_delete@VObject@Json@@@std@@QEBAXPEAVObject@Json@@@Z ; std::default_delete<Json::Object>::operator()
PUBLIC	?get_deleter@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAAEAU?$default_delete@VObject@Json@@@2@XZ ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::get_deleter
PUBLIC	?release@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAPEAVObject@Json@@XZ ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@$00@std@@QEAAAEAU?$default_delete@VObject@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::Object>,Json::Object *,1>::_Get_first
PUBLIC	??R?$default_delete@VBool@Json@@@std@@QEBAXPEAVBool@Json@@@Z ; std::default_delete<Json::Bool>::operator()
PUBLIC	?get_deleter@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAAAEAU?$default_delete@VBool@Json@@@2@XZ ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::get_deleter
PUBLIC	?release@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAAPEAVBool@Json@@XZ ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@$00@std@@QEAAAEAU?$default_delete@VBool@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::Bool>,Json::Bool *,1>::_Get_first
PUBLIC	??R?$default_delete@VNull@Json@@@std@@QEBAXPEAVNull@Json@@@Z ; std::default_delete<Json::Null>::operator()
PUBLIC	?get_deleter@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNull@Json@@@2@XZ ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::get_deleter
PUBLIC	?release@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAAPEAVNull@Json@@XZ ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@$00@std@@QEAAAEAU?$default_delete@VNull@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::Null>,Json::Null *,1>::_Get_first
PUBLIC	??R?$default_delete@VNumber@Json@@@std@@QEBAXPEAVNumber@Json@@@Z ; std::default_delete<Json::Number>::operator()
PUBLIC	?get_deleter@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::get_deleter
PUBLIC	?release@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAPEAVNumber@Json@@XZ ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Get_first
PUBLIC	?_Extract@?$_In_place_key_extract_map_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV32@AEBV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@Z ; std::_In_place_key_extract_map_impl<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::_Extract
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_Release
PUBLIC	??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>
PUBLIC	??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::_Release
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >
PUBLIC	??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * &>
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$exchange@PEAVString@Json@@$$T@std@@YAPEAVString@Json@@AEAPEAV12@$$QEA$$T@Z ; std::exchange<Json::String *,std::nullptr_t>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@@Z ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>
PUBLIC	??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>
PUBLIC	??$destroy_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ; std::destroy_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@AEAU10@@Z ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$_Uninitialized_move@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ; std::_Get_unwrapped<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > * const &>
PUBLIC	??$construct@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::construct<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$_Construct_in_place@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$forward@PEAVString@Json@@@std@@YA$$QEAPEAVString@Json@@AEAPEAV12@@Z ; std::forward<Json::String *>
PUBLIC	??$?0U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNumber@Json@@@1@$$QEAPEAVNumber@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Number>,Json::Number *>
PUBLIC	??$forward@U?$default_delete@VNumber@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNumber@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::Number> >
PUBLIC	??$?0U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@PEAVNumber@Json@@@Z ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::unique_ptr<Json::Number,std::default_delete<Json::Number> ><std::default_delete<Json::Number>,0>
PUBLIC	??$forward@N@std@@YA$$QEANAEAN@Z		; std::forward<double>
PUBLIC	??$?0U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNull@Json@@@1@$$QEAPEAVNull@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Null>,Json::Null *>
PUBLIC	??$forward@U?$default_delete@VNull@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNull@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::Null> >
PUBLIC	??$?0U?$default_delete@VNull@Json@@@std@@$0A@@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAA@PEAVNull@Json@@@Z ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::unique_ptr<Json::Null,std::default_delete<Json::Null> ><std::default_delete<Json::Null>,0>
PUBLIC	??$?0U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VBool@Json@@@1@$$QEAPEAVBool@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Bool>,Json::Bool *>
PUBLIC	??$forward@U?$default_delete@VBool@Json@@@std@@@std@@YA$$QEAU?$default_delete@VBool@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::Bool> >
PUBLIC	??$?0U?$default_delete@VBool@Json@@@std@@$0A@@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAA@PEAVBool@Json@@@Z ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::unique_ptr<Json::Bool,std::default_delete<Json::Bool> ><std::default_delete<Json::Bool>,0>
PUBLIC	??$?0AEAPEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVString@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1><Json::String * &>
PUBLIC	??$?0U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VArray@Json@@@1@$$QEAPEAVArray@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Array>,Json::Array *>
PUBLIC	??$forward@U?$default_delete@VArray@Json@@@std@@@std@@YA$$QEAU?$default_delete@VArray@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::Array> >
PUBLIC	??$?0U?$default_delete@VArray@Json@@@std@@$0A@@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@PEAVArray@Json@@@Z ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::unique_ptr<Json::Array,std::default_delete<Json::Array> ><std::default_delete<Json::Array>,0>
PUBLIC	??$?0U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VObject@Json@@@1@$$QEAPEAVObject@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Object>,Json::Object *>
PUBLIC	??$forward@U?$default_delete@VObject@Json@@@std@@@std@@YA$$QEAU?$default_delete@VObject@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::Object> >
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@$$QEA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,bool,0>
PUBLIC	??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0U?$default_delete@VObject@Json@@@std@@$0A@@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@PEAVObject@Json@@@Z ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::unique_ptr<Json::Object,std::default_delete<Json::Object> ><std::default_delete<Json::Object>,0>
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$?0VString@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VString@Json@@@1@@Z ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::String,0>
PUBLIC	?__autoclassinit2@Array@Json@@QEAAX_K@Z		; Json::Array::__autoclassinit2
PUBLIC	?__autoclassinit2@Object@Json@@QEAAX_K@Z	; Json::Object::__autoclassinit2
PUBLIC	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
PUBLIC	??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@QEBA@QEADQEBD0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1>::operator()
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@00@Z ; std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAMXZ ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size
PUBLIC	?end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::end
PUBLIC	?find@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::find
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Alloc_sentinel_and_proxy
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::deallocate
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::operator==
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1>::_Get_first
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >::allocate
PUBLIC	?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::size
PUBLIC	??A?$array@E$03@std@@QEBAAEBE_K@Z		; std::array<unsigned char,4>::operator[]
PUBLIC	??1?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::~unique_ptr<Json::Array,std::default_delete<Json::Array> >
PUBLIC	??C?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEBAPEAVArray@Json@@XZ ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::operator->
PUBLIC	??1?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::~unique_ptr<Json::Object,std::default_delete<Json::Object> >
PUBLIC	??C?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEBAPEAVObject@Json@@XZ ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::operator->
PUBLIC	??R?$default_delete@VString@Json@@@std@@QEBAXPEAVString@Json@@@Z ; std::default_delete<Json::String>::operator()
PUBLIC	?get_deleter@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::get_deleter
PUBLIC	?release@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAPEAVString@Json@@XZ ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Get_first
PUBLIC	??1?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::~unique_ptr<Json::Bool,std::default_delete<Json::Bool> >
PUBLIC	??1?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::~unique_ptr<Json::Null,std::default_delete<Json::Null> >
PUBLIC	??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::~unique_ptr<Json::Number,std::default_delete<Json::Number> >
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &>
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
PUBLIC	??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > * const &>
PUBLIC	??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &>
PUBLIC	??$forward@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAPEAV10@@Z ; std::forward<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *>
PUBLIC	??$forward@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$destroy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::destroy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Unfancy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@PEAV10@@Z ; std::_Unfancy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$forward@M@std@@YA$$QEAMAEAM@Z		; std::forward<float>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &>
PUBLIC	??$forward@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@0@AEBV10@@Z ; std::forward<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &>
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
PUBLIC	??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z ; Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$skipCommentScalar@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipCommentScalar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$?0U?$default_delete@VString@Json@@@std@@PEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VString@Json@@@1@$$QEAPEAVString@Json@@@Z ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::String>,Json::String *>
PUBLIC	??$forward@U?$default_delete@VString@Json@@@std@@@std@@YA$$QEAU?$default_delete@VString@Json@@@0@AEAU10@@Z ; std::forward<std::default_delete<Json::String> >
PUBLIC	??$?0VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@1@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Number,std::default_delete<Json::Number>,0>
PUBLIC	??$make_unique@VNumber@Json@@N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@$$QEAN@Z ; std::make_unique<Json::Number,double,0>
PUBLIC	??$?0VNull@Json@@U?$default_delete@VNull@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@1@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Null,std::default_delete<Json::Null>,0>
PUBLIC	??$make_unique@VNull@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@0@XZ ; std::make_unique<Json::Null,0>
PUBLIC	??$?0VBool@Json@@U?$default_delete@VBool@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@1@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Bool,std::default_delete<Json::Bool>,0>
PUBLIC	??$make_unique@VBool@Json@@_N$0A@@std@@YA?AV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@0@$$QEA_N@Z ; std::make_unique<Json::Bool,bool,0>
PUBLIC	??$?0U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@PEAVString@Json@@@Z ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::unique_ptr<Json::String,std::default_delete<Json::String> ><std::default_delete<Json::String>,0>
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@String@Json@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::String::String<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Parser::handleEscapedChar<MappedFile<0> >
PUBLIC	??$?0VArray@Json@@U?$default_delete@VArray@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@1@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Array,std::default_delete<Json::Array>,0>
PUBLIC	??$make_unique@VArray@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@0@XZ ; std::make_unique<Json::Array,0>
PUBLIC	??$?0VObject@Json@@U?$default_delete@VObject@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@1@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Object,std::default_delete<Json::Object>,0>
PUBLIC	??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ ; std::make_unique<Json::Object,0>
PUBLIC	??$skipCommentScalar@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipCommentScalar<MappedFile<0> >
PUBLIC	??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipCommentSIMD16<MappedFile<0> >
PUBLIC	??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$?0M@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1><float>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >
PUBLIC	?__autoclassinit2@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAX_K@Z ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAX_K@Z ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::__autoclassinit2
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NAEBV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
PUBLIC	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
PUBLIC	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEBADXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??R?$default_delete@VValue@Json@@@std@@QEBAXPEAVValue@Json@@@Z ; std::default_delete<Json::Value>::operator()
PUBLIC	??0?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::deallocate
PUBLIC	?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??0?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0>::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0>
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Max_bucket_size
PUBLIC	??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Unchecked_end
PUBLIC	?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Getal
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >::deallocate
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::capacity
PUBLIC	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Assign_grow
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1>::_Get_first
PUBLIC	??A?$array@E$0M@@std@@QEBAAEBE_K@Z		; std::array<unsigned char,12>::operator[]
PUBLIC	??A?$MappedFile@$0A@@@QEBAAEBD_K@Z		; MappedFile<0>::operator[]
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Get_first
PUBLIC	??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::~unique_ptr<Json::String,std::default_delete<Json::String> >
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
PUBLIC	??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
PUBLIC	??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
PUBLIC	??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
PUBLIC	??$?0V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@$$QEAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@22@Z ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1><std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *>
PUBLIC	??$exchange@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@$$T@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > &>
PUBLIC	??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1><std::_Zero_then_variadic_args_t,float>
PUBLIC	??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > ><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &,0>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseNumber<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$parseNull@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseNull<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$parseBoolFalse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseBoolFalse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$parseBoolTrue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseBoolTrue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z ; Json::Parser::parseString<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseArray<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Emplace_one_at_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_one_at_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$forward@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$?0VString@Json@@U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@1@@Z ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::String,std::default_delete<Json::String>,0>
PUBLIC	??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseNumber<MappedFile<0> >
PUBLIC	??$parseNull@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseNull<MappedFile<0> >
PUBLIC	??$parseBoolFalse@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseBoolFalse<MappedFile<0> >
PUBLIC	??$parseBoolTrue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseBoolTrue<MappedFile<0> >
PUBLIC	??$make_unique@VString@Json@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::make_unique<Json::String,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseString<MappedFile<0> >
PUBLIC	??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseArray<MappedFile<0> >
PUBLIC	??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseObject<MappedFile<0> >
PUBLIC	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >
PUBLIC	??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::is_open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z	; std::_Narrow_char_traits<char,int>::not_eof
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBADXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
PUBLIC	??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Tidy
PUBLIC	??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??0?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >
PUBLIC	?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Tidy
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Tidy
PUBLIC	?size@?$MappedFile@$0A@@@QEBA_KXZ		; MappedFile<0>::size
PUBLIC	?map@?$MappedFile@$0A@@@QEAAXPEBD@Z		; MappedFile<0>::map
PUBLIC	?unmap@?$MappedFile@$0A@@@QEAAXXZ		; MappedFile<0>::unmap
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1><>
PUBLIC	??$_Hash_array_representation@D@std@@YA_KQEBD_K@Z ; std::_Hash_array_representation<char>
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000> >::duration<__int64,std::ratio<1,1000000> ><__int64,0>
PUBLIC	??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$skipWhitespace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,0>
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>
PUBLIC	??$move@AEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::move<std::istreambuf_iterator<char,std::char_traits<char> > &>
PUBLIC	??$?8DU?$char_traits@D@std@@@std@@YA_NAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
PUBLIC	??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
PUBLIC	??$forward@_N@std@@YA$$QEA_NAEA_N@Z		; std::forward<bool>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::emplace_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$move@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z ; std::move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
PUBLIC	??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseValue<MappedFile<0> >
PUBLIC	??$skipWhitespace@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespace<MappedFile<0> >
PUBLIC	??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$construct_at@D$$V@std@@YAPEADQEAD@Z		; std::construct_at<char>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ	; std::locale::id::_Get_index<0>
PUBLIC	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
PUBLIC	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z	; std::_Get_unwrapped<char * &>
PUBLIC	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z	; std::_UIntegral_to_buff<char,unsigned int>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??0Document@Json@@QEAA@$$QEAV01@@Z		; Json::Document::Document
PUBLIC	?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	?is_open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ifstream<char,std::char_traits<char> >::is_open
PUBLIC	?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@AEAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
PUBLIC	?size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::size
PUBLIC	??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
PUBLIC	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >
PUBLIC	??0?$MappedFile@$0A@@@QEAA@PEBD@Z		; MappedFile<0>::MappedFile<0>
PUBLIC	??1?$MappedFile@$0A@@@QEAA@XZ			; MappedFile<0>::~MappedFile<0>
PUBLIC	?isMapped@?$MappedFile@$0A@@@QEBA_NXZ		; MappedFile<0>::isMapped
PUBLIC	?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000> >,__int64,std::ratio<1,1000000000>,0>
PUBLIC	??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,1000000000>,0>
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::istreambuf_iterator<char,std::char_traits<char> >,0>
PUBLIC	??$_Get_unwrapped@AEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YA?A_TAEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@@Z ; std::_Get_unwrapped<std::istreambuf_iterator<char,std::char_traits<char> > &>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
PUBLIC	??0Document@Json@@QEAA@XZ			; Json::Document::Document
PUBLIC	??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z ; Json::Parser::parse<MappedFile<0> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
PUBLIC	??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@0@XZ ; std::_Immortalize_memcpy_image<std::_System_error_category>
PUBLIC	??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@0@XZ ; std::_Immortalize_memcpy_image<std::_Generic_error_category>
PUBLIC	??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>
PUBLIC	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z		; std::end<char,21>
PUBLIC	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
PUBLIC	main
PUBLIC	?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z ; benchmarkString
PUBLIC	?__autoclassinit2@Document@Json@@QEAAX_K@Z	; Json::Document::__autoclassinit2
PUBLIC	?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; benchmarkFile
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	??1Document@Json@@QEAA@XZ			; Json::Document::~Document
PUBLIC	?__autoclassinit2@?$MappedFile@$0A@@@QEAAX_K@Z	; MappedFile<0>::__autoclassinit2
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Parser::parseFile
PUBLIC	?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1String@Json@@UEAA@XZ				; Json::String::~String
PUBLIC	??_GString@Json@@UEAAPEAXI@Z			; Json::String::`scalar deleting destructor'
PUBLIC	?isNull@String@Json@@UEBA_NXZ			; Json::String::isNull
PUBLIC	?isString@String@Json@@UEBA_NXZ			; Json::String::isString
PUBLIC	?isObject@String@Json@@UEBA_NXZ			; Json::String::isObject
PUBLIC	?isNumber@String@Json@@UEBA_NXZ			; Json::String::isNumber
PUBLIC	?isBool@String@Json@@UEBA_NXZ			; Json::String::isBool
PUBLIC	?isArray@String@Json@@UEBA_NXZ			; Json::String::isArray
PUBLIC	??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::~_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >
PUBLIC	??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
PUBLIC	??1Object@Json@@UEAA@XZ				; Json::Object::~Object
PUBLIC	??_GObject@Json@@UEAAPEAXI@Z			; Json::Object::`scalar deleting destructor'
PUBLIC	?isNull@Object@Json@@UEBA_NXZ			; Json::Object::isNull
PUBLIC	?isString@Object@Json@@UEBA_NXZ			; Json::Object::isString
PUBLIC	?isObject@Object@Json@@UEBA_NXZ			; Json::Object::isObject
PUBLIC	?isNumber@Object@Json@@UEBA_NXZ			; Json::Object::isNumber
PUBLIC	?isBool@Object@Json@@UEBA_NXZ			; Json::Object::isBool
PUBLIC	?isArray@Object@Json@@UEBA_NXZ			; Json::Object::isArray
PUBLIC	??0Object@Json@@QEAA@XZ				; Json::Object::Object
PUBLIC	?_Ceiling_of_log_2@std@@YAK_K@Z			; std::_Ceiling_of_log_2
PUBLIC	?_Floor_of_log_2@std@@YAK_K@Z			; std::_Floor_of_log_2
PUBLIC	??1Number@Json@@UEAA@XZ				; Json::Number::~Number
PUBLIC	??_GNumber@Json@@UEAAPEAXI@Z			; Json::Number::`scalar deleting destructor'
PUBLIC	?isNull@Number@Json@@UEBA_NXZ			; Json::Number::isNull
PUBLIC	?isString@Number@Json@@UEBA_NXZ			; Json::Number::isString
PUBLIC	?isObject@Number@Json@@UEBA_NXZ			; Json::Number::isObject
PUBLIC	?isNumber@Number@Json@@UEBA_NXZ			; Json::Number::isNumber
PUBLIC	?isBool@Number@Json@@UEBA_NXZ			; Json::Number::isBool
PUBLIC	?isArray@Number@Json@@UEBA_NXZ			; Json::Number::isArray
PUBLIC	??0Number@Json@@QEAA@N@Z			; Json::Number::Number
PUBLIC	??1Null@Json@@UEAA@XZ				; Json::Null::~Null
PUBLIC	??_GNull@Json@@UEAAPEAXI@Z			; Json::Null::`scalar deleting destructor'
PUBLIC	?isNull@Null@Json@@UEBA_NXZ			; Json::Null::isNull
PUBLIC	?isString@Null@Json@@UEBA_NXZ			; Json::Null::isString
PUBLIC	?isObject@Null@Json@@UEBA_NXZ			; Json::Null::isObject
PUBLIC	?isNumber@Null@Json@@UEBA_NXZ			; Json::Null::isNumber
PUBLIC	?isBool@Null@Json@@UEBA_NXZ			; Json::Null::isBool
PUBLIC	?isArray@Null@Json@@UEBA_NXZ			; Json::Null::isArray
PUBLIC	??0Null@Json@@QEAA@XZ				; Json::Null::Null
PUBLIC	??1Bool@Json@@UEAA@XZ				; Json::Bool::~Bool
PUBLIC	??_GBool@Json@@UEAAPEAXI@Z			; Json::Bool::`scalar deleting destructor'
PUBLIC	?isNull@Bool@Json@@UEBA_NXZ			; Json::Bool::isNull
PUBLIC	?isString@Bool@Json@@UEBA_NXZ			; Json::Bool::isString
PUBLIC	?isObject@Bool@Json@@UEBA_NXZ			; Json::Bool::isObject
PUBLIC	?isNumber@Bool@Json@@UEBA_NXZ			; Json::Bool::isNumber
PUBLIC	?isBool@Bool@Json@@UEBA_NXZ			; Json::Bool::isBool
PUBLIC	?isArray@Bool@Json@@UEBA_NXZ			; Json::Bool::isArray
PUBLIC	??0Bool@Json@@QEAA@_N@Z				; Json::Bool::Bool
PUBLIC	??_GValue@Json@@UEAAPEAXI@Z			; Json::Value::`scalar deleting destructor'
PUBLIC	??0Value@Json@@QEAA@XZ				; Json::Value::Value
PUBLIC	??1Value@Json@@UEAA@XZ				; Json::Value::~Value
PUBLIC	??1Array@Json@@UEAA@XZ				; Json::Array::~Array
PUBLIC	??_GArray@Json@@UEAAPEAXI@Z			; Json::Array::`scalar deleting destructor'
PUBLIC	?isNull@Array@Json@@UEBA_NXZ			; Json::Array::isNull
PUBLIC	?isString@Array@Json@@UEBA_NXZ			; Json::Array::isString
PUBLIC	?isObject@Array@Json@@UEBA_NXZ			; Json::Array::isObject
PUBLIC	?isNumber@Array@Json@@UEBA_NXZ			; Json::Array::isNumber
PUBLIC	?isBool@Array@Json@@UEBA_NXZ			; Json::Array::isBool
PUBLIC	?isArray@Array@Json@@UEBA_NXZ			; Json::Array::isArray
PUBLIC	??0Array@Json@@QEAA@XZ				; Json::Array::Array
PUBLIC	?roots@Document@Json@@QEBA@XZ			; Json::Document::roots
PUBLIC	??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z	; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z	; std::locale::_Getfacet
PUBLIC	??1locale@std@@QEAA@XZ				; std::locale::~locale
PUBLIC	?system_category@std@@YAAEBVerror_category@1@XZ	; std::system_category
PUBLIC	?generic_category@std@@YAAEBVerror_category@1@XZ ; std::generic_category
PUBLIC	??1_System_error_category@std@@UEAA@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UEAAPEAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?name@_System_error_category@std@@UEBAPEBDXZ	; std::_System_error_category::name
PUBLIC	??1_Generic_error_category@std@@UEAA@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UEAAPEAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	?name@_Generic_error_category@std@@UEBAPEBDXZ	; std::_Generic_error_category::name
PUBLIC	??1_System_error_message@std@@QEAA@XZ		; std::_System_error_message::~_System_error_message
PUBLIC	??0_System_error_message@std@@QEAA@K@Z		; std::_System_error_message::_System_error_message
PUBLIC	??0_System_error@std@@QEAA@AEBV01@@Z		; std::_System_error::_System_error
PUBLIC	??0system_error@std@@QEAA@AEBV01@@Z		; std::system_error::system_error
PUBLIC	??1system_error@std@@UEAA@XZ			; std::system_error::~system_error
PUBLIC	??_Gsystem_error@std@@UEAAPEAXI@Z		; std::system_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
PUBLIC	??1_System_error@std@@UEAA@XZ			; std::_System_error::~_System_error
PUBLIC	??_G_System_error@std@@UEAAPEAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0_System_error@std@@IEAA@Verror_code@1@@Z	; std::_System_error::_System_error
PUBLIC	?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	??8std@@YA_NAEBVerror_condition@0@0@Z		; std::operator==
PUBLIC	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
PUBLIC	?value@error_condition@std@@QEBAHXZ		; std::error_condition::value
PUBLIC	??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
PUBLIC	?value@error_code@std@@QEBAHXZ			; std::error_code::value
PUBLIC	??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_code::error_code
PUBLIC	??1error_category@std@@UEAA@XZ			; std::error_category::~error_category
PUBLIC	??8error_category@std@@QEBA_NAEBV01@@Z		; std::error_category::operator==
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
PUBLIC	?stod@std@@YANAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_K@Z ; std::stod
PUBLIC	?stoul@std@@YAKAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ; std::stoul
PUBLIC	??0bad_cast@std@@QEAA@AEBV01@@Z			; std::bad_cast::bad_cast
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1bad_cast@std@@UEAA@XZ			; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UEAAPEAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QEAA@XZ			; std::bad_cast::bad_cast
PUBLIC	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z	; std::_Fnv1a_append_bytes
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?$TSS0@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS0
PUBLIC	?$TSS1@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS1
PUBLIC	?ws_lf@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_lf
PUBLIC	?$TSS0@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS0
PUBLIC	?ws_lf@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::ws_lf
PUBLIC	?ws_star@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::ws_star
PUBLIC	?ws_cr@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_cr
PUBLIC	?ws_tab@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_tab
PUBLIC	?ws_space@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_space
PUBLIC	?$TSS0@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?ws_lf@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_lf
PUBLIC	?ws_lf@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_lf
PUBLIC	?ws_space@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_space
PUBLIC	?ws_star@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_star
PUBLIC	?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::falseLiteral
PUBLIC	?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::nullLiteral
PUBLIC	?ws_tab@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_tab
PUBLIC	?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::trueLiteral
PUBLIC	?$TSS2@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS2
PUBLIC	?$TSS1@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
PUBLIC	?$TSS3@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS3
PUBLIC	?$TSS1@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS1
PUBLIC	?ws_cr@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_cr
PUBLIC	?$TSS0@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
PUBLIC	?$TSS2@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS2
PUBLIC	?$TSS3@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS3
PUBLIC	?$TSS1@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
EXTRN	??1_Lockit@std@@QEAA@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	??_E_System_error_category@std@@UEAAPEAXI@Z:PROC ; std::_System_error_category::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UEAAPEAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UEAAPEAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UEAAPEAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_E_Generic_error_category@std@@UEAAPEAXI@Z:PROC ; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_EBool@Json@@UEAAPEAXI@Z:PROC			; Json::Bool::`vector deleting destructor'
EXTRN	??_ENull@Json@@UEAAPEAXI@Z:PROC			; Json::Null::`vector deleting destructor'
EXTRN	??_EArray@Json@@UEAAPEAXI@Z:PROC		; Json::Array::`vector deleting destructor'
EXTRN	??_EValue@Json@@UEAAPEAXI@Z:PROC		; Json::Value::`vector deleting destructor'
EXTRN	??_EString@Json@@UEAAPEAXI@Z:PROC		; Json::String::`vector deleting destructor'
EXTRN	??_ENumber@Json@@UEAAPEAXI@Z:PROC		; Json::Number::`vector deleting destructor'
EXTRN	??_EObject@Json@@UEAAPEAXI@Z:PROC		; Json::Object::`vector deleting destructor'
;	COMDAT ?$TSS0@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA
_BSS	SEGMENT
?$TSS0@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?$TSS1@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA
_BSS	SEGMENT
?$TSS1@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS1
_BSS	ENDS
;	COMDAT ?ws_lf@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_lf@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_lf
_BSS	ENDS
;	COMDAT ?$TSS0@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA
_BSS	SEGMENT
?$TSS0@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?ws_lf@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_lf@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::ws_lf
_BSS	ENDS
;	COMDAT ?ws_star@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_star@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::ws_star
_BSS	ENDS
;	COMDAT ?ws_cr@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_cr@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_cr
_BSS	ENDS
;	COMDAT ?ws_tab@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_tab@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_tab
_BSS	ENDS
;	COMDAT ?ws_space@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_space@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_space
_BSS	ENDS
;	COMDAT ?$TSS0@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
_BSS	SEGMENT
?$TSS0@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?ws_lf@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_lf@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_lf
_BSS	ENDS
;	COMDAT ?ws_lf@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_lf@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_lf
_BSS	ENDS
;	COMDAT ?ws_space@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_space@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_space
_BSS	ENDS
;	COMDAT ?ws_star@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_star@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_star
_BSS	ENDS
;	COMDAT ?ws_tab@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_tab@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_tab
_BSS	ENDS
;	COMDAT ?$TSS2@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
_BSS	SEGMENT
?$TSS2@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS2
_BSS	ENDS
;	COMDAT ?$TSS1@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
_BSS	SEGMENT
?$TSS1@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
_BSS	ENDS
;	COMDAT ?$TSS3@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
_BSS	SEGMENT
?$TSS3@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS3
_BSS	ENDS
;	COMDAT ?$TSS1@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA
_BSS	SEGMENT
?$TSS1@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS1
_BSS	ENDS
;	COMDAT ?ws_cr@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B
_BSS	SEGMENT
?ws_cr@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B DB 010H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_cr
_BSS	ENDS
;	COMDAT ?$TSS0@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
_BSS	SEGMENT
?$TSS0@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?$TSS2@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA
_BSS	SEGMENT
?$TSS2@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS2
_BSS	ENDS
;	COMDAT ?$TSS3@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA
_BSS	SEGMENT
?$TSS3@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS3
_BSS	ENDS
;	COMDAT ?$TSS1@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
_BSS	SEGMENT
?$TSS1@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 01H DUP (?) ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN45
	DD	imagerel $LN45+64
	DD	imagerel $unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z DD imagerel $LN28
	DD	imagerel $LN28+71
	DD	imagerel $unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN239
	DD	imagerel $LN239+47
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN239+47
	DD	imagerel $LN239+275
	DD	imagerel $chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN239+275
	DD	imagerel $LN239+288
	DD	imagerel $chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z DD imagerel $LN239+288
	DD	imagerel $LN239+505
	DD	imagerel $chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ DD imagerel $LN61
	DD	imagerel $LN61+35
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ DD imagerel $LN61+35
	DD	imagerel $LN61+86
	DD	imagerel $chain$0$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ DD imagerel $LN61+86
	DD	imagerel $LN61+118
	DD	imagerel $chain$1$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN82
	DD	imagerel $LN82+30
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN82+30
	DD	imagerel $LN82+68
	DD	imagerel $chain$0$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN82+68
	DD	imagerel $LN82+87
	DD	imagerel $chain$2$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN82+87
	DD	imagerel $LN82+134
	DD	imagerel $chain$3$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN82+134
	DD	imagerel $LN82+189
	DD	imagerel $chain$4$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN82+189
	DD	imagerel $LN82+195
	DD	imagerel $chain$5$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z DD imagerel $LN31
	DD	imagerel $LN31+71
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z DD imagerel $LN34
	DD	imagerel $LN34+83
	DD	imagerel $unwind$??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN88
	DD	imagerel $LN88+39
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN88+39
	DD	imagerel $LN88+77
	DD	imagerel $chain$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN88+77
	DD	imagerel $LN88+96
	DD	imagerel $chain$2$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN88+96
	DD	imagerel $LN88+150
	DD	imagerel $chain$3$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN88+150
	DD	imagerel $LN88+205
	DD	imagerel $chain$4$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN88+205
	DD	imagerel $LN88+211
	DD	imagerel $chain$5$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD imagerel $LN190
	DD	imagerel $LN190+50
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD imagerel $LN190+50
	DD	imagerel $LN190+380
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD imagerel $LN190+380
	DD	imagerel $LN190+386
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD imagerel $LN190+386
	DD	imagerel $LN190+392
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z DD imagerel $LN60
	DD	imagerel $LN60+136
	DD	imagerel $unwind$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z DD imagerel $LN51
	DD	imagerel $LN51+88
	DD	imagerel $unwind$??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN97
	DD	imagerel $LN97+39
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN97+39
	DD	imagerel $LN97+200
	DD	imagerel $chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN97+200
	DD	imagerel $LN97+227
	DD	imagerel $chain$3$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z DD imagerel $LN27
	DD	imagerel $LN27+127
	DD	imagerel $unwind$?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN350
	DD	imagerel $LN350+163
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN350+163
	DD	imagerel $LN350+666
	DD	imagerel $chain$6$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN350+666
	DD	imagerel $LN350+701
	DD	imagerel $chain$7$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN24
	DD	imagerel $LN24+37
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN37
	DD	imagerel $LN37+60
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN53
	DD	imagerel $LN53+133
	DD	imagerel $unwind$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@@Z DD imagerel $LN64
	DD	imagerel $LN64+133
	DD	imagerel $unwind$??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z DD imagerel $LN37
	DD	imagerel $LN37+89
	DD	imagerel $unwind$??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN18
	DD	imagerel $LN18+36
	DD	imagerel $unwind$??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD imagerel $LN102
	DD	imagerel $LN102+37
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD imagerel $LN102+37
	DD	imagerel $LN102+205
	DD	imagerel $chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD imagerel $LN102+205
	DD	imagerel $LN102+236
	DD	imagerel $chain$3$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD imagerel $LN57
	DD	imagerel $LN57+39
	DD	imagerel $unwind$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD imagerel $LN57+39
	DD	imagerel $LN57+108
	DD	imagerel $chain$0$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD imagerel $LN57+108
	DD	imagerel $LN57+202
	DD	imagerel $chain$1$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ DD imagerel $LN4@Xlength
	DD	imagerel $LN4@Xlength+18
	DD	imagerel $unwind$?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN57
	DD	imagerel $LN57+16
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN57+16
	DD	imagerel $LN57+97
	DD	imagerel $chain$1$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN57+97
	DD	imagerel $LN57+163
	DD	imagerel $chain$2$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD imagerel $LN6
	DD	imagerel $LN6+39
	DD	imagerel $unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN29
	DD	imagerel $LN29+57
	DD	imagerel $unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD imagerel $LN132
	DD	imagerel $LN132+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD imagerel $LN132+41
	DD	imagerel $LN132+336
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD imagerel $LN132+336
	DD	imagerel $LN132+342
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD imagerel $LN132+342
	DD	imagerel $LN132+348
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD imagerel $LN66
	DD	imagerel $LN66+44
	DD	imagerel $unwind$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD imagerel $LN66+44
	DD	imagerel $LN66+157
	DD	imagerel $chain$2$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD imagerel $LN66+157
	DD	imagerel $LN66+176
	DD	imagerel $chain$3$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN10
	DD	imagerel $LN10+72
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z DD imagerel $LN67
	DD	imagerel $LN67+133
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z DD imagerel $LN30
	DD	imagerel $LN30+130
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DD imagerel $LN97
	DD	imagerel $LN97+138
	DD	imagerel $unwind$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD imagerel $LN64
	DD	imagerel $LN64+207
	DD	imagerel $unwind$??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+15
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN6+15
	DD	imagerel $LN6+41
	DD	imagerel $chain$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN6+41
	DD	imagerel $LN6+47
	DD	imagerel $chain$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN59
	DD	imagerel $LN59+144
	DD	imagerel $unwind$?find@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN27
	DD	imagerel $LN27+127
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN20
	DD	imagerel $LN20+102
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN22
	DD	imagerel $LN22+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN22+62
	DD	imagerel $LN22+98
	DD	imagerel $chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z DD imagerel $LN22+98
	DD	imagerel $LN22+132
	DD	imagerel $chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN41
	DD	imagerel $LN41+36
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z DD imagerel $LN320
	DD	imagerel $LN320+1356
	DD	imagerel $unwind$??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$skipCommentScalar@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD imagerel $LN76
	DD	imagerel $LN76+271
	DD	imagerel $unwind$??$skipCommentScalar@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD imagerel $LN144
	DD	imagerel $LN144+726
	DD	imagerel $unwind$??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN390
	DD	imagerel $LN390+71
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN390+71
	DD	imagerel $LN390+518
	DD	imagerel $chain$3$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN390+518
	DD	imagerel $LN390+544
	DD	imagerel $chain$5$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN390+544
	DD	imagerel $LN390+550
	DD	imagerel $chain$6$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN390+550
	DD	imagerel $LN390+556
	DD	imagerel $chain$7$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VNumber@Json@@N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@$$QEAN@Z DD imagerel $LN21
	DD	imagerel $LN21+72
	DD	imagerel $unwind$??$make_unique@VNumber@Json@@N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@$$QEAN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VNull@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@0@XZ DD imagerel $LN21
	DD	imagerel $LN21+51
	DD	imagerel $unwind$??$make_unique@VNull@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@0@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VBool@Json@@_N$0A@@std@@YA?AV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@0@$$QEA_N@Z DD imagerel $LN21
	DD	imagerel $LN21+69
	DD	imagerel $unwind$??$make_unique@VBool@Json@@_N$0A@@std@@YA?AV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@0@$$QEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN301
	DD	imagerel $LN301+1336
	DD	imagerel $unwind$??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VArray@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@0@XZ DD imagerel $LN33
	DD	imagerel $LN33+85
	DD	imagerel $unwind$??$make_unique@VArray@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@0@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DD imagerel $LN345
	DD	imagerel $LN345+807
	DD	imagerel $unwind$??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ DD imagerel $LN97
	DD	imagerel $LN97+199
	DD	imagerel $unwind$??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA DD imagerel ?dtor$0@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA
	DD	imagerel ?dtor$0@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA+29
	DD	imagerel $unwind$?dtor$0@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$skipCommentScalar@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z DD imagerel $LN38
	DD	imagerel $LN38+206
	DD	imagerel $unwind$??$skipCommentScalar@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z DD imagerel $LN74
	DD	imagerel $LN74+607
	DD	imagerel $unwind$??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD imagerel $LN110
	DD	imagerel $LN110+63
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD imagerel $LN110+63
	DD	imagerel $LN110+118
	DD	imagerel $chain$0$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD imagerel $LN110+118
	DD	imagerel $LN110+201
	DD	imagerel $chain$1$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD imagerel $LN150
	DD	imagerel $LN150+47
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD imagerel $LN150+47
	DD	imagerel $LN150+205
	DD	imagerel $chain$2$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD imagerel $LN150+205
	DD	imagerel $LN150+290
	DD	imagerel $chain$3$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN23
	DD	imagerel $LN23+104
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN15
	DD	imagerel $LN15+80
	DD	imagerel $unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel $LN30
	DD	imagerel $LN30+335
	DD	imagerel $unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN40
	DD	imagerel $LN40+23
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN22
	DD	imagerel $LN22+82
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z DD imagerel $LN57
	DD	imagerel $LN57+71
	DD	imagerel $unwind$?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD imagerel $LN39
	DD	imagerel $LN39+119
	DD	imagerel $unwind$??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NAEBV12@@Z DD imagerel $LN46
	DD	imagerel $LN46+143
	DD	imagerel $unwind$?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+55
	DD	imagerel $unwind$?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEBADXZ DD imagerel $LN17
	DD	imagerel $LN17+62
	DD	imagerel $unwind$?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEBADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN13
	DD	imagerel $LN13+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+86
	DD	imagerel $unwind$?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z DD imagerel $LN34
	DD	imagerel $LN34+47
	DD	imagerel $unwind$??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN18
	DD	imagerel $LN18+86
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD imagerel $LN94
	DD	imagerel $LN94+58
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD imagerel $LN94+58
	DD	imagerel $LN94+257
	DD	imagerel $chain$0$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD imagerel $LN94+257
	DD	imagerel $LN94+271
	DD	imagerel $chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD imagerel $LN94+271
	DD	imagerel $LN94+293
	DD	imagerel $chain$2$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD imagerel $LN94+293
	DD	imagerel $LN94+335
	DD	imagerel $chain$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD imagerel $LN94+335
	DD	imagerel $LN94+341
	DD	imagerel $chain$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN14
	DD	imagerel $LN14+72
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD imagerel $LN11
	DD	imagerel $LN11+52
	DD	imagerel $unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN166
	DD	imagerel $LN166+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN166+56
	DD	imagerel $LN166+402
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN166+402
	DD	imagerel $LN166+408
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN166+408
	DD	imagerel $LN166+414
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN132
	DD	imagerel $LN132+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN132+47
	DD	imagerel $LN132+362
	DD	imagerel $chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN132+362
	DD	imagerel $LN132+368
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD imagerel $LN132+368
	DD	imagerel $LN132+374
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z DD imagerel $LN35
	DD	imagerel $LN35+59
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN57
	DD	imagerel $LN57+25
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN57+25
	DD	imagerel $LN57+70
	DD	imagerel $chain$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN57+70
	DD	imagerel $LN57+76
	DD	imagerel $chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD imagerel $LN255
	DD	imagerel $LN255+661
	DD	imagerel $unwind$??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseNull@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD imagerel $LN82
	DD	imagerel $LN82+187
	DD	imagerel $unwind$??$parseNull@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseBoolFalse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD imagerel $LN82
	DD	imagerel $LN82+191
	DD	imagerel $unwind$??$parseBoolFalse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseBoolTrue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD imagerel $LN82
	DD	imagerel $LN82+191
	DD	imagerel $unwind$??$parseBoolTrue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z DD imagerel $LN140
	DD	imagerel $LN140+398
	DD	imagerel $unwind$??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z@4HA DD imagerel ?dtor$0@?0???$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD imagerel $LN196
	DD	imagerel $LN196+440
	DD	imagerel $unwind$??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD imagerel $LN298
	DD	imagerel $LN298+933
	DD	imagerel $unwind$??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD imagerel $LN195
	DD	imagerel $LN195+783
	DD	imagerel $unwind$??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD imagerel $LN247
	DD	imagerel $LN247+649
	DD	imagerel $unwind$??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseNull@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD imagerel $LN73
	DD	imagerel $LN73+176
	DD	imagerel $unwind$??$parseNull@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseBoolFalse@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD imagerel $LN73
	DD	imagerel $LN73+180
	DD	imagerel $unwind$??$parseBoolFalse@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseBoolTrue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD imagerel $LN73
	DD	imagerel $LN73+180
	DD	imagerel $unwind$??$parseBoolTrue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@VString@Json@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN65
	DD	imagerel $LN65+119
	DD	imagerel $unwind$??$make_unique@VString@Json@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD imagerel $LN110
	DD	imagerel $LN110+358
	DD	imagerel $unwind$??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA DD imagerel ?dtor$0@?0???$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD imagerel $LN170
	DD	imagerel $LN170+409
	DD	imagerel $unwind$??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD imagerel $LN258
	DD	imagerel $LN258+971
	DD	imagerel $unwind$??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z DD imagerel $LN113
	DD	imagerel $LN113+695
	DD	imagerel $unwind$??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN99
	DD	imagerel $LN99+78
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN99+78
	DD	imagerel $LN99+257
	DD	imagerel $chain$0$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN99+257
	DD	imagerel $LN99+263
	DD	imagerel $chain$1$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN99+263
	DD	imagerel $LN99+269
	DD	imagerel $chain$2$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z DD imagerel $LN65
	DD	imagerel $LN65+145
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN18
	DD	imagerel $LN18+81
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN34
	DD	imagerel $LN34+31
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN34+31
	DD	imagerel $LN34+117
	DD	imagerel $chain$0$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN34+117
	DD	imagerel $LN34+180
	DD	imagerel $chain$1$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+192
	DD	imagerel $unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN28
	DD	imagerel $LN28+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN28+53
	DD	imagerel $LN28+148
	DD	imagerel $chain$0$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN28+148
	DD	imagerel $LN28+211
	DD	imagerel $chain$2$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN28+211
	DD	imagerel $LN28+232
	DD	imagerel $chain$3$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD imagerel $LN9
	DD	imagerel $LN9+72
	DD	imagerel $unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD imagerel $LN51
	DD	imagerel $LN51+500
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z DD imagerel $LN108
	DD	imagerel $LN108+314
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z DD imagerel $LN39
	DD	imagerel $LN39+72
	DD	imagerel $unwind$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN52
	DD	imagerel $LN52+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN52+35
	DD	imagerel $LN52+98
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN52+98
	DD	imagerel $LN52+128
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD imagerel $LN59
	DD	imagerel $LN59+71
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD imagerel $LN22
	DD	imagerel $LN22+57
	DD	imagerel $unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN33
	DD	imagerel $LN33+114
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBADXZ DD imagerel $LN23
	DD	imagerel $LN23+78
	DD	imagerel $unwind$??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN16
	DD	imagerel $LN16+61
	DD	imagerel $unwind$??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN22
	DD	imagerel $LN22+133
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN19
	DD	imagerel $LN19+62
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN57
	DD	imagerel $LN57+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN57+21
	DD	imagerel $LN57+90
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN57+90
	DD	imagerel $LN57+167
	DD	imagerel $chain$1$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z DD imagerel $LN60
	DD	imagerel $LN60+119
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN95
	DD	imagerel $LN95+35
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN95+35
	DD	imagerel $LN95+86
	DD	imagerel $chain$0$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN95+86
	DD	imagerel $LN95+109
	DD	imagerel $chain$1$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN29
	DD	imagerel $LN29+109
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?map@?$MappedFile@$0A@@@QEAAXPEBD@Z DD imagerel $LN14
	DD	imagerel $LN14+383
	DD	imagerel $unwind$?map@?$MappedFile@$0A@@@QEAAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?unmap@?$MappedFile@$0A@@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+66
	DD	imagerel $unwind$?unmap@?$MappedFile@$0A@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel $LN54
	DD	imagerel $LN54+314
	DD	imagerel $unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD imagerel $LN420
	DD	imagerel $LN420+1008
	DD	imagerel $unwind$??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z DD imagerel $LN240
	DD	imagerel $LN240+626
	DD	imagerel $unwind$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@@std@@YA_NAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z DD imagerel $LN48
	DD	imagerel $LN48+143
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@@std@@YA_NAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel $LN139
	DD	imagerel $LN139+461
	DD	imagerel $unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+59
	DD	imagerel $unwind$?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD imagerel $LN388
	DD	imagerel $LN388+971
	DD	imagerel $unwind$??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN26
	DD	imagerel $LN26+107
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ DD imagerel $LN10
	DD	imagerel $LN10+119
	DD	imagerel $unwind$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD imagerel $LN119
	DD	imagerel $LN119+316
	DD	imagerel $unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD imagerel $LN58
	DD	imagerel $LN58+108
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN29
	DD	imagerel $LN29+137
	DD	imagerel $unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+59
	DD	imagerel $unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+105
	DD	imagerel $unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN89
	DD	imagerel $LN89+111
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN89+111
	DD	imagerel $LN89+409
	DD	imagerel $chain$0$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN89+409
	DD	imagerel $LN89+439
	DD	imagerel $chain$1$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN110
	DD	imagerel $LN110+226
	DD	imagerel $unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN39
	DD	imagerel $LN39+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN39+51
	DD	imagerel $LN39+77
	DD	imagerel $chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN39+77
	DD	imagerel $LN39+101
	DD	imagerel $chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN267
	DD	imagerel $LN267+740
	DD	imagerel $unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN79
	DD	imagerel $LN79+93
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN79+93
	DD	imagerel $LN79+146
	DD	imagerel $chain$1$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN79+146
	DD	imagerel $LN79+322
	DD	imagerel $chain$2$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD imagerel $LN49
	DD	imagerel $LN49+197
	DD	imagerel $unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN42
	DD	imagerel $LN42+262
	DD	imagerel $unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN35
	DD	imagerel $LN35+211
	DD	imagerel $unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN23
	DD	imagerel $LN23+79
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN23+79
	DD	imagerel $LN23+223
	DD	imagerel $chain$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN23+223
	DD	imagerel $LN23+245
	DD	imagerel $chain$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD imagerel $LN11
	DD	imagerel $LN11+80
	DD	imagerel $unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD imagerel $LN17
	DD	imagerel $LN17+68
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN27
	DD	imagerel $LN27+187
	DD	imagerel $unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN37
	DD	imagerel $LN37+114
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN62
	DD	imagerel $LN62+51
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN62+51
	DD	imagerel $LN62+120
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN62+120
	DD	imagerel $LN62+155
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN59
	DD	imagerel $LN59+48
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN59+48
	DD	imagerel $LN59+111
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN59+111
	DD	imagerel $LN59+141
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN61
	DD	imagerel $LN61+21
	DD	imagerel $unwind$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN61+21
	DD	imagerel $LN61+90
	DD	imagerel $chain$0$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN61+90
	DD	imagerel $LN61+167
	DD	imagerel $chain$1$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN73
	DD	imagerel $LN73+117
	DD	imagerel $unwind$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN99
	DD	imagerel $LN99+35
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN99+35
	DD	imagerel $LN99+86
	DD	imagerel $chain$0$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN99+86
	DD	imagerel $LN99+109
	DD	imagerel $chain$1$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+109
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MappedFile@$0A@@@QEAA@PEBD@Z DD imagerel $LN17
	DD	imagerel $LN17+407
	DD	imagerel $unwind$??0?$MappedFile@$0A@@@QEAA@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$MappedFile@$0A@@@QEAA@XZ DD imagerel $LN10
	DD	imagerel $LN10+66
	DD	imagerel $unwind$??1?$MappedFile@$0A@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN93
	DD	imagerel $LN93+264
	DD	imagerel $unwind$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+89
	DD	imagerel $unwind$?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z DD imagerel $LN72
	DD	imagerel $LN72+33
	DD	imagerel $unwind$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z DD imagerel $LN72+33
	DD	imagerel $LN72+202
	DD	imagerel $chain$1$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z DD imagerel $LN72+202
	DD	imagerel $LN72+289
	DD	imagerel $chain$2$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN139
	DD	imagerel $LN139+470
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+59
	DD	imagerel $unwind$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z DD imagerel $LN93
	DD	imagerel $LN93+264
	DD	imagerel $unwind$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA DD imagerel ?dtor$0@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA
	DD	imagerel ?dtor$0@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA DD imagerel ?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA
	DD	imagerel ?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA+89
	DD	imagerel $unwind$?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD imagerel $LN133
	DD	imagerel $LN133+61
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD imagerel $LN133+61
	DD	imagerel $LN133+328
	DD	imagerel $chain$2$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD imagerel $LN133+328
	DD	imagerel $LN133+334
	DD	imagerel $chain$3$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD imagerel $LN133+334
	DD	imagerel $LN133+340
	DD	imagerel $chain$4$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN46
	DD	imagerel $LN46+129
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD imagerel $LN146
	DD	imagerel $LN146+490
	DD	imagerel $unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN619
	DD	imagerel $LN619+1766
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z DD imagerel $LN88
	DD	imagerel $LN88+685
	DD	imagerel $unwind$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$2@?0??benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z@4HA DD imagerel ?catch$2@?0??benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z@4HA
	DD	imagerel ?catch$2@?0??benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z@4HA+92
	DD	imagerel $unwind$?catch$2@?0??benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN32
	DD	imagerel $LN32+190
	DD	imagerel $unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD imagerel $LN246
	DD	imagerel $LN246+1611
	DD	imagerel $unwind$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$13@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA DD imagerel ?catch$13@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA
	DD	imagerel ?catch$13@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA+119
	DD	imagerel $unwind$?catch$13@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD imagerel $LN32
	DD	imagerel $LN32+218
	DD	imagerel $unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+119
	DD	imagerel $unwind$??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+119
	DD	imagerel $unwind$??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+119
	DD	imagerel $unwind$??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN45
	DD	imagerel $LN45+484
	DD	imagerel $unwind$?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN20
	DD	imagerel $LN20+23
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN99
	DD	imagerel $LN99+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN99+78
	DD	imagerel $LN99+257
	DD	imagerel $chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN99+257
	DD	imagerel $LN99+263
	DD	imagerel $chain$1$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN99+263
	DD	imagerel $LN99+269
	DD	imagerel $chain$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN23
	DD	imagerel $LN23+57
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1String@Json@@UEAA@XZ DD imagerel $LN43
	DD	imagerel $LN43+116
	DD	imagerel $unwind$??1String@Json@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GString@Json@@UEAAPEAXI@Z DD imagerel $LN51
	DD	imagerel $LN51+149
	DD	imagerel $unwind$??_GString@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN133
	DD	imagerel $LN133+89
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN133+89
	DD	imagerel $LN133+174
	DD	imagerel $chain$0$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN133+174
	DD	imagerel $LN133+196
	DD	imagerel $chain$1$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GObject@Json@@UEAAPEAXI@Z DD imagerel $LN19
	DD	imagerel $LN19+56
	DD	imagerel $unwind$??_GObject@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Object@Json@@QEAA@XZ DD imagerel $LN80
	DD	imagerel $LN80+146
	DD	imagerel $unwind$??0Object@Json@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GNumber@Json@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$??_GNumber@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GNull@Json@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$??_GNull@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GBool@Json@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$??_GBool@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GValue@Json@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$??_GValue@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GArray@Json@@UEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+56
	DD	imagerel $unwind$??_GArray@Json@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+98
	DD	imagerel $unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1locale@std@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+50
	DD	imagerel $unwind$??1locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_System_error_category@std@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$??_G_System_error_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD imagerel $LN20
	DD	imagerel $LN20+115
	DD	imagerel $unwind$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN53
	DD	imagerel $LN53+153
	DD	imagerel $unwind$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Generic_error_category@std@@UEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+33
	DD	imagerel $unwind$??_G_Generic_error_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN27
	DD	imagerel $LN27+79
	DD	imagerel $unwind$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error_message@std@@QEAA@K@Z DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$??0_System_error_message@std@@QEAA@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@QEAA@AEBV01@@Z DD imagerel $LN14
	DD	imagerel $LN14+82
	DD	imagerel $unwind$??0_System_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@AEBV01@@Z DD imagerel $LN19
	DD	imagerel $LN19+92
	DD	imagerel $unwind$??0system_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gsystem_error@std@@UEAAPEAXI@Z DD imagerel $LN27
	DD	imagerel $LN27+67
	DD	imagerel $unwind$??_Gsystem_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@HAEBVerror_category@1@@Z DD imagerel $LN70
	DD	imagerel $LN70+260
	DD	imagerel $unwind$??0system_error@std@@QEAA@HAEBVerror_category@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_System_error@std@@UEAAPEAXI@Z DD imagerel $LN22
	DD	imagerel $LN22+67
	DD	imagerel $unwind$??_G_System_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@IEAA@Verror_code@1@@Z DD imagerel $LN63
	DD	imagerel $LN63+256
	DD	imagerel $unwind$??0_System_error@std@@IEAA@Verror_code@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD imagerel $LN16
	DD	imagerel $LN16+63
	DD	imagerel $unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN7
	DD	imagerel $LN7+31
	DD	imagerel $unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN7
	DD	imagerel $LN7+23
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stod@std@@YANAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_K@Z DD imagerel $LN22
	DD	imagerel $LN22+131
	DD	imagerel $unwind$?stod@std@@YANAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stoul@std@@YAKAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z DD imagerel $LN22
	DD	imagerel $LN22+137
	DD	imagerel $unwind$?stoul@std@@YAKAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@AEBV01@@Z DD imagerel $LN9
	DD	imagerel $LN9+63
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_cast@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_cast@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_cast@std@@UEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+67
	DD	imagerel $unwind$??_Gbad_cast@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN19
	DD	imagerel $LN19+112
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN7
	DD	imagerel $LN7+62
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN9
	DD	imagerel $LN9+63
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN14
	DD	imagerel $LN14+63
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN22
	DD	imagerel $LN22+67
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+67
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??nullLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; ??nullLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
_DATA	SEGMENT
?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 074H ; Json::Parser::trueLiteral
	DB	072H
	DB	075H
	DB	065H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DQ	0000000000000004H
	DQ	000000000000000fH
_DATA	ENDS
;	COMDAT ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
_DATA	SEGMENT
?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 06eH ; Json::Parser::nullLiteral
	DB	075H
	DB	06cH
	DB	06cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DQ	0000000000000004H
	DQ	000000000000000fH
_DATA	ENDS
;	COMDAT ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
_DATA	SEGMENT
?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 066H ; Json::Parser::falseLiteral
	DB	061H
	DB	06cH
	DB	073H
	DB	065H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DQ	0000000000000005H
	DQ	000000000000000fH
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 021519H
	DD	030027206H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_cast@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_cast@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stoul@std@@YAKAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z DD 041919H
	DD	09340aH
	DD	07006520aH
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stod@std@@YANAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_K@Z DD 041919H
	DD	09340aH
	DD	07006520aH
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@IEAA@Verror_code@1@@Z DD 041919H
	DD	012340aH
	DD	07006d20aH
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_System_error@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@HAEBVerror_category@1@@Z DD 021819H
	DD	03002f209H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gsystem_error@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@QEAA@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error_message@std@@QEAA@K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Generic_error_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DB 04H
	DB	0dcH
	DB	02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DB 02H
	DB	0aH
	DD	imagerel ??1_System_error_message@std@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	imagerel $ip2state$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 041919H
	DD	0a340aH
	DD	07006720aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DB 02H
	DB	'f'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DB 060H
	DD	imagerel $ip2state$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_System_error_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1locale@std@@QEAA@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GArray@Json@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GValue@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GBool@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GNull@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GNumber@Json@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Object@Json@@QEAA@XZ DB 04H
	DB	'v'
	DB	00H
	DB	'|'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Object@Json@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$2@?0???0Object@Json@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0Object@Json@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Object@Json@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0Object@Json@@QEAA@XZ
	DD	imagerel $ip2state$??0Object@Json@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Object@Json@@QEAA@XZ DD 060f11H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0Object@Json@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GObject@Json@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN133
	DD	imagerel $LN133+89
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020521H
	DD	097405H
	DD	imagerel $LN133
	DD	imagerel $LN133+89
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 040a01H
	DD	0a340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GString@Json@@UEAAPEAXI@Z DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1String@Json@@UEAA@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 020021H
	DD	063400H
	DD	imagerel $LN99
	DD	imagerel $LN99+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN99
	DD	imagerel $LN99+78
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 050a01H
	DD	0e006620aH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0edH, 03H
	DB	02H
	DB	'f'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$MappedFile@$0A@@@QEAA@XZ
	DB	0e0H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 072519H
	DD	0197417H
	DD	0183417H
	DD	0140117H
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	09aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$13@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA DD 030b01H
	DD	05007620bH
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 014H
	DB	08eH
	DB	00H
	DB	0e9H, 02H
	DB	02H
	DB	090H
	DB	00H
	DB	0e6H
	DB	02H
	DB	0e4H
	DB	04H
	DB	'=', 02H
	DB	06H
	DB	0a6H
	DB	04H
	DB	'Q', 07H
	DB	02H
	DB	05H, 04H
	DB	0aH
	DB	'v'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 02H
	DB	017H
	DB	012H
	DD	imagerel ??_R0?AVexception@std@@@8
	DB	0c0H
	DD	imagerel ?catch$13@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA
	DB	0d5H, 0cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 0aH
	DB	0aH
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	081H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
	DB	030H
	DB	038H
	DB	086H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DB 038H
	DD	imagerel $stateUnwindMap$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	DD	imagerel $tryMap$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	DD	imagerel $ip2state$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 0d3319H
	DD	01c9821H
	DD	01d881cH
	DD	01e6817H
	DD	0443412H
	DD	03e0112H
	DD	07009f00bH
	DD	06008H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	DD	01b3H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 02H
	DB	'9', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 068H
	DD	imagerel $stateUnwindMap$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	imagerel $ip2state$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$2@?0??benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z@4HA DD 030b01H
	DD	05007420bH
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z DB 06H
	DB	'z'
	DB	00H
	DB	0ceH
	DB	02H
	DB	082H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z DB 02H
	DB	017H
	DB	012H
	DD	imagerel ??_R0?AVexception@std@@@8
	DB	'`'
	DD	imagerel ?catch$2@?0??benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z@4HA
	DB	0a5H, 03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z DB 038H
	DD	imagerel $stateUnwindMap$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z
	DD	imagerel $tryMap$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z
	DD	imagerel $ip2state$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z DD 082619H
	DD	067817H
	DD	076811H
	DD	07004f20bH
	DD	030026003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z
	DD	053H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DB '*'
	DB	'.'
	DB	00H
	DB	'|'
	DB	02H
	DB	01eH
	DB	00H
	DB	0f4H
	DB	02H
	DB	01eH
	DB	00H
	DB	0f4H
	DB	04H
	DB	'R'
	DB	06H
	DB	'('
	DB	04H
	DB	'Y', 03H
	DB	00H
	DB	'R'
	DB	04H
	DB	'('
	DB	06H
	DB	'q', 03H
	DB	00H
	DB	'R'
	DB	04H
	DB	'('
	DB	06H
	DB	'q', 03H
	DB	00H
	DB	'R'
	DB	04H
	DB	'('
	DB	06H
	DB	'q', 03H
	DB	00H
	DB	'R'
	DB	04H
	DB	'('
	DB	06H
	DB	01dH, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DB 06H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$main DB 028H
	DD	imagerel $stateUnwindMap$main
	DD	imagerel $ip2state$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	020911H
	DD	05002d209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD 08bf19H
	DD	01264bfH
	DD	01154afH
	DD	0e005b209H
	DD	030027003H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 060021H
	DD	087400H
	DD	0115400H
	DD	0f3400H
	DD	imagerel $LN133
	DD	imagerel $LN133+61
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 021H
	DD	imagerel $LN133
	DD	imagerel $LN133+61
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 061221H
	DD	087412H
	DD	011540dH
	DD	0f3405H
	DD	imagerel $LN133
	DD	imagerel $LN133+61
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 050c01H
	DD	0f008820cH
	DD	0c004e006H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA DB 06H
	DB	'*'
	DB	02H
	DB	'.'
	DB	04H
	DB	' '
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA DB 06H
	DB	08H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA DB 029H
	DD	imagerel $stateUnwindMap$?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA
	DD	imagerel $ip2state$?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z DB 08H
	DB	0d2H
	DB	04H
	DB	'V'
	DB	06H
	DB	'F'
	DB	04H
	DB	'l'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z DB 02H
	DB	07H
	DB	012H
	DD	imagerel ??_R0?AVexception@std@@@8
	DB	'p'
	DD	imagerel ?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z DB 02H
	DB	02H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA
	DB	028H
	DB	0aH
	DD	imagerel ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
	DB	050H
	DB	06aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z
	DD	imagerel $tryMap$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z
	DD	imagerel $ip2state$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z DD 072419H
	DD	01b6412H
	DD	01a3412H
	DD	0160112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z
	DD	0a3H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0cH
	DB	0d6H
	DB	00H
	DB	'h'
	DB	02H
	DB	0baH
	DB	06H
	DB	0e6H
	DB	04H
	DB	'L'
	DB	00H
	DB	'P'
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	0c5H, 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0aH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z DD 020021H
	DD	0d3400H
	DD	imagerel $LN72
	DD	imagerel $LN72+33
	DD	imagerel $unwind$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z DD 046b21H
	DD	0d346bH
	DD	0c6405H
	DD	imagerel $LN72
	DD	imagerel $LN72+33
	DD	imagerel $unwind$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z DD 061701H
	DD	047817H
	DD	05680cH
	DD	07002d206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DB 06H
	DB	'*'
	DB	02H
	DB	'.'
	DB	04H
	DB	' '
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DB 06H
	DB	08H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DB 029H
	DD	imagerel $stateUnwindMap$?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel $ip2state$?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DB	0d2H
	DB	04H
	DB	'V'
	DB	06H
	DB	'F'
	DB	04H
	DB	'l'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	07H
	DB	012H
	DD	imagerel ??_R0?AVexception@std@@@8
	DB	'p'
	DD	imagerel ?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	02H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	028H
	DB	0aH
	DD	imagerel ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
	DB	050H
	DB	06aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $tryMap$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 072419H
	DD	01b6412H
	DD	01a3412H
	DD	0160112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0a3H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$MappedFile@$0A@@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MappedFile@$0A@@@QEAA@PEBD@Z DD 041c19H
	DD	014340dH
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+35
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DD 020521H
	DD	073405H
	DD	imagerel $LN99
	DD	imagerel $LN99+35
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DB 04H
	DB	'F'
	DB	00H
	DB	'|'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel ?dtor$1@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ DD 040a11H
	DD	09340aH
	DD	07006520aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+21
	DD	imagerel $unwind$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 020521H
	DD	097405H
	DD	imagerel $LN61
	DD	imagerel $LN61+21
	DD	imagerel $unwind$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 040a01H
	DD	0a340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+48
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 020521H
	DD	087405H
	DD	imagerel $LN59
	DD	imagerel $LN59+48
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 040a01H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 021H
	DD	imagerel $LN62
	DD	imagerel $LN62+51
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN62
	DD	imagerel $LN62+51
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 060f01H
	DD	0a540fH
	DD	09340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 02H
	DB	'Q', 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	imagerel $ip2state$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+79
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 020521H
	DD	087405H
	DD	imagerel $LN23
	DD	imagerel $LN23+79
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 031619H
	DD	060038207H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 041719H
	DD	070045208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 061a19H
	DD	0e007520bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD 0a3c01H
	DD	0bf43cH
	DD	09e437H
	DD	08642fH
	DD	070043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+93
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 020521H
	DD	047405H
	DD	imagerel $LN79
	DD	imagerel $LN79+93
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 064101H
	DD	053441H
	DD	0e0055209H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 04H
	DB	0c5H, 04H
	DB	02H
	DB	'5', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DB 028H
	DD	imagerel $stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	imagerel $ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 082819H
	DD	015741aH
	DD	014641aH
	DD	013341aH
	DD	05010f21aH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020021H
	DD	067400H
	DD	imagerel $LN39
	DD	imagerel $LN39+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020521H
	DD	067405H
	DD	imagerel $LN39
	DD	imagerel $LN39+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 021H
	DD	imagerel $LN89
	DD	imagerel $LN89+111
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 020821H
	DD	0146408H
	DD	imagerel $LN89
	DD	imagerel $LN89+111
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 041c19H
	DD	015340dH
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 02H
	DB	0aaH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DB 02H
	DB	0b2H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DB 068H
	DD	imagerel $stateUnwindMap$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DD	imagerel $ip2state$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD 060b01H
	DD	0e007520bH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 0cH
	DB	'b'
	DB	00H
	DB	0a0H
	DB	02H
	DB	08aH
	DB	00H
	DB	'-', 0aH
	DB	04H
	DB	'*'
	DB	06H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
	DD	imagerel $ip2state$??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD 050b11H
	DD	014010bH
	DD	060037004H
	DD	03002H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 0eH
	DB	0aeH
	DB	00H
	DB	'h'
	DB	02H
	DB	0baH
	DB	06H
	DB	0a0H
	DB	04H
	DB	'2'
	DB	06H
	DB	'h'
	DB	04H
	DB	'^'
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DB	0a1H, 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 0aH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@@std@@YA_NAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z DB 06H
	DB	0a6H
	DB	02H
	DB	0d4H
	DB	00H
	DB	091H, 02H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z
	DD	imagerel $ip2state$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z DD 0a1411H
	DD	0133414H
	DD	0f0107214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 0cH
	DB	'j'
	DB	00H
	DB	09aH
	DB	02H
	DB	08aH
	DB	00H
	DB	0bdH, 0aH
	DB	04H
	DB	'*'
	DB	06H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
	DD	imagerel $ip2state$??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD 050b11H
	DD	014010bH
	DD	060037004H
	DD	03002H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 08H
	DB	099H, 02H
	DB	02H
	DB	082H
	DB	04H
	DB	':'
	DB	00H
	DB	'`'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 04H
	DB	0aH
	DD	imagerel __imp_??1_Lockit@std@@QEAA@XZ
	DB	050H
	DB	032H
	DD	imagerel ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	imagerel $ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 082319H
	DD	0d6414H
	DD	0c5414H
	DD	0b3414H
	DD	070107214H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?unmap@?$MappedFile@$0A@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?map@?$MappedFile@$0A@@@QEAAXPEBD@Z DD 021819H
	DD	03002f209H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN95
	DD	imagerel $LN95+35
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ DD 020521H
	DD	073405H
	DD	imagerel $LN95
	DD	imagerel $LN95+35
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z DB 04H
	DB	'J'
	DB	00H
	DB	'|'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z DD 040a11H
	DD	09340aH
	DD	07006520aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD 020521H
	DD	097405H
	DD	imagerel $LN57
	DD	imagerel $LN57+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ DD 040a01H
	DD	0a340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'h'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 04H
	DB	'X'
	DB	00H
	DB	'\'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBADXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN52
	DD	imagerel $LN52+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z DD 0a1601H
	DD	0e5416H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 0eH
	DB	'z'
	DB	00H
	DB	'>'
	DB	02H
	DB	'Z'
	DB	04H
	DB	08aH
	DB	06H
	DB	'e', 02H
	DB	08H
	DB	0ccH
	DB	06H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DB	02aH
	DD	imagerel ??1locale@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
	DD	imagerel $ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD 061b19H
	DD	012340cH
	DD	07008b20cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 020021H
	DD	0f7400H
	DD	imagerel $LN28
	DD	imagerel $LN28+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 020521H
	DD	0f7405H
	DD	imagerel $LN28
	DD	imagerel $LN28+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 021519H
	DD	03002b206H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD 061e19H
	DD	0d640fH
	DD	0c340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+31
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 020521H
	DD	073405H
	DD	imagerel $LN34
	DD	imagerel $LN34+31
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 020021H
	DD	063400H
	DD	imagerel $LN99
	DD	imagerel $LN99+78
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+78
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN99
	DD	imagerel $LN99+78
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 050a01H
	DD	0e006620aH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z DD 081501H
	DD	0c7415H
	DD	0b6415H
	DD	0a3415H
	DD	0e0117215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 01eH
	DB	'|'
	DB	00H
	DB	'8'
	DB	02H
	DB	08cH
	DB	04H
	DB	0d1H, 02H
	DB	0aH
	DB	'*'
	DB	04H
	DB	'|'
	DB	02H
	DB	0feH
	DB	00H
	DB	'B'
	DB	04H
	DB	0e0H
	DB	02H
	DB	01aH
	DB	0cH
	DB	':'
	DB	0eH
	DB	'B'
	DB	02H
	DB	'B'
	DB	04H
	DB	0f4H
	DB	06H
	DB	'"'
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 0eH
	DB	0aH
	DD	imagerel ??1?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	0a2H
	DD	imagerel ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
	DB	0a0H
	DB	05H
	DB	02H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
	DD	imagerel $ip2state$??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD 092519H
	DD	01a0117H
	DD	0e009f00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 0cH
	DB	'J'
	DB	00H
	DB	094H
	DB	02H
	DB	'V'
	DB	04H
	DB	'H'
	DB	02H
	DB	0a4H
	DB	00H
	DB	't'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
	DD	imagerel $ip2state$??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD 081011H
	DD	0133410H
	DD	0f00c9210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 06H
	DB	'!', 02H
	DB	02H
	DB	'5', 02H
	DB	00H
	DB	'\'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
	DD	imagerel $ip2state$??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD 040811H
	DD	070049208H
	DD	030026003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VString@Json@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseBoolTrue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseBoolFalse@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseNull@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 08H
	DB	')', 03H
	DB	02H
	DB	'E', 02H
	DB	00H
	DB	0ceH
	DB	02H
	DB	0e6H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
	DD	imagerel $ip2state$??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z DD 0a2a19H
	DD	07681cH
	DD	0173416H
	DD	0f00cf216H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 01cH
	DB	'|'
	DB	00H
	DB	'X'
	DB	02H
	DB	'j'
	DB	04H
	DB	0bdH, 02H
	DB	0aH
	DB	'*'
	DB	04H
	DB	082H
	DB	02H
	DB	05H, 03H
	DB	00H
	DB	'f'
	DB	04H
	DB	'"'
	DB	06H
	DB	':'
	DB	08H
	DB	'B'
	DB	02H
	DB	' '
	DB	0cH
	DB	01aH
	DB	0eH
	DB	':'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 0eH
	DB	0aH
	DD	imagerel ??1?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	0a2H
	DD	imagerel ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
	DB	0a0H
	DB	05H
	DB	02H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
	DD	imagerel $ip2state$??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD 092519H
	DD	01a0117H
	DD	0e009f00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
	DD	0c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 0cH
	DB	'J'
	DB	00H
	DB	094H
	DB	02H
	DB	'j'
	DB	04H
	DB	'H'
	DB	02H
	DB	0c8H
	DB	00H
	DB	'z'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
	DD	imagerel $ip2state$??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD 081011H
	DD	0133410H
	DD	0f00c9210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z DB 06H
	DB	'y', 02H
	DB	02H
	DB	'}', 02H
	DB	00H
	DB	'\'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z
	DD	imagerel $ip2state$??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z DD 040811H
	DD	070049208H
	DD	030026003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseBoolTrue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseBoolFalse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseNull@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 08H
	DB	'M', 03H
	DB	02H
	DB	'Q', 02H
	DB	00H
	DB	0ceH
	DB	02H
	DB	0e6H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
	DD	imagerel $ip2state$??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z DD 0a2a19H
	DD	07681cH
	DD	0173416H
	DD	0f00cf216H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+25
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN57
	DD	imagerel $LN57+25
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 060021H
	DD	06f400H
	DD	0ec400H
	DD	0d7400H
	DD	imagerel $LN132
	DD	imagerel $LN132+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 021H
	DD	imagerel $LN132
	DD	imagerel $LN132+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 061621H
	DD	06f416H
	DD	0ec40aH
	DD	0d7405H
	DD	imagerel $LN132
	DD	imagerel $LN132+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z DD 050a01H
	DD	0e006620aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 060021H
	DD	06f400H
	DD	077400H
	DD	0105400H
	DD	imagerel $LN166
	DD	imagerel $LN166+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 021H
	DD	imagerel $LN166
	DD	imagerel $LN166+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 061d21H
	DD	06f41dH
	DD	077414H
	DD	0105408H
	DD	imagerel $LN166
	DD	imagerel $LN166+56
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 060d01H
	DD	0e009720dH
	DD	0c005d007H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD 020021H
	DD	0c6400H
	DD	imagerel $LN94
	DD	imagerel $LN94+58
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN94
	DD	imagerel $LN94+58
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD 020021H
	DD	0c6400H
	DD	imagerel $LN94
	DD	imagerel $LN94+58
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN94
	DD	imagerel $LN94+58
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN94
	DD	imagerel $LN94+58
	DD	imagerel $unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z DD 060d01H
	DD	0d340dH
	DD	0e009520dH
	DD	050067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEBADXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NAEBV12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 06H
	DB	080H
	DB	00H
	DB	'm', 02H
	DB	02H
	DB	0beH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 02H
	DB	0aH
	DD	imagerel ??1locale@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DB 028H
	DD	imagerel $stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	imagerel $ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 061e19H
	DD	0f640fH
	DD	0e340fH
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD 021H
	DD	imagerel $LN150
	DD	imagerel $LN150+47
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD 061621H
	DD	0ec416H
	DD	0d740eH
	DD	0c6405H
	DD	imagerel $LN150
	DD	imagerel $LN150+47
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z DD 060e01H
	DD	0f340eH
	DD	0f00a720eH
	DD	05006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD 021H
	DD	imagerel $LN110
	DD	imagerel $LN110+63
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD 020521H
	DD	0ce405H
	DD	imagerel $LN110
	DD	imagerel $LN110+63
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD 081201H
	DD	0e5412H
	DD	0d3412H
	DD	0f00e7212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z DB 08H
	DB	09H, 07H
	DB	00H
	DB	092H
	DB	02H
	DB	'$'
	DB	04H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
	DD	imagerel $ip2state$??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z DD 061211H
	DD	0136412H
	DD	0123412H
	DD	0700bf212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$skipCommentScalar@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ DB 06H
	DB	'F'
	DB	00H
	DB	08aH
	DB	02H
	DB	'|'
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ DB 028H
	DD	imagerel $stateUnwindMap$??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ
	DD	imagerel $ip2state$??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ DD 081411H
	DD	0d6414H
	DD	0c5414H
	DD	0b3414H
	DD	070107214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DB 06H
	DB	'%', 04H
	DB	00H
	DB	'0'
	DB	02H
	DB	081H, 04H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
	DB	03aH
	DD	imagerel ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
	DD	imagerel $ip2state$??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DD 091111H
	DD	0f00d8211H
	DD	0d009e00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VArray@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@0@XZ DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0eH
	DB	'Y', 02H
	DB	00H
	DB	0a5H, 06H
	DB	02H
	DB	'I', 06H
	DB	00H
	DB	']', 02H
	DB	04H
	DB	'$'
	DB	06H
	DB	'>'
	DB	00H
	DB	'F'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 072219H
	DD	01f3410H
	DD	0180110H
	DD	07007e009H
	DD	06006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VBool@Json@@_N$0A@@std@@YA?AV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@0@$$QEA_N@Z DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VNull@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@0@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@VNumber@Json@@N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@$$QEAN@Z DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD 080021H
	DD	06e400H
	DD	07d400H
	DD	08c400H
	DD	0117400H
	DD	imagerel $LN390
	DD	imagerel $LN390+71
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD 021H
	DD	imagerel $LN390
	DD	imagerel $LN390+71
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD 080021H
	DD	06e400H
	DD	07d400H
	DD	08c400H
	DD	0117400H
	DD	imagerel $LN390
	DD	imagerel $LN390+71
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD 082421H
	DD	06e424H
	DD	07d413H
	DD	08c40cH
	DD	0117404H
	DD	imagerel $LN390
	DD	imagerel $LN390+71
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z DD 050c01H
	DD	0f008820cH
	DD	050056006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DB 08H
	DB	0e5H, 08H
	DB	00H
	DB	092H
	DB	02H
	DB	'$'
	DB	04H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
	DD	imagerel $ip2state$??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD 061211H
	DD	0136412H
	DD	0123412H
	DD	0700bf212H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$skipCommentScalar@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z DB 0eH
	DB	081H, 02H
	DB	00H
	DB	0a5H, 06H
	DB	02H
	DB	'e', 06H
	DB	00H
	DB	']', 02H
	DB	04H
	DB	'$'
	DB	06H
	DB	'>'
	DB	00H
	DB	'L'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z
	DD	imagerel $ip2state$??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z DD 072219H
	DD	01f3410H
	DD	0180110H
	DD	07007e009H
	DD	06006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z
	DD	0b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN22
	DD	imagerel $LN22+62
	DD	imagerel $unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN6
	DD	imagerel $LN6+15
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN6
	DD	imagerel $LN6+15
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD 0a5d01H
	DD	09f45dH
	DD	086454H
	DD	0a340dH
	DD	0e009320dH
	DD	050067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DB 02H
	DB	'`'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
	DD	imagerel $ip2state$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z DD 081911H
	DD	096419H
	DD	085419H
	DD	073419H
	DD	070153219H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$07@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+44
	DD	imagerel $unwind$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD 061721H
	DD	0ae417H
	DD	09740eH
	DD	085405H
	DD	imagerel $LN66
	DD	imagerel $LN66+44
	DD	imagerel $unwind$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z DD 040901H
	DD	0f0053209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD 060021H
	DD	06e400H
	DD	077400H
	DD	0e5400H
	DD	imagerel $LN132
	DD	imagerel $LN132+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD 021H
	DD	imagerel $LN132
	DD	imagerel $LN132+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD 061a21H
	DD	06e41aH
	DD	077411H
	DD	0e5405H
	DD	imagerel $LN132
	DD	imagerel $LN132+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z DD 040901H
	DD	0f0057209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+16
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 040e21H
	DD	0a740eH
	DD	093405H
	DD	imagerel $LN57
	DD	imagerel $LN57+16
	DD	imagerel $unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ DQ 00000420400010401r ; 3.58617e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+39
	DD	imagerel $unwind$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD 020521H
	DD	0b7405H
	DD	imagerel $LN57
	DD	imagerel $LN57+39
	DD	imagerel $unwind$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z DD 081301H
	DD	0d5413H
	DD	0c3413H
	DD	0f00f5213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD 021H
	DD	imagerel $LN102
	DD	imagerel $LN102+37
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD 061621H
	DD	0ae416H
	DD	09640eH
	DD	083405H
	DD	imagerel $LN102
	DD	imagerel $LN102+37
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z DD 040a01H
	DD	0b540aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN350
	DD	imagerel $LN350+163
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 041421H
	DD	08f414H
	DD	09e405H
	DD	imagerel $LN350
	DD	imagerel $LN350+163
	DD	imagerel $unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z DD 0c6f01H
	DD	0ac46fH
	DD	0b7465H
	DD	0c645bH
	DD	0d544bH
	DD	0123442H
	DD	0d002d206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 021H
	DD	imagerel $LN97
	DD	imagerel $LN97+39
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 061621H
	DD	0ae416H
	DD	09540eH
	DD	083405H
	DD	imagerel $LN97
	DD	imagerel $LN97+39
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 040a01H
	DD	0b640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD 060021H
	DD	06f400H
	DD	0fe400H
	DD	0e7400H
	DD	imagerel $LN190
	DD	imagerel $LN190+50
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD 021H
	DD	imagerel $LN190
	DD	imagerel $LN190+50
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD 061621H
	DD	06f416H
	DD	0fe40aH
	DD	0e7405H
	DD	imagerel $LN190
	DD	imagerel $LN190+50
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z DD 050a01H
	DD	0c006620aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+39
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN88+77
	DD	imagerel $LN88+96
	DD	imagerel $chain$2$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020521H
	DD	093405H
	DD	imagerel $LN88+77
	DD	imagerel $LN88+96
	DD	imagerel $chain$2$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020021H
	DD	0a6400H
	DD	imagerel $LN88
	DD	imagerel $LN88+39
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020521H
	DD	0a6405H
	DD	imagerel $LN88
	DD	imagerel $LN88+39
	DD	imagerel $unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN82
	DD	imagerel $LN82+30
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN82+68
	DD	imagerel $LN82+87
	DD	imagerel $chain$2$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020521H
	DD	093405H
	DD	imagerel $LN82+68
	DD	imagerel $LN82+87
	DD	imagerel $chain$2$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020021H
	DD	0a7400H
	DD	imagerel $LN82
	DD	imagerel $LN82+30
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020521H
	DD	0a7405H
	DD	imagerel $LN82
	DD	imagerel $LN82+30
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+35
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	073405H
	DD	imagerel $LN61
	DD	imagerel $LN61+35
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a0021H
	DD	08d400H
	DD	09c400H
	DD	0117400H
	DD	0106400H
	DD	0f3400H
	DD	imagerel $LN239
	DD	imagerel $LN239+47
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 021H
	DD	imagerel $LN239
	DD	imagerel $LN239+47
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 0a1721H
	DD	08d417H
	DD	09c413H
	DD	011740fH
	DD	010640bH
	DD	0f3404H
	DD	imagerel $LN239
	DD	imagerel $LN239+47
	DD	imagerel $unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z DD 040c01H
	DD	0f008920cH
	DD	05004e006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 040a01H
	DD	07340aH
	DD	07006320aH
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??trueLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; ??trueLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??falseLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; ??falseLiteral$initializer$@Parser@Json@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, rdx

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z
_TEXT	SEGMENT
_Val$dead$ = 8
_First$ = 16
_Count$ = 24
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 2258 :     const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val

	xor	r9d, r9d
	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r8, r8
	je	SHORT $LN14@Fnv1a_appe
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	4
$LL10@Fnv1a_appe:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rdx+r9]
	inc	r9
	xor	rax, rcx

; 2261 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	r9, r8
	jb	SHORT $LL10@Fnv1a_appe
$LN14@Fnv1a_appe:

; 2262 :     }
; 2263 : 
; 2264 :     return _Val;
; 2265 : }

	ret	0
?_Fnv1a_append_bytes@std@@YA_K_KQEBE_K@Z ENDP		; std::_Fnv1a_append_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 68   :         _Data._What = _Message;
; 69   :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@

; 66   :         : _Data()

	mov	QWORD PTR [rcx+16], 0

; 133  :     {

	mov	QWORD PTR [rcx], rax

; 134  :     }

	mov	rax, rcx

; 68   :         _Data._What = _Message;

	mov	QWORD PTR [rcx+8], rdx

; 134  :     }

	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN13@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 68   :         _Data._What = _Message;

	lea	rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rax

; 144  :     {

	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rcx], rax

; 145  :     }

	mov	rax, rcx
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN18@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN18@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
	sub	rsp, 72					; 00000048H

; 108  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 73   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	vpxor	xmm0, xmm0, xmm0
	mov	QWORD PTR [rbx], rcx
	lea	rdx, QWORD PTR [rbx+8]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 73   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	vpxor	xmm0, xmm0, xmm0
	mov	QWORD PTR [rbx], rcx
	lea	rdx, QWORD PTR [rbx+8]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 8
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 136  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr$ = 64
_Bytes$ = 72
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 200  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN7:
	sub	rsp, 56					; 00000038H

; 201  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 202  :     _Bytes += _Non_user_size;

	add	QWORD PTR [rdx], 39			; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rdx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN3@Adjust_man

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	QWORD PTR [rcx], rdx

; 221  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN3@Adjust_man:

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN5@Adjust_man:
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1184 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1185 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1186 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1191 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1450 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	rax, rcx
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1453 :     _CONSTEXPR20 void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 530  : [[noreturn]] inline void _Xlen_string() {

$LN4:
	sub	rsp, 40					; 00000028H

; 531  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen_strin:
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\stdexcept
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\stdexcept
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\stdexcept
;	COMDAT ??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_InitData$4 = 32
__$ArrayPad$ = 48
this$ = 80
_Message$ = 88
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

$LN19:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\stdexcept

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

	mov	r8, rdx
	mov	rbx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN7@runtime_er

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN7@runtime_er:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 59   :         : _Data()

	lea	rdx, QWORD PTR [rcx+8]

; 60   :     {
; 61   :         __std_exception_data _InitData = { _Message, true };

	mov	QWORD PTR _InitData$4[rsp], r8
	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	BYTE PTR _InitData$4[rsp+8], 1
	mov	QWORD PTR [rcx], rax

; 62   :         __std_exception_copy(&_InitData, &_Data);

	lea	rcx, QWORD PTR _InitData$4[rsp]
	vpxor	xmm0, xmm0, xmm0

; 59   :         : _Data()

	vmovups	XMMWORD PTR [rdx], xmm0

; 62   :         __std_exception_copy(&_InitData, &_Data);

	call	QWORD PTR __imp___std_exception_copy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\stdexcept

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

	lea	rax, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_typeinfo.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_cast@std@@QEAA@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 68   :         _Data._What = _Message;

	lea	rax, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast@
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_typeinfo.h

; 153  :     {

	lea	rax, OFFSET FLAT:??_7bad_cast@std@@6B@
	mov	QWORD PTR [rcx], rax

; 154  :     }

	mov	rax, rcx
	ret	0
??0bad_cast@std@@QEAA@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_cast@std@@UEAAPEAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN13@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_cast@std@@UEAAPEAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_cast@std@@UEAA@XZ PROC				; std::bad_cast::~bad_cast, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1bad_cast@std@@UEAA@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 62   : [[noreturn]] inline void _Throw_bad_cast() {

$LN4:
	sub	rsp, 72					; 00000048H

; 63   :     _THROW(bad_cast{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_cast@std@@QEAA@XZ		; std::bad_cast::bad_cast
	lea	rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_bad_:
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_cast@std@@QEAA@AEBV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 73   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	vpxor	xmm0, xmm0, xmm0
	mov	QWORD PTR [rbx], rcx
	lea	rdx, QWORD PTR [rbx+8]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_cast@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_cast@std@@QEAA@AEBV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
;	COMDAT ?stoul@std@@YAKAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z
_TEXT	SEGMENT
_Eptr$ = 32
__$ArrayPad$ = 40
_Str$ = 64
_Idx$dead$ = 72
_Base$dead$ = 80
?stoul@std@@YAKAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z PROC ; std::stoul, COMDAT

; 132  : _EXPORT_STD _NODISCARD inline unsigned long stoul(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {

$LN22:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx

; 133  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 133  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	mov	rdi, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN10@stoul

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN10@stoul:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 137  :     const unsigned long _Ans = _CSTD strtoul(_Ptr, &_Eptr, _Base);

	mov	r8d, 16
	mov	DWORD PTR [rax], 0
	lea	rdx, QWORD PTR _Eptr$[rsp]
	mov	rcx, rbx
	call	QWORD PTR __imp_strtoul

; 138  : 
; 139  :     if (_Ptr == _Eptr) {

	cmp	rbx, QWORD PTR _Eptr$[rsp]
	jne	SHORT $LN2@stoul

; 140  :         _Xinvalid_argument("invalid stoul argument");

	lea	rcx, OFFSET FLAT:??_C@_0BH@DPNNDOEK@invalid?5stoul?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN2@stoul:

; 141  :     }
; 142  : 
; 143  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [rdi], 34			; 00000022H
	jne	SHORT $LN3@stoul

; 144  :         _Xout_of_range("stoul argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BM@MOLGGFGJ@stoul?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN3@stoul:

; 145  :     }
; 146  : 
; 147  :     if (_Idx) {
; 148  :         *_Idx = static_cast<size_t>(_Eptr - _Ptr);
; 149  :     }
; 150  : 
; 151  :     return _Ans;
; 152  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN19@stoul:
?stoul@std@@YAKAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_KH@Z ENDP ; std::stoul
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
;	COMDAT ?stod@std@@YANAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_K@Z
_TEXT	SEGMENT
_Eptr$ = 32
__$ArrayPad$ = 40
_Str$ = 64
_Idx$dead$ = 72
?stod@std@@YANAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_K@Z PROC ; std::stod, COMDAT

; 220  : _EXPORT_STD _NODISCARD inline double stod(const string& _Str, size_t* _Idx = nullptr) {

$LN22:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx

; 221  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 221  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	mov	rdi, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN10@stod

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN10@stod:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 225  :     const double _Ans = _CSTD strtod(_Ptr, &_Eptr);

	lea	rdx, QWORD PTR _Eptr$[rsp]
	mov	DWORD PTR [rax], 0
	mov	rcx, rbx
	call	QWORD PTR __imp_strtod

; 226  : 
; 227  :     if (_Ptr == _Eptr) {

	cmp	rbx, QWORD PTR _Eptr$[rsp]
	jne	SHORT $LN2@stod

; 228  :         _Xinvalid_argument("invalid stod argument");

	lea	rcx, OFFSET FLAT:??_C@_0BG@LNNHAOEF@invalid?5stod?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN2@stod:

; 229  :     }
; 230  : 
; 231  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [rdi], 34			; 00000022H
	jne	SHORT $LN3@stod

; 232  :         _Xout_of_range("stod argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BL@PPHDABKE@stod?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN3@stod:

; 233  :     }
; 234  : 
; 235  :     if (_Idx) {
; 236  :         *_Idx = static_cast<size_t>(_Eptr - _Ptr);
; 237  :     }
; 238  : 
; 239  :     return _Ans;
; 240  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN19@stod:
?stod@std@@YANAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PEA_K@Z ENDP ; std::stod
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_Val$ = 72
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::to_string, COMDAT

; 463  : _EXPORT_STD _NODISCARD inline string to_string(int _Val) {

$LN7:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 464  :     return _Integral_to_string<char>(_Val);

	call	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
	mov	rax, rbx

; 465  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rdx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 102  : }

	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??8error_category@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8error_category@std@@QEBA_NAEBV01@@Z PROC		; std::error_category::operator==, COMDAT

; 100  : #ifdef _M_CEE_PURE
; 101  :         return _Addr == _Right._Addr;
; 102  : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 103  :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

	mov	rax, QWORD PTR [rdx+8]
	cmp	QWORD PTR [rcx+8], rax
	sete	al

; 104  : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 105  :     }

	ret	0
??8error_category@std@@QEBA_NAEBV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??1error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1error_category@std@@UEAA@XZ PROC			; std::error_category::~error_category, COMDAT

; 87   :     _CONSTEXPR20 virtual ~error_category() noexcept = default;

	ret	0
??1error_category@std@@UEAA@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0error_code@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT

; 171  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?value@error_code@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_code@std@@QEBAHXZ PROC			; std::error_code::value, COMDAT

; 197  :         return _Myval;

	mov	eax, DWORD PTR [rcx]

; 198  :     }

	ret	0
?value@error_code@std@@QEBAHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?category@error_code@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_code@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_code::category, COMDAT

; 201  :         return *_Mycat;

	mov	rax, QWORD PTR [rcx+8]

; 202  :     }

	ret	0
?category@error_code@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT

; 206  :     _NODISCARD string message() const {

$LN7:
	push	rbx
	sub	rsp, 48					; 00000030H

; 207  :         return category().message(value());

	mov	r8d, DWORD PTR [rcx]
	mov	rbx, rdx
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	mov	rax, rbx

; 208  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?value@error_condition@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_condition@std@@QEBAHXZ PROC		; std::error_condition::value, COMDAT

; 288  :         return _Myval;

	mov	eax, DWORD PTR [rcx]

; 289  :     }

	ret	0
?value@error_condition@std@@QEBAHXZ ENDP		; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?category@error_condition@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT

; 292  :         return *_Mycat;

	mov	rax, QWORD PTR [rcx+8]

; 293  :     }

	ret	0
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??8std@@YA_NAEBVerror_condition@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??8std@@YA_NAEBVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 305  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	mov	rax, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rcx+8]
	mov	r8, QWORD PTR [rax+8]
	cmp	QWORD PTR [r9+8], r8
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	jne	SHORT $LN3@operator
	mov	al, 1

; 306  :     }

	ret	0
$LN3@operator:

; 305  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	xor	al, al

; 306  :     }

	ret	0
??8std@@YA_NAEBVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Errval$ = 24
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rdx], r8d

; 408  :     // make error_condition for error code
; 409  :     return error_condition(_Errval, *this);

	mov	rax, rdx

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	QWORD PTR [rdx+8], rcx

; 410  : }

	ret	0
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Errval$ = 72
_Cond$ = 80
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT

; 412  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

$LN16:
	push	rbx
	sub	rsp, 48					; 00000030H

; 413  :     return default_error_condition(_Errval) == _Cond;

	mov	rax, QWORD PTR [rcx]
	mov	rbx, r8
	mov	r8d, edx
	lea	rdx, QWORD PTR $T1[rsp]
	call	QWORD PTR [rax+24]

; 305  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	mov	rcx, QWORD PTR [rbx+8]
	mov	r9, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [r9+8], rdx
	jne	SHORT $LN6@equivalent
	mov	ecx, DWORD PTR [rbx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN6@equivalent

; 413  :     return default_error_condition(_Errval) == _Cond;

	mov	al, 1

; 414  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN6@equivalent:

; 413  :     return default_error_condition(_Errval) == _Cond;

	xor	al, al

; 414  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
_TEXT	SEGMENT
this$ = 8
_Code$ = 16
_Errval$ = 24
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT

; 417  :     return *this == _Code.category() && _Code.value() == _Errval;

	mov	rax, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rax+8]
	cmp	QWORD PTR [rcx+8], r9
	jne	SHORT $LN3@equivalent
	cmp	DWORD PTR [rdx], r8d
	jne	SHORT $LN3@equivalent
	mov	al, 1

; 418  : }

	ret	0
$LN3@equivalent:

; 417  :     return *this == _Code.category() && _Code.value() == _Errval;

	xor	al, al

; 418  : }

	ret	0
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\stdexcept
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0_System_error@std@@IEAA@Verror_code@1@@Z
_TEXT	SEGMENT
$T2 = 48
this$GSCopy$ = 80
_InitData$10 = 80
__$ArrayPad$ = 96
this$ = 128
_Errcode$ = 136
??0_System_error@std@@IEAA@Verror_code@1@@Z PROC	; std::_System_error::_System_error, COMDAT

; 473  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

$LN63:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	mov	rbx, rcx

; 207  :         return category().message(value());

	mov	rcx, QWORD PTR [rdx+8]

; 473  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	mov	rdi, rdx

; 207  :         return category().message(value());

	mov	r8d, DWORD PTR [rdx]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR $T2[rsp+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 60   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rbx], rcx
	lea	rdx, QWORD PTR [rbx+8]
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T2[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 61   :         __std_exception_data _InitData = { _Message, true };

	mov	BYTE PTR _InitData$10[rsp+8], 1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR $T2[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 62   :         __std_exception_copy(&_InitData, &_Data);

	lea	rcx, QWORD PTR _InitData$10[rsp]
	mov	QWORD PTR _InitData$10[rsp], rax
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T2[rsp+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\stdexcept

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

	lea	rax, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rbx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN42@System_err
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T2[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN50@System_err

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN50@System_err
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN50@System_err:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN42@System_err:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error

; 473  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	vmovups	xmm0, XMMWORD PTR [rdi]
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	vmovups	XMMWORD PTR [rbx+24], xmm0
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
$LN60@System_err:
??0_System_error@std@@IEAA@Verror_code@1@@Z ENDP	; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_G_System_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_System_error@std@@UEAAPEAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN18@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN18@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G_System_error@std@@UEAAPEAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1_System_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_System_error@std@@UEAA@XZ PROC			; std::_System_error::~_System_error, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1_System_error@std@@UEAA@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\stdexcept
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0system_error@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
$T2 = 48
$T5 = 64
this$GSCopy$ = 96
_InitData$14 = 96
__$ArrayPad$ = 112
this$ = 144
_Errval$ = 152
_Errcat$ = 160
??0system_error@std@@QEAA@HAEBVerror_category@1@@Z PROC	; std::system_error::system_error, COMDAT

; 492  :     system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat)) {}

$LN70:
	push	rbx
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	mov	r9, r8

; 207  :         return category().message(value());

	mov	rax, QWORD PTR [r8]

; 492  :     system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat)) {}

	mov	rbx, rcx

; 171  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	QWORD PTR $T2[rsp+8], r8

; 207  :         return category().message(value());

	mov	rcx, r9

; 171  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR $T2[rsp], edx

; 207  :         return category().message(value());

	mov	r8d, edx
	lea	rdx, QWORD PTR $T5[rsp]
	call	QWORD PTR [rax+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR $T5[rsp+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 60   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rbx], rcx
	lea	rdx, QWORD PTR [rbx+8]
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T5[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 61   :         __std_exception_data _InitData = { _Message, true };

	mov	BYTE PTR _InitData$14[rsp+8], 1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR $T5[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 62   :         __std_exception_copy(&_InitData, &_Data);

	lea	rcx, QWORD PTR _InitData$14[rsp]
	mov	QWORD PTR _InitData$14[rsp], rax
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T5[rsp+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\stdexcept

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

	lea	rax, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rbx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN48@system_err
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN56@system_err

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN56@system_err
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN56@system_err:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN48@system_err:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error

; 473  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	vmovups	xmm0, XMMWORD PTR $T2[rsp]

; 492  :     system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat)) {}

	lea	rax, OFFSET FLAT:??_7system_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 473  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

	vmovups	XMMWORD PTR [rbx+24], xmm0

; 492  :     system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat)) {}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 128				; 00000080H
	pop	rbx
	ret	0
$LN67@system_err:
??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ENDP	; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gsystem_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gsystem_error@std@@UEAAPEAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
$LN27:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN23@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN23@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gsystem_error@std@@UEAAPEAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1system_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1system_error@std@@UEAA@XZ PROC			; std::system_error::~system_error, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1system_error@std@@UEAA@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0system_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0system_error@std@@QEAA@AEBV01@@Z PROC		; std::system_error::system_error, COMDAT
$LN19:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 73   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax
	lea	rdx, QWORD PTR [rcx+8]
	mov	rdi, rcx
	vpxor	xmm0, xmm0, xmm0

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rbx+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rdi], rax
	lea	rax, OFFSET FLAT:??_7system_error@std@@6B@
	vmovups	xmm0, XMMWORD PTR [rbx+24]
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi], rax
	mov	rax, rdi
	vmovups	XMMWORD PTR [rdi+24], xmm0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0system_error@std@@QEAA@AEBV01@@Z ENDP		; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0_System_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0_System_error@std@@QEAA@AEBV01@@Z PROC		; std::_System_error::_System_error, COMDAT
$LN14:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 73   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax
	lea	rdx, QWORD PTR [rcx+8]
	mov	rdi, rcx
	vpxor	xmm0, xmm0, xmm0

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rbx+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rdi], rax
	mov	rax, rdi
	vmovups	xmm0, XMMWORD PTR [rbx+24]
	mov	rbx, QWORD PTR [rsp+48]
	vmovups	XMMWORD PTR [rdi+24], xmm0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0_System_error@std@@QEAA@AEBV01@@Z ENDP		; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??0_System_error_message@std@@QEAA@K@Z
_TEXT	SEGMENT
this$ = 48
_Ec$ = 56
??0_System_error_message@std@@QEAA@K@Z PROC		; std::_System_error_message::_System_error_message, COMDAT

; 523  :     explicit _System_error_message(const unsigned long _Ec) noexcept

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, edx

; 524  :         : _Str(nullptr), _Length(_CSTD __std_system_error_allocate_message(_Ec, &_Str)) {}

	mov	QWORD PTR [rcx], 0
	mov	rdx, rcx
	mov	rbx, rcx
	mov	ecx, eax
	call	__std_system_error_allocate_message
	mov	QWORD PTR [rbx+8], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_System_error_message@std@@QEAA@K@Z ENDP		; std::_System_error_message::_System_error_message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??1_System_error_message@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_System_error_message@std@@QEAA@XZ PROC		; std::_System_error_message::~_System_error_message, COMDAT

; 530  :         _CSTD __std_system_error_deallocate_message(_Str);

	mov	rcx, QWORD PTR [rcx]
	jmp	__std_system_error_deallocate_message
??1_System_error_message@std@@QEAA@XZ ENDP		; std::_System_error_message::~_System_error_message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_Generic_error_category@std@@UEBAPEBDXZ PROC	; std::_Generic_error_category::name, COMDAT

; 539  :         return "generic";

	lea	rax, OFFSET FLAT:??_C@_07DCLBNMLN@generic@

; 540  :     }

	ret	0
?name@_Generic_error_category@std@@UEBAPEBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Errcode$ = 80
?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT

; 542  :     _NODISCARD string message(int _Errcode) const override {

$LN27:
	push	rbx
	sub	rsp, 48					; 00000030H

; 543  :         return _Syserror_map(_Errcode);

	mov	ecx, r8d
	mov	rbx, rdx
	call	QWORD PTR __imp_?_Syserror_map@std@@YAPEBDH@Z
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rbx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rbx+16], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

	mov	r8, -1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rbx+24], 0
$LL23@message:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

	inc	r8
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL23@message
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rax
	mov	rcx, rbx
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error

; 543  :         return _Syserror_map(_Errcode);

	mov	rax, rbx

; 544  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Generic_error_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Generic_error_category@std@@UEAAPEAXI@Z PROC	; std::_Generic_error_category::`scalar deleting destructor', COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN5@scalar
	mov	edx, 16
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G_Generic_error_category@std@@UEAAPEAXI@Z ENDP	; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_Generic_error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Generic_error_category@std@@UEAA@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
	ret	0
??1_Generic_error_category@std@@UEAA@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?name@_System_error_category@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_System_error_category@std@@UEBAPEBDXZ PROC	; std::_System_error_category::name, COMDAT

; 571  :         return "system";

	lea	rax, OFFSET FLAT:??_C@_06FHFOAHML@system@

; 572  :     }

	ret	0
?name@_System_error_category@std@@UEBAPEBDXZ ENDP	; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_Msg$ = 40
__$ReturnUdt$GSCopy$ = 40
__$ArrayPad$ = 56
this$ = 80
__$ReturnUdt$ = 88
_Errcode$ = 96
?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT

; 574  :     _NODISCARD string message(int _Errcode) const override {

$LN53:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	edi, edi

; 524  :         : _Str(nullptr), _Length(_CSTD __std_system_error_allocate_message(_Ec, &_Str)) {}

	mov	QWORD PTR _Msg$[rsp], rdi
	lea	rdx, QWORD PTR _Msg$[rsp]
	mov	ecx, r8d
	call	__std_system_error_allocate_message
	mov	QWORD PTR _Msg$[rsp+8], rax

; 575  :         const _System_error_message _Msg(static_cast<unsigned long>(_Errcode));
; 576  : 
; 577  :         if (_Msg._Str && _Msg._Length != 0) {

	mov	rdx, QWORD PTR _Msg$[rsp]
	test	rdx, rdx
	je	SHORT $LN2@message
	test	rax, rax
	je	SHORT $LN2@message
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 756  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	mov	r8, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error

; 579  :             return string{_Msg._Str, _Msg._Length};

	jmp	SHORT $LN50@message
$LN2@message:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 756  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	mov	r8d, 13
	lea	rdx, OFFSET FLAT:?_Unknown_error@?6??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_System_error_category::message'::`7'::_Unknown_error
$LN50@message:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error

; 585  :     }

	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rbx], xmm0
	mov	QWORD PTR [rbx+16], rdi
	mov	QWORD PTR [rbx+24], rdi
	mov	rcx, rbx
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	mov	rcx, QWORD PTR _Msg$[rsp]
	call	__std_system_error_deallocate_message
	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Msg$ = 40
__$ReturnUdt$GSCopy$ = 40
__$ArrayPad$ = 56
this$ = 80
__$ReturnUdt$ = 88
_Errcode$ = 96
?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA PROC ; `std::_System_error_category::message'::`1'::dtor$0
	lea	rcx, QWORD PTR _Msg$[rdx]
	jmp	??1_System_error_message@std@@QEAA@XZ	; std::_System_error_message::~_System_error_message
?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA ENDP ; `std::_System_error_category::message'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Errval$ = 64
?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT

; 587  :     _NODISCARD error_condition default_error_condition(int _Errval) const noexcept override {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, r8d
	mov	rbx, rdx

; 588  :         if (_Errval == 0) {

	test	r8d, r8d
	jne	SHORT $LN2@default_er

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rdx], r8d
	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static
	mov	QWORD PTR [rdx+8], rax

; 595  :             return error_condition(_Errval, _STD system_category());
; 596  :         } else {
; 597  :             return error_condition(_Posv, _STD generic_category());
; 598  :         }
; 599  :     }

	mov	rax, rdx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@default_er:

; 589  :             return error_condition(0, _STD generic_category());
; 590  :         }
; 591  : 
; 592  :         // make error_condition for error code (generic if possible)
; 593  :         const int _Posv = _Winerror_map(_Errval);

	mov	ecx, edi
	call	QWORD PTR __imp_?_Winerror_map@std@@YAHH@Z

; 594  :         if (_Posv == 0) {

	test	eax, eax
	jne	SHORT $LN3@default_er

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rbx], edi
	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static

; 595  :             return error_condition(_Errval, _STD system_category());
; 596  :         } else {
; 597  :             return error_condition(_Posv, _STD generic_category());
; 598  :         }
; 599  :     }

	mov	QWORD PTR [rbx+8], rax
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@default_er:

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	DWORD PTR [rbx], eax
	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAAEBV_Generic_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static

; 595  :             return error_condition(_Errval, _STD system_category());
; 596  :         } else {
; 597  :             return error_condition(_Posv, _STD generic_category());
; 598  :         }
; 599  :     }

	mov	QWORD PTR [rbx+8], rax
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_System_error_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_System_error_category@std@@UEAAPEAXI@Z PROC	; std::_System_error_category::`scalar deleting destructor', COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN5@scalar
	mov	edx, 16
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G_System_error_category@std@@UEAAPEAXI@Z ENDP	; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_System_error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_System_error_category@std@@UEAA@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
	ret	0
??1_System_error_category@std@@UEAA@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ?system_category@std@@YAAEBVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAAEBVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 702  :     return _Immortalize_memcpy_image<_System_error_category>();

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static

; 703  : }

	ret	0
?system_category@std@@YAAEBVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??1locale@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1locale@std@@QEAA@XZ PROC				; std::locale::~locale, COMDAT

; 353  :     ~locale() noexcept {

$LN9:
	sub	rsp, 40					; 00000028H

; 354  :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN4@locale

; 355  :             delete _Ptr->_Decref();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	test	rax, rax
	je	SHORT $LN4@locale
	mov	rcx, QWORD PTR [rax]
	mov	edx, 1
	mov	r8, QWORD PTR [rcx]
	mov	rcx, rax

; 356  :         }
; 357  :     }

	add	rsp, 40					; 00000028H

; 355  :             delete _Ptr->_Decref();

	rex_jmp	r8
$LN4@locale:

; 356  :         }
; 357  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1locale@std@@QEAA@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
_TEXT	SEGMENT
this$ = 48
_Id$ = 56
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z PROC	; std::locale::_Getfacet, COMDAT

; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	rdx, QWORD PTR [rcx+8]
	lea	rdi, QWORD PTR [rbx*8]
	cmp	rbx, QWORD PTR [rdx+24]
	jae	SHORT $LN6@Getfacet
	mov	rax, QWORD PTR [rdx+16]
	mov	rax, QWORD PTR [rdi+rax]

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

	test	rax, rax
	jne	SHORT $LN3@Getfacet
	jmp	SHORT $LN8@Getfacet
$LN6@Getfacet:

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	eax, eax
$LN8@Getfacet:

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [rdx+36], 0
	je	SHORT $LN3@Getfacet

; 379  :             return _Facptr; // found facet or not transparent
; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 384  :         if (_Id < _Ptr0->_Facetcount) {

	cmp	rbx, QWORD PTR [rax+24]
	jae	SHORT $LN4@Getfacet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

	mov	rax, QWORD PTR [rax+16]
	mov	rax, QWORD PTR [rdi+rax]

; 389  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@Getfacet:

; 386  :         }
; 387  : 
; 388  :         return nullptr; // no entry in current locale

	xor	eax, eax
$LN3@Getfacet:

; 389  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ENDP	; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 73   : inline bool _Fgetc(char& _Byte, FILE* _File) { // get a char element from a C stream

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 74   :     int _Meta;
; 75   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

	mov	rcx, rdx
	call	QWORD PTR __imp_fgetc
	cmp	eax, -1
	jne	SHORT $LN2@Fgetc

; 76   :         return false;

	xor	al, al

; 80   :     }
; 81   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Fgetc:

; 77   :     } else { // got one, convert to char
; 78   :         _Byte = static_cast<char>(_Meta);

	mov	BYTE PTR [rbx], al

; 79   :         return true;

	mov	al, 1

; 80   :     }
; 81   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 113  : inline bool _Fputc(char _Byte, FILE* _File) { // put a char element to a C stream

$LN4:
	sub	rsp, 40					; 00000028H

; 114  :     return _CSTD fputc(_Byte, _File) != EOF;

	movsx	ecx, cl
	call	QWORD PTR __imp_fputc
	cmp	eax, -1
	setne	al

; 115  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 135  : inline bool _Ungetc(const char& _Byte, FILE* _File) { // put back a char element to a C stream

$LN4:
	sub	rsp, 40					; 00000028H

; 136  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

	movzx	ecx, BYTE PTR [rcx]
	call	QWORD PTR __imp_ungetc
	cmp	eax, -1
	setne	al

; 137  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Document.h
;	COMDAT ?roots@Document@Json@@QEBA@XZ
_TEXT	SEGMENT
this$ = 8
?roots@Document@Json@@QEBA@XZ PROC			; Json::Document::roots, COMDAT

; 25   : 		const auto& roots() const { return m_roots; };

	mov	rax, rcx
	ret	0
?roots@Document@Json@@QEBA@XZ ENDP			; Json::Document::roots
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ??0Array@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Array@Json@@QEAA@XZ PROC				; Json::Array::Array, COMDAT

; 17   : 		Array() : Value() {};

	lea	rax, OFFSET FLAT:??_7Array@Json@@6B@
	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h

; 17   : 		Array() : Value() {};

	mov	rax, rcx
	ret	0
??0Array@Json@@QEAA@XZ ENDP				; Json::Array::Array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isArray@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isArray@Array@Json@@UEBA_NXZ PROC			; Json::Array::isArray, COMDAT

; 19   : 		bool isArray() const override { return true; }

	mov	al, 1
	ret	0
?isArray@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isBool@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isBool@Array@Json@@UEBA_NXZ PROC			; Json::Array::isBool, COMDAT

; 20   : 		bool isBool() const override { return false; }

	xor	al, al
	ret	0
?isBool@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isNumber@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNumber@Array@Json@@UEBA_NXZ PROC			; Json::Array::isNumber, COMDAT

; 21   : 		bool isNumber() const override { return false; }

	xor	al, al
	ret	0
?isNumber@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isObject@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isObject@Array@Json@@UEBA_NXZ PROC			; Json::Array::isObject, COMDAT

; 22   : 		bool isObject() const override { return false; }

	xor	al, al
	ret	0
?isObject@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isString@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isString@Array@Json@@UEBA_NXZ PROC			; Json::Array::isString, COMDAT

; 23   : 		bool isString() const override { return false; }

	xor	al, al
	ret	0
?isString@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
;	COMDAT ?isNull@Array@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNull@Array@Json@@UEBA_NXZ PROC			; Json::Array::isNull, COMDAT

; 24   : 		bool isNull() const override { return false; }

	xor	al, al
	ret	0
?isNull@Array@Json@@UEBA_NXZ ENDP			; Json::Array::isNull
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GArray@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GArray@Json@@UEAAPEAXI@Z PROC			; Json::Array::`scalar deleting destructor', COMDAT
$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx
	add	rcx, 8
	call	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
	test	bl, 1
	je	SHORT $LN13@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GArray@Json@@UEAAPEAXI@Z ENDP			; Json::Array::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1Array@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Array@Json@@UEAA@XZ PROC				; Json::Array::~Array, COMDAT
	add	rcx, 8
	jmp	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
??1Array@Json@@UEAA@XZ ENDP				; Json::Array::~Array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Value.h
;	COMDAT ??1Value@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Value@Json@@UEAA@XZ PROC				; Json::Value::~Value, COMDAT

; 17   : 		virtual ~Value() = default;

	ret	0
??1Value@Json@@UEAA@XZ ENDP				; Json::Value::~Value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Value.h
;	COMDAT ??0Value@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Value@Json@@QEAA@XZ PROC				; Json::Value::Value, COMDAT

; 16   : 		Value() = default;

	lea	rax, OFFSET FLAT:??_7Value@Json@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0Value@Json@@QEAA@XZ ENDP				; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GValue@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GValue@Json@@UEAAPEAXI@Z PROC			; Json::Value::`scalar deleting destructor', COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN5@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GValue@Json@@UEAAPEAXI@Z ENDP			; Json::Value::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
;	COMDAT ??0Bool@Json@@QEAA@_N@Z
_TEXT	SEGMENT
this$ = 8
value$ = 16
??0Bool@Json@@QEAA@_N@Z PROC				; Json::Bool::Bool, COMDAT

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rax, OFFSET FLAT:??_7Bool@Json@@6B@
	mov	BYTE PTR [rcx+8], dl
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0Bool@Json@@QEAA@_N@Z ENDP				; Json::Bool::Bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
;	COMDAT ?isArray@Bool@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isArray@Bool@Json@@UEBA_NXZ PROC			; Json::Bool::isArray, COMDAT

; 15   : 		bool isArray() const override { return false; }

	xor	al, al
	ret	0
?isArray@Bool@Json@@UEBA_NXZ ENDP			; Json::Bool::isArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
;	COMDAT ?isBool@Bool@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isBool@Bool@Json@@UEBA_NXZ PROC			; Json::Bool::isBool, COMDAT

; 16   : 		bool isBool() const override { return true; }

	mov	al, 1
	ret	0
?isBool@Bool@Json@@UEBA_NXZ ENDP			; Json::Bool::isBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
;	COMDAT ?isNumber@Bool@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNumber@Bool@Json@@UEBA_NXZ PROC			; Json::Bool::isNumber, COMDAT

; 17   : 		bool isNumber() const override { return false; }

	xor	al, al
	ret	0
?isNumber@Bool@Json@@UEBA_NXZ ENDP			; Json::Bool::isNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
;	COMDAT ?isObject@Bool@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isObject@Bool@Json@@UEBA_NXZ PROC			; Json::Bool::isObject, COMDAT

; 18   : 		bool isObject() const override { return false; }

	xor	al, al
	ret	0
?isObject@Bool@Json@@UEBA_NXZ ENDP			; Json::Bool::isObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
;	COMDAT ?isString@Bool@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isString@Bool@Json@@UEBA_NXZ PROC			; Json::Bool::isString, COMDAT

; 19   : 		bool isString() const override { return false; }

	xor	al, al
	ret	0
?isString@Bool@Json@@UEBA_NXZ ENDP			; Json::Bool::isString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
;	COMDAT ?isNull@Bool@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNull@Bool@Json@@UEBA_NXZ PROC			; Json::Bool::isNull, COMDAT

; 20   : 		bool isNull() const override { return false; }

	xor	al, al
	ret	0
?isNull@Bool@Json@@UEBA_NXZ ENDP			; Json::Bool::isNull
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GBool@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GBool@Json@@UEAAPEAXI@Z PROC				; Json::Bool::`scalar deleting destructor', COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN5@scalar
	mov	edx, 16
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GBool@Json@@UEAAPEAXI@Z ENDP				; Json::Bool::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1Bool@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Bool@Json@@UEAA@XZ PROC				; Json::Bool::~Bool, COMDAT
	ret	0
??1Bool@Json@@UEAA@XZ ENDP				; Json::Bool::~Bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
;	COMDAT ??0Null@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Null@Json@@QEAA@XZ PROC				; Json::Null::Null, COMDAT

; 9    : 		Null() : Value() {};

	lea	rax, OFFSET FLAT:??_7Null@Json@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0Null@Json@@QEAA@XZ ENDP				; Json::Null::Null
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
;	COMDAT ?isArray@Null@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isArray@Null@Json@@UEBA_NXZ PROC			; Json::Null::isArray, COMDAT

; 11   : 		bool isArray() const override { return false; }

	xor	al, al
	ret	0
?isArray@Null@Json@@UEBA_NXZ ENDP			; Json::Null::isArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
;	COMDAT ?isBool@Null@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isBool@Null@Json@@UEBA_NXZ PROC			; Json::Null::isBool, COMDAT

; 12   : 		bool isBool() const override { return false; }

	xor	al, al
	ret	0
?isBool@Null@Json@@UEBA_NXZ ENDP			; Json::Null::isBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
;	COMDAT ?isNumber@Null@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNumber@Null@Json@@UEBA_NXZ PROC			; Json::Null::isNumber, COMDAT

; 13   : 		bool isNumber() const override { return false; }

	xor	al, al
	ret	0
?isNumber@Null@Json@@UEBA_NXZ ENDP			; Json::Null::isNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
;	COMDAT ?isObject@Null@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isObject@Null@Json@@UEBA_NXZ PROC			; Json::Null::isObject, COMDAT

; 14   : 		bool isObject() const override { return false; }

	xor	al, al
	ret	0
?isObject@Null@Json@@UEBA_NXZ ENDP			; Json::Null::isObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
;	COMDAT ?isString@Null@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isString@Null@Json@@UEBA_NXZ PROC			; Json::Null::isString, COMDAT

; 15   : 		bool isString() const override { return false; }

	xor	al, al
	ret	0
?isString@Null@Json@@UEBA_NXZ ENDP			; Json::Null::isString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
;	COMDAT ?isNull@Null@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNull@Null@Json@@UEBA_NXZ PROC			; Json::Null::isNull, COMDAT

; 16   : 		bool isNull() const override { return true; }

	mov	al, 1
	ret	0
?isNull@Null@Json@@UEBA_NXZ ENDP			; Json::Null::isNull
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GNull@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GNull@Json@@UEAAPEAXI@Z PROC				; Json::Null::`scalar deleting destructor', COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN5@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GNull@Json@@UEAAPEAXI@Z ENDP				; Json::Null::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1Null@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Null@Json@@UEAA@XZ PROC				; Json::Null::~Null, COMDAT
	ret	0
??1Null@Json@@UEAA@XZ ENDP				; Json::Null::~Null
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ??0Number@Json@@QEAA@N@Z
_TEXT	SEGMENT
this$ = 8
value$ = 16
??0Number@Json@@QEAA@N@Z PROC				; Json::Number::Number, COMDAT

; 13   : 		Number(double value) : Value(), m_value(value) {};

	lea	rax, OFFSET FLAT:??_7Number@Json@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	vmovsd	QWORD PTR [rcx+8], xmm1
	ret	0
??0Number@Json@@QEAA@N@Z ENDP				; Json::Number::Number
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isArray@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isArray@Number@Json@@UEBA_NXZ PROC			; Json::Number::isArray, COMDAT

; 15   : 		bool isArray() const override { return false; }

	xor	al, al
	ret	0
?isArray@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isBool@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isBool@Number@Json@@UEBA_NXZ PROC			; Json::Number::isBool, COMDAT

; 16   : 		bool isBool() const override { return false; }

	xor	al, al
	ret	0
?isBool@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isNumber@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNumber@Number@Json@@UEBA_NXZ PROC			; Json::Number::isNumber, COMDAT

; 17   : 		bool isNumber() const override { return true; }

	mov	al, 1
	ret	0
?isNumber@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isObject@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isObject@Number@Json@@UEBA_NXZ PROC			; Json::Number::isObject, COMDAT

; 18   : 		bool isObject() const override { return false; }

	xor	al, al
	ret	0
?isObject@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isString@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isString@Number@Json@@UEBA_NXZ PROC			; Json::Number::isString, COMDAT

; 19   : 		bool isString() const override { return false; }

	xor	al, al
	ret	0
?isString@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
;	COMDAT ?isNull@Number@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNull@Number@Json@@UEBA_NXZ PROC			; Json::Number::isNull, COMDAT

; 20   : 		bool isNull() const override { return false; }

	xor	al, al
	ret	0
?isNull@Number@Json@@UEBA_NXZ ENDP			; Json::Number::isNull
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GNumber@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GNumber@Json@@UEAAPEAXI@Z PROC			; Json::Number::`scalar deleting destructor', COMDAT
$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN5@scalar
	mov	edx, 16
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GNumber@Json@@UEAAPEAXI@Z ENDP			; Json::Number::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1Number@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Number@Json@@UEAA@XZ PROC				; Json::Number::~Number, COMDAT
	ret	0
??1Number@Json@@UEAA@XZ ENDP				; Json::Number::~Number
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h
;	COMDAT ?_Floor_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Value$ = 8
?_Floor_of_log_2@std@@YAK_K@Z PROC			; std::_Floor_of_log_2, COMDAT

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rcx, 1

; 26   :     unsigned long _Result;
; 27   : 
; 28   : #ifdef _M_CEE_PURE
; 29   : #ifdef _WIN64
; 30   :     _Result = 63;
; 31   : #else // ^^^ 64-bit / 32-bit vvv
; 32   :     _Result = 31;
; 33   : #endif // ^^^ 32-bit ^^^
; 34   : 
; 35   :     while ((size_t{1} << _Result) > _Value) {
; 36   :         --_Result;
; 37   :     }
; 38   : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 39   : #ifdef _WIN64
; 40   :     // CodeQL [SM02313] _Result is always initialized: the code above guarantees that _Value is non-zero.
; 41   :     _BitScanReverse64(&_Result, _Value);

	bsr	rax, rcx

; 42   : #else // ^^^ 64-bit / 32-bit vvv
; 43   :     // CodeQL [SM02313] _Result is always initialized: the code above guarantees that _Value is non-zero.
; 44   :     _BitScanReverse(&_Result, _Value);
; 45   : #endif // ^^^ 32-bit ^^^
; 46   : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 47   : 
; 48   :     return _Result;
; 49   : }

	ret	0
?_Floor_of_log_2@std@@YAK_K@Z ENDP			; std::_Floor_of_log_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h
;	COMDAT ?_Ceiling_of_log_2@std@@YAK_K@Z
_TEXT	SEGMENT
_Value$ = 8
?_Ceiling_of_log_2@std@@YAK_K@Z PROC			; std::_Ceiling_of_log_2, COMDAT

; 52   :                                                                                   // pre: _Value > 1
; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	rax, QWORD PTR [rcx-1]

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rax, 1

; 26   :     unsigned long _Result;
; 27   : 
; 28   : #ifdef _M_CEE_PURE
; 29   : #ifdef _WIN64
; 30   :     _Result = 63;
; 31   : #else // ^^^ 64-bit / 32-bit vvv
; 32   :     _Result = 31;
; 33   : #endif // ^^^ 32-bit ^^^
; 34   : 
; 35   :     while ((size_t{1} << _Result) > _Value) {
; 36   :         --_Result;
; 37   :     }
; 38   : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 39   : #ifdef _WIN64
; 40   :     // CodeQL [SM02313] _Result is always initialized: the code above guarantees that _Value is non-zero.
; 41   :     _BitScanReverse64(&_Result, _Value);

	bsr	rax, rax

; 52   :                                                                                   // pre: _Value > 1
; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	inc	eax

; 54   : }

	ret	0
?_Ceiling_of_log_2@std@@YAK_K@Z ENDP			; std::_Ceiling_of_log_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h
;	COMDAT ??0Object@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 32
this$GSCopy$ = 32
this$ = 64
??0Object@Json@@QEAA@XZ PROC				; Json::Object::Object, COMDAT

; 18   : 		Object() : Value() {};

$LN80:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	lea	rax, OFFSET FLAT:??_7Object@Json@@6B@
	mov	QWORD PTR [rcx], rax
	lea	rbx, QWORD PTR [rcx+8]
	mov	QWORD PTR this$[rsp], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	xor	esi, esi
	mov	DWORD PTR [rbx], esi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rbx+8], rsi
	mov	QWORD PTR [rbx+16], rsi

; 1852 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rax], rax

; 1853 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1854 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx+8], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 371  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	lea	rcx, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rsi
	mov	QWORD PTR [rcx+8], rsi
	mov	QWORD PTR [rcx+16], rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 371  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR [rbx+48], 7
	mov	QWORD PTR [rbx+56], 8

; 372  :         // construct empty hash table
; 373  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [rbx], 1065353216		; 3f800000H

; 374  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 16
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Assign_grow
	npad	1
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h

; 18   : 		Object() : Value() {};

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0Object@Json@@QEAA@XZ ENDP				; Json::Object::Object
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$GSCopy$ = 32
this$ = 64
?dtor$2@?0???0Object@Json@@QEAA@XZ@4HA PROC		; `Json::Object::Object'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
?dtor$2@?0???0Object@Json@@QEAA@XZ@4HA ENDP		; `Json::Object::Object'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 32
this$GSCopy$ = 32
this$ = 64
?dtor$3@?0???0Object@Json@@QEAA@XZ@4HA PROC		; `Json::Object::Object'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >
?dtor$3@?0???0Object@Json@@QEAA@XZ@4HA ENDP		; `Json::Object::Object'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h
;	COMDAT ?isArray@Object@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isArray@Object@Json@@UEBA_NXZ PROC			; Json::Object::isArray, COMDAT

; 20   : 		bool isArray() const override { return false; }

	xor	al, al
	ret	0
?isArray@Object@Json@@UEBA_NXZ ENDP			; Json::Object::isArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h
;	COMDAT ?isBool@Object@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isBool@Object@Json@@UEBA_NXZ PROC			; Json::Object::isBool, COMDAT

; 21   : 		bool isBool() const override { return false; }

	xor	al, al
	ret	0
?isBool@Object@Json@@UEBA_NXZ ENDP			; Json::Object::isBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h
;	COMDAT ?isNumber@Object@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNumber@Object@Json@@UEBA_NXZ PROC			; Json::Object::isNumber, COMDAT

; 22   : 		bool isNumber() const override { return false; }

	xor	al, al
	ret	0
?isNumber@Object@Json@@UEBA_NXZ ENDP			; Json::Object::isNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h
;	COMDAT ?isObject@Object@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isObject@Object@Json@@UEBA_NXZ PROC			; Json::Object::isObject, COMDAT

; 23   : 		bool isObject() const override { return true; }

	mov	al, 1
	ret	0
?isObject@Object@Json@@UEBA_NXZ ENDP			; Json::Object::isObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h
;	COMDAT ?isString@Object@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isString@Object@Json@@UEBA_NXZ PROC			; Json::Object::isString, COMDAT

; 24   : 		bool isString() const override { return false; }

	xor	al, al
	ret	0
?isString@Object@Json@@UEBA_NXZ ENDP			; Json::Object::isString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h
;	COMDAT ?isNull@Object@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNull@Object@Json@@UEBA_NXZ PROC			; Json::Object::isNull, COMDAT

; 25   : 		bool isNull() const override { return false; }

	xor	al, al
	ret	0
?isNull@Object@Json@@UEBA_NXZ ENDP			; Json::Object::isNull
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GObject@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GObject@Json@@UEAAPEAXI@Z PROC			; Json::Object::`scalar deleting destructor', COMDAT
$LN19:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx
	add	rcx, 8
	call	??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	test	bl, 1
	je	SHORT $LN15@scalar
	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN15@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GObject@Json@@UEAAPEAXI@Z ENDP			; Json::Object::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1Object@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Object@Json@@UEAA@XZ PROC				; Json::Object::~Object, COMDAT
	add	rcx, 8
	jmp	??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
??1Object@Json@@UEAA@XZ ENDP				; Json::Object::~Object
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >, COMDAT
	jmp	??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::~_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >, COMDAT
$LN133:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 307  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	xor	ebx, ebx
	mov	rcx, QWORD PTR [rcx+24]
	test	rcx, rcx
	je	SHORT $LN8@Hash

; 279  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rsi+40]
	sub	rdx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@Hash

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN24@Hash

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN25@Hash:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 310  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	QWORD PTR [rsi+24], rbx

; 311  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rsi+32], rbx

; 312  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rsi+40], rbx
$LN8@Hash:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 1518 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rsp+72], rdi

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rbx

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rdi, QWORD PTR [rcx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rdi, rdi
	je	SHORT $LN122@Hash
	npad	3
$LL40@Hash:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdi]

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rdi+16]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rdi, rbx
	test	rbx, rbx
	jne	SHORT $LL40@Hash
$LN122@Hash:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rsi+8]
	mov	edx, 56					; 00000038H
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rsi
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN24@Hash:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN130@Hash:
??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::~_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isArray@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isArray@String@Json@@UEBA_NXZ PROC			; Json::String::isArray, COMDAT

; 19   : 		bool isArray() const override { return false; }

	xor	al, al
	ret	0
?isArray@String@Json@@UEBA_NXZ ENDP			; Json::String::isArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isBool@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isBool@String@Json@@UEBA_NXZ PROC			; Json::String::isBool, COMDAT

; 20   : 		bool isBool() const override { return false; }

	xor	al, al
	ret	0
?isBool@String@Json@@UEBA_NXZ ENDP			; Json::String::isBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isNumber@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNumber@String@Json@@UEBA_NXZ PROC			; Json::String::isNumber, COMDAT

; 21   : 		bool isNumber() const override { return false; }

	xor	al, al
	ret	0
?isNumber@String@Json@@UEBA_NXZ ENDP			; Json::String::isNumber
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isObject@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isObject@String@Json@@UEBA_NXZ PROC			; Json::String::isObject, COMDAT

; 22   : 		bool isObject() const override { return false; }

	xor	al, al
	ret	0
?isObject@String@Json@@UEBA_NXZ ENDP			; Json::String::isObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isString@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isString@String@Json@@UEBA_NXZ PROC			; Json::String::isString, COMDAT

; 23   : 		bool isString() const override { return true; }

	mov	al, 1
	ret	0
?isString@String@Json@@UEBA_NXZ ENDP			; Json::String::isString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ?isNull@String@Json@@UEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isNull@String@Json@@UEBA_NXZ PROC			; Json::String::isNull, COMDAT

; 24   : 		bool isNull() const override { return false; }

	xor	al, al
	ret	0
?isNull@String@Json@@UEBA_NXZ ENDP			; Json::String::isNull
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??_GString@Json@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 64
__flags$ = 72
??_GString@Json@@UEAAPEAXI@Z PROC			; Json::String::`scalar deleting destructor', COMDAT
$LN51:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	edi, edx
	mov	rbx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+32]

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN28@scalar
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN36@scalar

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN35@scalar

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN36@scalar:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN28@scalar:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+24], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+32], 15

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+8], 0
	test	dil, 1
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN35@scalar:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN48@scalar:
??_GString@Json@@UEAAPEAXI@Z ENDP			; Json::String::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1String@Json@@UEAA@XZ
_TEXT	SEGMENT
this$ = 64
??1String@Json@@UEAA@XZ PROC				; Json::String::~String, COMDAT
$LN43:
	push	rbx
	sub	rsp, 48					; 00000030H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+32]
	mov	rbx, rcx

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN22@String
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN30@String

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN29@String

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN30@String:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN22@String:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+24], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+32], 15

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx+8], 0
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN29@String:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN40@String:
??1String@Json@@UEAA@XZ ENDP				; Json::String::~String
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 768  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN23:
	push	rbx
	sub	rsp, 32					; 00000020H

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax

; 768  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	rbx, rcx
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

	mov	r8, -1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
$LL19@basic_stri:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

	inc	r8
	cmp	BYTE PTR [rdx+r8], al
	jne	SHORT $LL19@basic_stri
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 770  :     }

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 974  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 495  : 
; 496  :         value_type _Buf[_BUF_SIZE];
; 497  :         pointer _Ptr;
; 498  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 499  : 
; 500  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }
; 512  :     };
; 513  :     _Bxty _Bx;
; 514  : 
; 515  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 516  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 495  : 
; 496  :         value_type _Buf[_BUF_SIZE];
; 497  :         pointer _Ptr;
; 498  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 499  : 
; 500  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }
; 512  :     };
; 513  :     _Bxty _Bx;
; 514  : 
; 515  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 516  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	rax, rcx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 444  :         // find length of null-terminated string
; 445  : #if _HAS_CXX17
; 446  : #ifdef __cpp_char8_t
; 447  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 448  : #if _HAS_U8_INTRINSICS
; 449  :             return __builtin_u8strlen(_First);
; 450  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 451  :             return _Primary_char_traits::length(_First);
; 452  : #endif // ^^^ no u8 intrinsics ^^^
; 453  :         } else
; 454  : #endif // defined(__cpp_char8_t)
; 455  :         {
; 456  :             return __builtin_strlen(_First);

	mov	rax, -1
$LL4@length:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL4@length

; 457  :         }
; 458  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 459  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 460  : #endif // ^^^ !_HAS_CXX17 ^^^
; 461  :     }

	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1121 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1122 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1123 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1124 : 
; 1125 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1126 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1127 :             _Xlength_error("size is too long for _Size_type");
; 1128 :         }
; 1129 :     }
; 1130 : 
; 1131 :     return static_cast<_Size_type>(_Len);

	mov	rax, rcx

; 1132 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 871  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN99:
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 56					; 00000038H

; 872  :         auto& _My_data = _Mypair._Myval2;
; 873  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 874  : 
; 875  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 876  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 877  :         } else {
; 878  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 879  :         }
; 880  : 
; 881  :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	mov	rdi, r8
	mov	r14, rdx
	mov	rsi, rcx
	cmp	r8, rbp
	ja	$LN96@Construct

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

	cmp	r8, 15
	ja	SHORT $LN3@Construct

; 890  :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 891  :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 898  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rdi+rsi], 0

; 929  :     }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rdi
	mov	QWORD PTR [rsp+48], rbx
	or	rax, 15
	cmp	rax, rbp

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN13@Construct

; 2980 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN38@Construct:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN39@Construct
	xor	ebx, ebx
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rbx
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN13@Construct:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN31@Construct

; 228  :         return nullptr;

	xor	ebx, ebx
	jmp	SHORT $LN30@Construct
$LN31@Construct:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN33@Construct

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN97@Construct
	jmp	SHORT $LN38@Construct
$LN39@Construct:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN30@Construct
$LN33@Construct:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN30@Construct:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 915  :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 916  :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0
	mov	rbx, QWORD PTR [rsp+48]

; 929  :     }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN96@Construct:

; 882  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN97@Construct:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN94@Construct:
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2378 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 2379 :         const size_type _Storage_max = // can always store small string
; 2380 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2381 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 2382 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2383 :         );
; 2384 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 78   : }

	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3111 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3112 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1543 :         return *this;

	mov	rax, rcx

; 1544 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3107 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3108 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 105  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 106  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 107  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 108  :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 109  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 110  : #if _HAS_CXX20
; 111  :         if (_STD is_constant_evaluated()) {
; 112  :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 113  :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 114  :                 _First1[_Idx] = _First2[_Idx];
; 115  :             }
; 116  : 
; 117  :             return _First1;
; 118  :         }
; 119  : #endif // _HAS_CXX20
; 120  : 
; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy

; 122  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 123  : 
; 124  :         return _First1;

	mov	rax, rbx

; 125  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 497  : #if _HAS_CXX20
; 498  :         if (_STD is_constant_evaluated()) {
; 499  :             return _Primary_char_traits::assign(_Left, _Right);
; 500  :         }
; 501  : #endif // _HAS_CXX20
; 502  :         _Left = _Right;
; 503  :     }

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 229  :         _Left = _Right;

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al

; 230  :     }

	ret	0
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??__E?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$di	SEGMENT
??__E?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic initializer for 'Json::Parser::nullLiteral'', COMDAT

; 43   : 		static inline const std::string nullLiteral = "null";

	lea	rcx, OFFSET FLAT:??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Parser::nullLiteral''
	jmp	atexit
??__E?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic initializer for 'Json::Parser::nullLiteral''
text$di	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??__E?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$di	SEGMENT
??__E?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic initializer for 'Json::Parser::trueLiteral'', COMDAT

; 44   : 		static inline const std::string trueLiteral = "true";

	lea	rcx, OFFSET FLAT:??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Parser::trueLiteral''
	jmp	atexit
??__E?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic initializer for 'Json::Parser::trueLiteral''
text$di	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??__E?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$di	SEGMENT
??__E?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic initializer for 'Json::Parser::falseLiteral'', COMDAT

; 45   : 		static inline const std::string falseLiteral = "false";

	lea	rcx, OFFSET FLAT:??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Parser::falseLiteral''
	jmp	atexit
??__E?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic initializer for 'Json::Parser::falseLiteral''
text$di	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T5 = 72
$T6 = 72
$T7 = 72
file$ = 112
__$ReturnUdt$GSCopy$ = 144
file_size$12 = 144
__$ArrayPad$ = 152
__$ReturnUdt$ = 176
filename$ = 184
?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Parser::parseFile, COMDAT

; 598  : 		static Document parseFile(const std::string& filename) {

$LN45:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	lea	rbp, QWORD PTR [rsp-87]
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-73], rax
	mov	rax, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-73], rcx
	xor	edi, edi
	vpxor	xmm0, xmm0, xmm0
	vmovups	YMMWORD PTR file$[rbp-73], ymm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15
	jbe	SHORT $LN15@parseFile

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN15@parseFile:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 23   :     DataPointer m_data = nullptr;

	mov	QWORD PTR file$[rbp-73], rdi

; 24   :     size_t m_size = 0;

	mov	QWORD PTR file$[rbp-65], rdi

; 25   : #ifdef _WIN32
; 26   :     void* m_file_handle = nullptr;

	vmovdqu	XMMWORD PTR file$[rbp-57], xmm0

; 105  :         else         m_file_handle = CreateFileA(

	mov	QWORD PTR [rsp+48], rdi
	mov	DWORD PTR [rsp+40], 128			; 00000080H
	mov	DWORD PTR [rsp+32], 3
	xor	r9d, r9d
	mov	edx, -2147483648			; 80000000H
	mov	r8d, 1
	mov	rcx, rax
	vzeroupper
	call	QWORD PTR __imp_CreateFileA
	mov	QWORD PTR file$[rbp-57], rax
	cmp	rax, -1

; 106  :             filename, GENERIC_READ, FILE_SHARE_READ, NULL,
; 107  :             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
; 108  :         );
; 109  : 
; 110  :         if (m_file_handle == INVALID_HANDLE_VALUE) {

	je	$LN41@parseFile

; 112  :         }
; 113  : 
; 114  :         LARGE_INTEGER file_size;
; 115  :         GetFileSizeEx(m_file_handle, &file_size);

	lea	rdx, QWORD PTR file_size$12[rbp-73]
	mov	rcx, rax
	call	QWORD PTR __imp_GetFileSizeEx

; 116  :         m_size = static_cast<std::size_t>(file_size.QuadPart);

	mov	rax, QWORD PTR file_size$12[rbp-73]
	mov	QWORD PTR file$[rbp-65], rax

; 117  : 
; 118  :         if constexpr (writable)
; 119  :             m_mapping_handle = CreateFileMappingA(
; 120  :                 m_file_handle, NULL, PAGE_READWRITE, 0, 0, NULL
; 121  :             );
; 122  :         else m_mapping_handle = CreateFileMappingA(

	mov	QWORD PTR [rsp+40], rdi
	mov	DWORD PTR [rsp+32], edi
	xor	r9d, r9d
	xor	edx, edx
	mov	r8d, 2
	mov	rcx, QWORD PTR file$[rbp-57]
	call	QWORD PTR __imp_CreateFileMappingA
	mov	rcx, rax
	mov	QWORD PTR file$[rbp-49], rax
	test	rax, rax

; 123  :             m_file_handle, NULL, PAGE_READONLY, 0, 0, NULL
; 124  :         );
; 125  : 
; 126  : 
; 127  :         if (!m_mapping_handle) {

	je	$LN42@parseFile

; 130  :         }
; 131  : 
; 132  :         if constexpr (writable)
; 133  :             m_data = static_cast<const char*>(MapViewOfFile(
; 134  :                 m_mapping_handle, FILE_MAP_WRITE, 0, 0, m_size
; 135  :             ));
; 136  :         else m_data = static_cast<const char*>(MapViewOfFile(

	mov	rax, QWORD PTR file$[rbp-65]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, 4
	call	QWORD PTR __imp_MapViewOfFile
	mov	QWORD PTR file$[rbp-73], rax
	test	rax, rax

; 137  :             m_mapping_handle, FILE_MAP_READ, 0, 0, m_size
; 138  :         ));
; 139  : 
; 140  :         if (!m_data) {

	je	SHORT $LN43@parseFile
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 602  : 			return parse(file);

	lea	rdx, QWORD PTR file$[rbp-73]
	mov	rcx, rbx
	call	??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z ; Json::Parser::parse<MappedFile<0> >
	npad	1
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 176  :         if (m_data) {

	mov	rcx, QWORD PTR file$[rbp-73]
	test	rcx, rcx
	je	SHORT $LN37@parseFile

; 177  : #ifdef _WIN32
; 178  :             UnmapViewOfFile(m_data);

	call	QWORD PTR __imp_UnmapViewOfFile

; 179  :             CloseHandle(m_mapping_handle);

	mov	rcx, QWORD PTR file$[rbp-49]
	call	QWORD PTR __imp_CloseHandle

; 180  :             CloseHandle(m_file_handle);

	mov	rcx, QWORD PTR file$[rbp-57]
	call	QWORD PTR __imp_CloseHandle
$LN37@parseFile:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 602  : 			return parse(file);

	mov	rax, rbx

; 603  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-73]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
$LN43@parseFile:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 141  :             CloseHandle(m_mapping_handle);

	mov	rcx, QWORD PTR file$[rbp-49]
	call	QWORD PTR __imp_CloseHandle

; 142  :             CloseHandle(m_file_handle);

	mov	rcx, QWORD PTR file$[rbp-57]
	call	QWORD PTR __imp_CloseHandle

; 143  :             throw std::system_error(GetLastError(), std::system_category());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	call	?system_category@std@@YAAEBVerror_category@1@XZ ; std::system_category
	mov	r8, rax
	lea	rcx, QWORD PTR $T7[rbp-73]
	call	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T7[rbp-73]
	call	_CxxThrowException
	int	3
$LN41@parseFile:

; 111  :             throw std::system_error(GetLastError(), std::system_category());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	call	?system_category@std@@YAAEBVerror_category@1@XZ ; std::system_category
	mov	r8, rax
	lea	rcx, QWORD PTR $T5[rbp-73]
	call	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T5[rbp-73]
	call	_CxxThrowException
	int	3
$LN42@parseFile:

; 128  :             CloseHandle(m_file_handle);

	mov	rcx, QWORD PTR file$[rbp-57]
	call	QWORD PTR __imp_CloseHandle

; 129  :             throw std::system_error(GetLastError(), std::system_category());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	call	?system_category@std@@YAAEBVerror_category@1@XZ ; std::system_category
	mov	r8, rax
	lea	rcx, QWORD PTR $T6[rbp-73]
	call	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T6[rbp-73]
	call	_CxxThrowException
	int	3
$LN39@parseFile:
?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Parser::parseFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 72
$T6 = 72
$T7 = 72
file$ = 112
__$ReturnUdt$GSCopy$ = 144
file_size$12 = 144
__$ArrayPad$ = 152
__$ReturnUdt$ = 176
filename$ = 184
?dtor$0@?0??parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Parser::parseFile'::`1'::dtor$0
	lea	rcx, QWORD PTR file$[rdx]
	jmp	??1?$MappedFile@$0A@@@QEAA@XZ		; MappedFile<0>::~MappedFile<0>
?dtor$0@?0??parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Parser::parseFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$yd	SEGMENT
??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic atexit destructor for 'Json::Parser::falseLiteral'', COMDAT
	sub	rsp, 56					; 00000038H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN21@falseLiter

; 3084 :             _ASAN_STRING_REMOVE(*this);
; 3085 :             auto& _Al = _Getal();
; 3086 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN29@falseLiter

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN28@falseLiter

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN29@falseLiter:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@falseLiter:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 3091 :         _My_data._Myres  = _Small_string_capacity;
; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 56					; 00000038H
	ret	0
$LN28@falseLiter:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN36@falseLiter:
??__F?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic atexit destructor for 'Json::Parser::falseLiteral''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$yd	SEGMENT
??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic atexit destructor for 'Json::Parser::trueLiteral'', COMDAT
	sub	rsp, 56					; 00000038H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN21@trueLitera

; 3084 :             _ASAN_STRING_REMOVE(*this);
; 3085 :             auto& _Al = _Getal();
; 3086 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN29@trueLitera

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN28@trueLitera

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN29@trueLitera:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@trueLitera:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 3091 :         _My_data._Myres  = _Small_string_capacity;
; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 56					; 00000038H
	ret	0
$LN28@trueLitera:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN36@trueLitera:
??__F?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic atexit destructor for 'Json::Parser::trueLiteral''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$yd	SEGMENT
??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic atexit destructor for 'Json::Parser::nullLiteral'', COMDAT
	sub	rsp, 56					; 00000038H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN21@nullLitera

; 3084 :             _ASAN_STRING_REMOVE(*this);
; 3085 :             auto& _Al = _Getal();
; 3086 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rcx, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN29@nullLitera

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN28@nullLitera

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN29@nullLitera:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@nullLitera:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, xmm0

; 3091 :         _My_data._Myres  = _Small_string_capacity;
; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B, 0
	add	rsp, 56					; 00000038H
	ret	0
$LN28@nullLitera:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN36@nullLitera:
??__F?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic atexit destructor for 'Json::Parser::nullLiteral''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$MappedFile@$0A@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$MappedFile@$0A@@@QEAAX_K@Z PROC	; MappedFile<0>::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	vmovups	YMMWORD PTR [rcx], ymm0
	vzeroupper
	ret	0
?__autoclassinit2@?$MappedFile@$0A@@@QEAAX_K@Z ENDP	; MappedFile<0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1Document@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Document@Json@@QEAA@XZ PROC				; Json::Document::~Document, COMDAT
	jmp	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
??1Document@Json@@QEAA@XZ ENDP				; Json::Document::~Document
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 48
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT

; 656  :         _NODISCARD static time_point now() noexcept { // get current time

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 657  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rdi, rax

; 658  :             const long long _Ctr  = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter
	mov	r9, rax

; 659  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 660  :             // The compiler recognizes the constants for frequency and time period and uses shifts and
; 661  :             // multiplies instead of divides to calculate the nanosecond value.
; 662  :             constexpr long long _TenMHz        = 10'000'000;
; 663  :             constexpr long long _TwentyFourMHz = 24'000'000;
; 664  :             if (_Freq == _TenMHz) {

	cmp	rdi, 10000000				; 00989680H
	jne	SHORT $LN2@now

; 665  :                 // 10 MHz is a very common QPC frequency on modern x86/x64 PCs. Optimizing for
; 666  :                 // this specific frequency can double the performance of this function by
; 667  :                 // avoiding the expensive frequency conversion path.
; 668  :                 static_assert(period::den % _TenMHz == 0, "It should never fail.");
; 669  :                 constexpr long long _Multiplier = period::den / _TenMHz;
; 670  :                 return time_point(duration(_Ctr * _Multiplier));

	imul	rax, r9, 100				; 00000064H

; 685  :             }
; 686  :         }

	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@now:

; 671  :             } else if (_Freq == _TwentyFourMHz) {

	cmp	rdi, 24000000				; 016e3600H
	jne	SHORT $LN4@now

; 672  :                 // 24 MHz is a common frequency on ARM/ARM64, including cases where it emulates x86/x64.
; 673  :                 const long long _Whole = (_Ctr / _TwentyFourMHz) * period::den;

	mov	r10, -5551535331153507085		; b2f4fc0794908cf3H
	mov	rax, r10
	imul	r9

; 674  :                 const long long _Part  = (_Ctr % _TwentyFourMHz) * period::den / _TwentyFourMHz;

	mov	rax, r10
	lea	r8, QWORD PTR [r9+rdx]
	sar	r8, 24
	mov	rcx, r8
	shr	rcx, 63					; 0000003fH
	add	r8, rcx
	imul	rcx, r8, 24000000			; 016e3600H
	sub	r9, rcx
	imul	rcx, r9, 1000000000			; 3b9aca00H
	imul	rcx
	add	rdx, rcx
	sar	rdx, 24
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	imul	rax, r8, 1000000000			; 3b9aca00H

; 675  :                 return time_point(duration(_Whole + _Part));

	add	rdx, rax

; 685  :             }
; 686  :         }

	mov	rax, rbx

; 213  :             : _MyDur(_Other) {}

	mov	QWORD PTR [rbx], rdx

; 685  :             }
; 686  :         }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@now:

; 676  :             } else {
; 677  :                 // Instead of just having "(_Ctr * period::den) / _Freq",
; 678  :                 // the algorithm below prevents overflow when _Ctr is sufficiently large.
; 679  :                 // It assumes that _Freq * period::den does not overflow, which is currently true for nano period.
; 680  :                 // It is not realistic for _Ctr to accumulate to large values from zero with this assumption,
; 681  :                 // but the initial value of _Ctr could be large.
; 682  :                 const long long _Whole = (_Ctr / _Freq) * period::den;
; 683  :                 const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

	cdq
	idiv	rdi
	mov	rcx, rax
	imul	rax, rdx, 1000000000			; 3b9aca00H
	imul	rcx, rcx, 1000000000			; 3b9aca00H
	cdq
	idiv	rdi

; 684  :                 return time_point(duration(_Whole + _Part));

	add	rax, rcx

; 685  :             }
; 686  :         }

	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\ios
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
;	COMDAT ?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
$T21 = 48
start$ = 48
_UFirst$59 = 48
$T40 = 48
i$60 = 64
$T16 = 80
size$61 = 80
end$ = 80
$T41 = 80
e$62 = 96
content$ = 104
doc$63 = 136
file$ = 160
__$ArrayPad$ = 432
filename$ = 528
iterations$ = 536
?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; benchmarkFile, COMDAT

; 7    : void benchmarkFile(const std::string& filename, int iterations = 10000) {

$LN246:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 496				; 000001f0H
	vmovaps	XMMWORD PTR [rax-40], xmm6
	vmovaps	XMMWORD PTR [rax-56], xmm8
	vmovaps	XMMWORD PTR [rax-72], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movsxd	rsi, edx
	mov	rdi, rcx

; 8    :     std::cout << "Benchmarking " << filename << " with " << iterations << " iterations..." << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0O@GIEEEDME@Benchmarking?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdi+24], 15
	jbe	SHORT $LN237@benchmarkF

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN237@benchmarkF:

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	r8, QWORD PTR [rdi+16]
	mov	rcx, rax
	call	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 8    :     std::cout << "Benchmarking " << filename << " with " << iterations << " iterations..." << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_06BIDGLIKJ@?5with?5@
	mov	rcx, rax
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, esi
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0P@DKBFGACC@?5iterations?4?4?4@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	xor	edx, edx
	mov	r8d, 272				; 00000110H
	lea	rcx, QWORD PTR file$[rsp]
	call	memset
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdi+24], 15
	jbe	SHORT $LN238@benchmarkF

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN238@benchmarkF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 42   :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

	lea	rcx, QWORD PTR file$[rsp]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	rax, QWORD PTR file$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	r15, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR file$[rsp+rcx], r15
	mov	rax, QWORD PTR file$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR file$[rsp+rcx-4], edx
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 12   :     if (!file.is_open()) {

	cmp	QWORD PTR file$[rsp+144], 0
	jne	SHORT $LN5@benchmarkF

; 13   :         std::cout << "Failed to open " << filename << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0BA@IMHBNKKK@Failed?5to?5open?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	r8, QWORD PTR [rdi+16]

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdi+24], 15
	jbe	SHORT $LN149@benchmarkF

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN149@benchmarkF:

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	rdx, rdi
	mov	rcx, rax
	call	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 13   :         std::cout << "Failed to open " << filename << std::endl;

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	npad	1

; 14   :         return;

	lea	rcx, QWORD PTR file$[rsp]
	call	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	jmp	$LN81@benchmarkF
$LN5@benchmarkF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 376  :     constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}

	mov	QWORD PTR $T16[rsp], 0
	mov	WORD PTR $T16[rsp+8], 1

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

	mov	rax, QWORD PTR file$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\ios

; 78   :         return _Mystrbuf;

	mov	rcx, QWORD PTR file$[rsp+rcx+72]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

	mov	QWORD PTR $T21[rsp], rcx
	test	rcx, rcx
	sete	BYTE PTR $T21[rsp+8]
	mov	BYTE PTR $T21[rsp+9], 0
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR content$[rsp], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR content$[rsp+16], xmm1

; 801  :         auto _UFirst = _STD _Get_unwrapped(_First);

	vmovups	xmm0, XMMWORD PTR $T21[rsp]
	vmovups	XMMWORD PTR _UFirst$59[rsp], xmm0

; 802  :         auto _ULast  = _STD _Get_unwrapped(_Last);

	vmovups	xmm6, XMMWORD PTR $T16[rsp]
	test	rcx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

	je	SHORT $LN241@benchmarkF

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN202@benchmarkF

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR _UFirst$59[rsp+9], al
	mov	rax, QWORD PTR _UFirst$59[rsp]

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR _UFirst$59[rsp+8], 1

; 437  :         if (!_Got) {

	vmovups	xmm0, XMMWORD PTR _UFirst$59[rsp]
	jmp	SHORT $LN193@benchmarkF
$LN202@benchmarkF:

; 471  :             _Strbuf = nullptr;

	xor	eax, eax
	mov	QWORD PTR _UFirst$59[rsp], rax

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR _UFirst$59[rsp+8], 1

; 437  :         if (!_Got) {

	vmovups	xmm0, XMMWORD PTR _UFirst$59[rsp]
	jmp	SHORT $LN193@benchmarkF
$LN241@benchmarkF:
	vmovq	rax, xmm0
$LN193@benchmarkF:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	test	rax, rax
	vmovq	rax, xmm6
	jne	$LN234@benchmarkF
	test	rax, rax
	je	$LN236@benchmarkF
$LN167@benchmarkF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 814  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));

	vmovdqa	XMMWORD PTR $T40[rsp], xmm6
	vmovdqa	XMMWORD PTR $T41[rsp], xmm0
	lea	r8, QWORD PTR $T40[rsp]
	lea	rdx, QWORD PTR $T41[rsp]
	lea	rcx, QWORD PTR content$[rsp]
	call	??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>
	npad	1
$LN168@benchmarkF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 162  :         if (!_Filebuffer.close()) {

	lea	rcx, QWORD PTR file$[rsp+16]
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
	test	rax, rax
	jne	SHORT $LN224@benchmarkF

; 163  :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR file$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR file$[rsp]
	add	rcx, rax
	xor	r8d, r8d
	mov	edx, 2
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN224@benchmarkF:
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 20   :     std::cout << "File size: " << content.size() << " bytes" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0M@KFCNOOOB@File?5size?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rdx, QWORD PTR content$[rsp+16]
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_K@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_06LCIDCBMH@?5bytes@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 21   :     
; 22   :     // Benchmark parsing
; 23   :     auto start = std::chrono::high_resolution_clock::now();

	lea	rcx, QWORD PTR start$[rsp]
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 24   :     
; 25   :     for (int i = 0; i < iterations; ++i) {

	xor	ebx, ebx
$LN243@benchmarkF:
	mov	DWORD PTR i$60[rsp], ebx
	cmp	ebx, esi
	jge	$LN3@benchmarkF
	vpxor	xmm0, xmm0, xmm0
	xor	eax, eax
	vmovups	XMMWORD PTR doc$63[rsp], xmm0
	mov	QWORD PTR doc$63[rsp+16], rax

; 26   :         try {
; 27   :             auto doc = Json::Parser::parseFile(filename);

	mov	rdx, rdi
	lea	rcx, QWORD PTR doc$63[rsp]
	call	?parseFile@Parser@Json@@SA?AVDocument@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Parser::parseFile
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 1915 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR doc$63[rsp+8]
	sub	rax, QWORD PTR doc$63[rsp]
	sar	rax, 3
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 29   :             volatile size_t size = doc.roots().size();

	mov	QWORD PTR size$61[rsp], rax

; 30   :             (void)size;

	mov	rax, QWORD PTR size$61[rsp]
	lea	rcx, QWORD PTR doc$63[rsp]
	call	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
	npad	1

; 24   :     
; 25   :     for (int i = 0; i < iterations; ++i) {

	inc	ebx
	jmp	SHORT $LN243@benchmarkF
$LN234@benchmarkF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	test	rax, rax
	je	$LN167@benchmarkF
$LN236@benchmarkF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR content$[rsp+16], xmm0

; 861  :         _My_data._Myres  = _Small_string_capacity;
; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR content$[rsp], 0

; 805  :         } else {

	jmp	$LN168@benchmarkF
$LN14@benchmarkF:
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 33   :             return;

	lea	rcx, QWORD PTR content$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR file$[rsp]
	call	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	jmp	$LN81@benchmarkF
$LN3@benchmarkF:

; 34   :         }
; 35   :     }
; 36   :     
; 37   :     auto end = std::chrono::high_resolution_clock::now();

	lea	rcx, QWORD PTR end$[rsp]
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp

; 300  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	rcx, QWORD PTR end$[rsp]
	sub	rcx, QWORD PTR start$[rsp]

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	rax, 4835703278458516699		; 431bde82d7b634dbH
	imul	rcx
	mov	rbx, rdx
	sar	rbx, 18
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax
	vxorps	xmm9, xmm9, xmm9
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 40   :     double avgTime = static_cast<double>(duration.count()) / iterations;

	vcvtsi2sd xmm9, xmm9, esi
	vxorps	xmm8, xmm8, xmm8
	vcvtsi2sd xmm8, xmm8, rbx

; 41   :     double throughput = (content.size() * iterations) / (1024.0 * 1024.0) / (duration.count() / 1000.0);

	mov	rcx, rsi
	imul	rcx, QWORD PTR content$[rsp+16]
	vxorps	xmm0, xmm0, xmm0
	test	rcx, rcx
	js	SHORT $LN239@benchmarkF
	vcvtsi2sd xmm0, xmm0, rcx
	jmp	SHORT $LN240@benchmarkF
$LN239@benchmarkF:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	vcvtsi2sd xmm0, xmm0, rax
	vaddsd	xmm0, xmm0, xmm0
$LN240@benchmarkF:
	vmulsd	xmm1, xmm0, QWORD PTR __real@3eb0000000000000
	vdivsd	xmm0, xmm8, QWORD PTR __real@408f400000000000
	vdivsd	xmm6, xmm1, xmm0

; 42   :     
; 43   :     std::cout << "Total time: " << duration.count() << " ms" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0N@LGHPBDLJ@Total?5time?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rdx, rbx
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_J@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_03DKJEPNJL@?5ms@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 44   :     std::cout << "Average time per parse: " << avgTime << " ms" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0BJ@DGPEJFHC@Average?5time?5per?5parse?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 40   :     double avgTime = static_cast<double>(duration.count()) / iterations;

	vdivsd	xmm1, xmm8, xmm9

; 44   :     std::cout << "Average time per parse: " << avgTime << " ms" << std::endl;

	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_03DKJEPNJL@?5ms@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 45   :     std::cout << "Throughput: " << throughput << " MB/s" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0N@CLDCHGEI@Throughput?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	vmovaps	xmm1, xmm6
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_05OPOMHMMM@?5MB?1s@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 46   :     std::cout << "Parses per second: " << (iterations * 1000.0 / duration.count()) << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0BE@CEEEFPFP@Parses?5per?5second?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	vmulsd	xmm0, xmm9, QWORD PTR __real@408f400000000000
	vdivsd	xmm1, xmm0, xmm8
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 47   :     std::cout << std::endl;

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR content$[rsp+24]
	cmp	rdx, 15
	jbe	SHORT $LN65@benchmarkF

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR content$[rsp]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN73@benchmarkF

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN73@benchmarkF
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN73@benchmarkF:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN65@benchmarkF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR content$[rsp+16], xmm0

; 3091 :         _My_data._Myres  = _Small_string_capacity;
; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR content$[rsp], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

	mov	rax, QWORD PTR file$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR file$[rsp+rcx], r15
	mov	rax, QWORD PTR file$[rsp]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR file$[rsp+rcx-4], edx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 175  :     __CLR_OR_THIS_CALL ~basic_filebuf() noexcept override {

	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR file$[rsp+16], rax

; 176  :         if (_Myfile) {

	cmp	QWORD PTR file$[rsp+144], 0
	je	SHORT $LN105@benchmarkF

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rcx, QWORD PTR file$[rsp+128]
	mov	rax, QWORD PTR file$[rsp+40]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN105@benchmarkF

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR file$[rsp+160]
	mov	rcx, QWORD PTR file$[rsp+152]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [rax], rcx

; 208  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR file$[rsp+72]
	mov	QWORD PTR [rax], rcx

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR file$[rsp+96]
	mov	DWORD PTR [rax], edx
$LN105@benchmarkF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 180  :         if (_Closef) {

	cmp	BYTE PTR file$[rsp+140], 0
	je	SHORT $LN90@benchmarkF

; 181  :             close();

	lea	rcx, QWORD PTR file$[rsp+16]
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN90@benchmarkF:

; 182  :         }
; 183  :     }

	lea	rcx, QWORD PTR file$[rsp+16]
	call	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

	lea	rcx, QWORD PTR file$[rsp+24]
	call	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	lea	rcx, QWORD PTR file$[rsp+176]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN81@benchmarkF:
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 48   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+496]
	mov	rbx, QWORD PTR [r11+48]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm8, XMMWORD PTR [r11-32]
	vmovaps	xmm9, XMMWORD PTR [r11-48]
	mov	rsp, r11
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
$LN242@benchmarkF:
?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; benchmarkFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T21 = 48
start$ = 48
_UFirst$59 = 48
$T40 = 48
i$60 = 64
$T16 = 80
size$61 = 80
end$ = 80
$T41 = 80
e$62 = 96
content$ = 104
doc$63 = 136
file$ = 160
__$ArrayPad$ = 432
filename$ = 528
iterations$ = 536
?dtor$0@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA PROC ; `benchmarkFile'::`1'::dtor$0
	lea	rcx, QWORD PTR file$[rdx]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$0@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA ENDP ; `benchmarkFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T21 = 48
start$ = 48
_UFirst$59 = 48
$T40 = 48
i$60 = 64
$T16 = 80
size$61 = 80
end$ = 80
$T41 = 80
e$62 = 96
content$ = 104
doc$63 = 136
file$ = 160
__$ArrayPad$ = 432
filename$ = 528
iterations$ = 536
?dtor$1@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA PROC ; `benchmarkFile'::`1'::dtor$1
	lea	rcx, QWORD PTR content$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA ENDP ; `benchmarkFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T21 = 48
start$ = 48
_UFirst$59 = 48
$T40 = 48
i$60 = 64
$T16 = 80
size$61 = 80
end$ = 80
$T41 = 80
e$62 = 96
content$ = 104
doc$63 = 136
file$ = 160
__$ArrayPad$ = 432
filename$ = 528
iterations$ = 536
?catch$13@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA PROC ; `benchmarkFile'::`1'::catch$13

; 31   :         } catch (const std::exception& e) {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 56					; 00000038H
	mov	rbp, rdx
__catch$?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z$0:

; 32   :             std::cout << "Parse error on iteration " << i << ": " << e.what() << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0BK@CGECCDED@Parse?5error?5on?5iteration?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, DWORD PTR i$60[rbp]
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rbx, rax
	mov	rcx, QWORD PTR e$62[rbp]
	mov	rdx, QWORD PTR [rcx]
	call	QWORD PTR [rdx+8]
	mov	rdx, rax
	mov	rcx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	npad	1

; 33   :             return;

	mov	rax, 0
	add	rsp, 56					; 00000038H
	pop	rbp
	pop	rbx
	ret	0
	int	3
?catch$13@?0??benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z@4HA ENDP ; `benchmarkFile'::`1'::catch$13
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN32:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rdi, QWORD PTR [rcx+176]

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

	mov	rax, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rdx+rdi-176], rax
	mov	rax, QWORD PTR [rcx]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR [rcx+rdi-180], edx
	lea	rbx, QWORD PTR [rdi-160]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 175  :     __CLR_OR_THIS_CALL ~basic_filebuf() noexcept override {

	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rbx], rax

; 176  :         if (_Myfile) {

	cmp	QWORD PTR [rbx+128], 0
	je	SHORT $LN26@vbase
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	rcx, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rbx+112]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN26@vbase

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	r8, QWORD PTR [rbx+144]
	mov	rdx, QWORD PTR [rbx+136]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [rcx], rdx

; 208  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rdx

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	r8d, edx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], r8d
$LN26@vbase:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 180  :         if (_Closef) {

	cmp	BYTE PTR [rbx+124], 0
	je	SHORT $LN11@vbase

; 181  :             close();

	mov	rcx, rbx
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN11@vbase:

; 182  :         }
; 183  :     }

	mov	rcx, rbx
	call	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

	lea	rcx, QWORD PTR [rdi-152]
	call	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	mov	rcx, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	rex_jmp	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
	xor	edx, edx
	mov	r8d, 272				; 00000110H
	jmp	memset
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@Document@Json@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@Document@Json@@QEAAX_K@Z PROC		; Json::Document::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	xor	eax, eax
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@Document@Json@@QEAAX_K@Z ENDP		; Json::Document::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
;	COMDAT ?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z
_TEXT	SEGMENT
size$27 = 32
start$ = 40
e$28 = 48
doc$29 = 56
__$ArrayPad$ = 80
json$ = 160
name$ = 168
iterations$ = 176
?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z PROC ; benchmarkString, COMDAT

; 50   : void benchmarkString(const std::string& json, const std::string& name, int iterations = 100000) {

$LN88:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 128				; 00000080H
	vmovaps	XMMWORD PTR [rsp+112], xmm6
	vmovaps	XMMWORD PTR [rsp+96], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	edi, r8d
	mov	rbx, rdx
	mov	rsi, rcx

; 51   :     std::cout << "Benchmarking " << name << " with " << iterations << " iterations..." << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0O@GIEEEDME@Benchmarking?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	r8, QWORD PTR [rbx+16]

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+24], 15
	jbe	SHORT $LN18@benchmarkS

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN18@benchmarkS:

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	rdx, rbx
	mov	rcx, rax
	call	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 51   :     std::cout << "Benchmarking " << name << " with " << iterations << " iterations..." << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_06BIDGLIKJ@?5with?5@
	mov	rcx, rax
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, edi
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0P@DKBFGACC@?5iterations?4?4?4@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 52   :     
; 53   :     auto start = std::chrono::high_resolution_clock::now();

	lea	rcx, QWORD PTR start$[rsp]
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 54   :     
; 55   :     for (int i = 0; i < iterations; ++i) {

	xor	ebx, ebx
$LL4@benchmarkS:
	cmp	ebx, edi
	jge	SHORT $LN3@benchmarkS
	vpxor	xmm0, xmm0, xmm0
	xor	eax, eax
	vmovups	XMMWORD PTR doc$29[rsp], xmm0
	mov	QWORD PTR doc$29[rsp+16], rax

; 56   :         try {
; 57   :             auto doc = Json::Parser::parse(json);

	mov	rdx, rsi
	lea	rcx, QWORD PTR doc$29[rsp]
	call	??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 1915 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR doc$29[rsp+8]
	sub	rax, QWORD PTR doc$29[rsp]
	sar	rax, 3
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 58   :             volatile size_t size = doc.roots().size();

	mov	QWORD PTR size$27[rsp], rax

; 59   :             (void)size;

	mov	rax, QWORD PTR size$27[rsp]
	lea	rcx, QWORD PTR doc$29[rsp]
	call	??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
	npad	1

; 54   :     
; 55   :     for (int i = 0; i < iterations; ++i) {

	inc	ebx
	jmp	SHORT $LL4@benchmarkS
$LN11@benchmarkS:

; 60   :         } catch (const std::exception& e) {
; 61   :             std::cout << "Parse error: " << e.what() << std::endl;
; 62   :             return;

	jmp	$LN1@benchmarkS
$LN3@benchmarkS:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp

; 657  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 658  :             const long long _Ctr  = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter
	mov	r9, rax

; 659  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 660  :             // The compiler recognizes the constants for frequency and time period and uses shifts and
; 661  :             // multiplies instead of divides to calculate the nanosecond value.
; 662  :             constexpr long long _TenMHz        = 10'000'000;
; 663  :             constexpr long long _TwentyFourMHz = 24'000'000;
; 664  :             if (_Freq == _TenMHz) {

	cmp	rbx, 10000000				; 00989680H
	jne	SHORT $LN36@benchmarkS

; 665  :                 // 10 MHz is a very common QPC frequency on modern x86/x64 PCs. Optimizing for
; 666  :                 // this specific frequency can double the performance of this function by
; 667  :                 // avoiding the expensive frequency conversion path.
; 668  :                 static_assert(period::den % _TenMHz == 0, "It should never fail.");
; 669  :                 constexpr long long _Multiplier = period::den / _TenMHz;
; 670  :                 return time_point(duration(_Ctr * _Multiplier));

	imul	rdx, r9, 100				; 00000064H
	jmp	SHORT $LN39@benchmarkS
$LN36@benchmarkS:

; 671  :             } else if (_Freq == _TwentyFourMHz) {

	cmp	rbx, 24000000				; 016e3600H
	jne	SHORT $LN38@benchmarkS

; 672  :                 // 24 MHz is a common frequency on ARM/ARM64, including cases where it emulates x86/x64.
; 673  :                 const long long _Whole = (_Ctr / _TwentyFourMHz) * period::den;

	mov	r10, -5551535331153507085		; b2f4fc0794908cf3H
	mov	rax, r10
	imul	r9
	lea	r8, QWORD PTR [r9+rdx]
	sar	r8, 24
	mov	rcx, r8
	shr	rcx, 63					; 0000003fH
	add	r8, rcx
	imul	rcx, r8, 24000000			; 016e3600H

; 674  :                 const long long _Part  = (_Ctr % _TwentyFourMHz) * period::den / _TwentyFourMHz;

	sub	r9, rcx
	imul	rcx, r9, 1000000000			; 3b9aca00H
	mov	rax, r10
	imul	rcx
	add	rdx, rcx
	sar	rdx, 24
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 672  :                 // 24 MHz is a common frequency on ARM/ARM64, including cases where it emulates x86/x64.
; 673  :                 const long long _Whole = (_Ctr / _TwentyFourMHz) * period::den;

	imul	rax, r8, 1000000000			; 3b9aca00H

; 675  :                 return time_point(duration(_Whole + _Part));

	jmp	SHORT $LN85@benchmarkS
$LN38@benchmarkS:

; 683  :                 const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

	cdq
	idiv	rbx
	mov	rcx, rax
	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx
	mov	rdx, rax

; 676  :             } else {
; 677  :                 // Instead of just having "(_Ctr * period::den) / _Freq",
; 678  :                 // the algorithm below prevents overflow when _Ctr is sufficiently large.
; 679  :                 // It assumes that _Freq * period::den does not overflow, which is currently true for nano period.
; 680  :                 // It is not realistic for _Ctr to accumulate to large values from zero with this assumption,
; 681  :                 // but the initial value of _Ctr could be large.
; 682  :                 const long long _Whole = (_Ctr / _Freq) * period::den;

	imul	rax, rcx, 1000000000			; 3b9aca00H
$LN85@benchmarkS:

; 221  :             return _MyDur;

	add	rdx, rax
$LN39@benchmarkS:
	sub	rdx, QWORD PTR start$[rsp]

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	rax, 2361183241434822607		; 20c49ba5e353f7cfH
	imul	rdx
	mov	rbx, rdx
	sar	rbx, 7
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 71   :     std::cout << "Total time: " << duration.count() << " s" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0N@LGHPBDLJ@Total?5time?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rdx, rbx
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_J@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_04KGNIJDJC@?5?N?$LMs@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 72   :     std::cout << "Average time per parse: " << avgTime << " s" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0BJ@DGPEJFHC@Average?5time?5per?5parse?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	vxorps	xmm6, xmm6, xmm6

; 63   :         }
; 64   :     }
; 65   :     
; 66   :     auto end = std::chrono::high_resolution_clock::now();
; 67   :     auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
; 68   :     
; 69   :     double avgTime = static_cast<double>(duration.count()) / iterations;

	vcvtsi2sd xmm6, xmm6, edi
	vxorps	xmm7, xmm7, xmm7
	vcvtsi2sd xmm7, xmm7, rbx
	vdivsd	xmm1, xmm7, xmm6

; 72   :     std::cout << "Average time per parse: " << avgTime << " s" << std::endl;

	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_04KGNIJDJC@?5?N?$LMs@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 73   :     std::cout << "Parses per second: " << (iterations * 1000000.0 / duration.count()) << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0BE@CEEEFPFP@Parses?5per?5second?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	vmulsd	xmm0, xmm6, QWORD PTR __real@412e848000000000
	vdivsd	xmm1, xmm0, xmm7
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 74   :     std::cout << std::endl;

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
$LN1@benchmarkS:

; 75   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	vmovaps	xmm6, XMMWORD PTR [rsp+112]
	vmovaps	xmm7, XMMWORD PTR [rsp+96]
	add	rsp, 128				; 00000080H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z ENDP ; benchmarkString
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
size$27 = 32
start$ = 40
e$28 = 48
doc$29 = 56
__$ArrayPad$ = 80
json$ = 160
name$ = 168
iterations$ = 176
?catch$2@?0??benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z@4HA PROC ; `benchmarkString'::`1'::catch$2

; 60   :         } catch (const std::exception& e) {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z$0:

; 61   :             std::cout << "Parse error: " << e.what() << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0O@DJOCHAI@Parse?5error?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rbx, rax
	mov	rcx, QWORD PTR e$28[rbp]
	mov	rdx, QWORD PTR [rcx]
	call	QWORD PTR [rdx+8]
	mov	rdx, rax
	mov	rcx, rbx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	npad	1

; 62   :             return;

	mov	rax, 0
	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
	int	3
?catch$2@?0??benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z@4HA ENDP ; `benchmarkString'::`1'::catch$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp
;	COMDAT main
_TEXT	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main	PROC						; COMDAT

; 77   : int main() {

$LN619:
	push	rbp
	mov	rbp, rsp
	sub	rsp, 112				; 00000070H

; 78   :     std::cout << "=== JSON Parser Benchmark ===" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0BO@OECEGPPP@?$DN?$DN?$DN?5JSON?5Parser?5Benchmark?5?$DN?$DN?$DN@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T1[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T1[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 15
	lea	rdx, OFFSET FLAT:??_C@_0BA@DPKMFFGL@tests?1test?4json@
	lea	rcx, QWORD PTR $T1[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 81   :     benchmarkFile("tests/test.json", 5000);

	mov	edx, 5000				; 00001388H
	lea	rcx, QWORD PTR $T1[rbp-112]
	call	?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; benchmarkFile
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T1[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN51@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T1[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN59@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN59@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN59@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN51@main:
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T7[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T7[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 26
	lea	rdx, OFFSET FLAT:??_C@_0BL@OLMDAAM@tests?1test_edge_cases?4json@
	lea	rcx, QWORD PTR $T7[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 82   :     benchmarkFile("tests/test_edge_cases.json", 3000);

	mov	edx, 3000				; 00000bb8H
	lea	rcx, QWORD PTR $T7[rbp-112]
	call	?benchmarkFile@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; benchmarkFile
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T7[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN102@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T7[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN110@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN110@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN110@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN102@main:
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T13[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T13[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 13
	lea	rdx, OFFSET FLAT:??_C@_0O@LLNAIOEN@simple?5object@
	lea	rcx, QWORD PTR $T13[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T17[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T17[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 16
	lea	rdx, OFFSET FLAT:??_C@_0BB@KHKLOMNG@?$HL?$CCkey?$CC?3?5?$CCvalue?$CC?$HN@
	lea	rcx, QWORD PTR $T17[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 85   :     benchmarkString("{\"key\": \"value\"}", "simple object", 50000);

	mov	r8d, 50000				; 0000c350H
	lea	rdx, QWORD PTR $T13[rbp-112]
	lea	rcx, QWORD PTR $T17[rbp-112]
	call	?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z ; benchmarkString
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T17[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN170@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T17[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN178@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN178@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN178@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN170@main:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR $T17[rbp-96], xmm0

; 3091 :         _My_data._Myres  = _Small_string_capacity;
; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T17[rbp-112], 0

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T13[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN202@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T13[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN210@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN210@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN210@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN202@main:
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T25[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T25[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 12
	lea	rdx, OFFSET FLAT:??_C@_0N@PEMCCABF@simple?5array@
	lea	rcx, QWORD PTR $T25[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T29[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T29[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 15
	lea	rdx, OFFSET FLAT:??_C@_0BA@PLDJKHGB@?$FL1?0?52?0?53?0?54?0?55?$FN@
	lea	rcx, QWORD PTR $T29[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 86   :     benchmarkString("[1, 2, 3, 4, 5]", "simple array", 50000);

	mov	r8d, 50000				; 0000c350H
	lea	rdx, QWORD PTR $T25[rbp-112]
	lea	rcx, QWORD PTR $T29[rbp-112]
	call	?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z ; benchmarkString
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T29[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN270@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T29[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN278@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN278@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN278@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN270@main:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR $T29[rbp-96], xmm0

; 3091 :         _My_data._Myres  = _Small_string_capacity;
; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T29[rbp-112], 0

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T25[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN302@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T25[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN310@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN310@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN310@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN302@main:
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T37[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T37[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:??_C@_06EBGNBFIA@number@
	lea	rcx, QWORD PTR $T37[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T41[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T41[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:??_C@_07GNGCELP@42?45e10@
	lea	rcx, QWORD PTR $T41[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 87   :     benchmarkString("42.5e10", "number", 100000);

	mov	r8d, 100000				; 000186a0H
	lea	rdx, QWORD PTR $T37[rbp-112]
	lea	rcx, QWORD PTR $T41[rbp-112]
	call	?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z ; benchmarkString
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T41[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN370@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T41[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN378@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN378@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN378@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN370@main:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR $T41[rbp-96], xmm0

; 3091 :         _My_data._Myres  = _Small_string_capacity;
; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T41[rbp-112], 0

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T37[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN402@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T37[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN410@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN410@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN410@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN402@main:
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T49[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T49[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:??_C@_06ICGJLFIM@string@
	lea	rcx, QWORD PTR $T49[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T53[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T53[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 13
	lea	rdx, OFFSET FLAT:??_C@_0O@MHBFGJKG@?$CChello?5world?$CC@
	lea	rcx, QWORD PTR $T53[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 88   :     benchmarkString("\"hello world\"", "string", 100000);

	mov	r8d, 100000				; 000186a0H
	lea	rdx, QWORD PTR $T49[rbp-112]
	lea	rcx, QWORD PTR $T53[rbp-112]
	call	?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z ; benchmarkString
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T53[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN470@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T53[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN478@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN478@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN478@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN470@main:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR $T53[rbp-96], xmm0

; 3091 :         _My_data._Myres  = _Small_string_capacity;
; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T53[rbp-112], 0

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T49[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN502@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T49[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN510@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN510@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN510@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN502@main:
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T61[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T61[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 14
	lea	rdx, OFFSET FLAT:??_C@_0P@PFMECINC@complex?5object@
	lea	rcx, QWORD PTR $T61[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR $T65[rbp-112], xmm0
	vpxor	xmm1, xmm1, xmm1

; 517  :     size_type _Mysize = 0; // current length of string (size)

	vmovdqu	XMMWORD PTR $T65[rbp-96], xmm1

; 769  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0LM@GKIIEDNC@?$HL?6?5?5?5?5?5?5?5?5?$CCname?$CC?3?5?$CCJohn?$CC?0?6?5?5?5?5?5@
	lea	rcx, QWORD PTR $T65[rbp-112]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 91   :     benchmarkString(R"({

	mov	r8d, 20000				; 00004e20H
	lea	rdx, QWORD PTR $T61[rbp-112]
	lea	rcx, QWORD PTR $T65[rbp-112]
	call	?benchmarkString@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H@Z ; benchmarkString
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T65[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN570@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T65[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN578@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN578@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN578@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN570@main:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR $T65[rbp-96], xmm0

; 3091 :         _My_data._Myres  = _Small_string_capacity;
; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T65[rbp-112], 0

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR $T61[rbp-88]
	cmp	rdx, 15
	jbe	SHORT $LN602@main

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T61[rbp-112]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN610@main

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN610@main
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN610@main:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN602@main:
; File E:\unik\C_code\libraries\JsonParser\tests\benchmark.cpp

; 101  :     std::cout << "Benchmark complete!" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0BE@HCHBDOOD@Benchmark?5complete?$CB@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 102  :     return 0;

	xor	eax, eax

; 103  : }

	add	rsp, 112				; 00000070H
	pop	rbp
	ret	0
$LN616@main:
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$0 PROC
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$1 PROC
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$2 PROC
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$3 PROC
	lea	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$3 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$4 PROC
	lea	rcx, QWORD PTR $T25[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$4 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$5 PROC
	lea	rcx, QWORD PTR $T29[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$5 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$6 PROC
	lea	rcx, QWORD PTR $T37[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$6 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$7 PROC
	lea	rcx, QWORD PTR $T41[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$7 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$8 PROC
	lea	rcx, QWORD PTR $T49[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$8 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$9 PROC
	lea	rcx, QWORD PTR $T53[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$9 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$10 PROC
	lea	rcx, QWORD PTR $T61[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$10 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T7 = 48
$T17 = 48
$T29 = 48
$T41 = 48
$T53 = 48
$T65 = 48
$T13 = 80
$T25 = 80
$T37 = 80
$T49 = 80
$T61 = 80
main$dtor$11 PROC
	lea	rcx, QWORD PTR $T65[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$11 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
;	COMDAT ??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 56
_Buff$ = 64
__$ArrayPad$ = 88
__$ReturnUdt$ = 128
_Val$ = 136
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z PROC ; std::_Integral_to_string<char,int>, COMDAT

; 441  : _NODISCARD basic_string<_Elem> _Integral_to_string(const _Ty _Val) {

$LN146:
	push	rbx
	push	rdi
	push	r14
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	xor	r14d, r14d
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 442  :     // convert _Val to string
; 443  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 444  :     _Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 445  :     _Elem* const _Buff_end = _STD end(_Buff);
; 446  :     _Elem* _RNext          = _Buff_end;
; 447  : 
; 448  :     if constexpr (is_signed_v<_Ty>) {
; 449  :         const auto _UVal = static_cast<make_unsigned_t<_Ty>>(_Val);
; 450  :         if (_Val < 0) {

	lea	rdi, QWORD PTR _Buff$[rsp+21]
	mov	r8d, edx
	mov	rbx, rcx
	test	edx, edx
	jns	SHORT $LL15@Integral_t
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 2759 :     auto _UVal_trunc = _UVal;

	neg	r8d
$LL10@Integral_t:

; 2779 :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	rdi
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [rdi], r8b

; 2780 :         _UVal_trunc /= 10;

	mov	r8d, edx

; 2781 :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL10@Integral_t
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 452  :             *--_RNext = '-';

	dec	rdi
	mov	BYTE PTR [rdi], 45			; 0000002dH

; 453  :         } else {

	jmp	SHORT $LN3@Integral_t
	npad	12
$LL15@Integral_t:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 2779 :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	rdi
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [rdi], r8b

; 2780 :         _UVal_trunc /= 10;

	mov	r8d, edx

; 2781 :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL15@Integral_t
$LN3@Integral_t:
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rbx], xmm0

; 803  :         if (_UFirst == _ULast) {

	lea	rax, QWORD PTR _Buff$[rsp+21]
	mov	QWORD PTR [rsp+136], rbp

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rbx+16], r14

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rbx+24], r14
	mov	QWORD PTR [rsp+144], rsi

; 803  :         if (_UFirst == _ULast) {

	cmp	rdi, rax
	jne	SHORT $LN18@Integral_t

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], r14b

; 805  :         } else {

	jmp	$LN36@Integral_t
$LN18@Integral_t:

; 806  :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 807  :                 _Construct<_Construct_strategy::_From_ptr>(

	lea	rsi, QWORD PTR _Buff$[rsp+21]

; 881  :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH

; 807  :                 _Construct<_Construct_strategy::_From_ptr>(

	sub	rsi, rdi

; 881  :         if (_Count > max_size()) {

	cmp	rsi, rbp
	ja	$LN143@Integral_t

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

	cmp	rsi, 15
	ja	SHORT $LN38@Integral_t
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 890  :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 891  :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbx
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 898  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rsi+rbx], r14b

; 899  :             } else { // _Strat == _Construct_strategy::_From_string
; 900  : #ifdef _INSERT_STRING_ANNOTATION
; 901  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 902  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 903  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 904  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 905  :             }
; 906  : 
; 907  :             _Proxy._Release();
; 908  :             return;

	jmp	$LN36@Integral_t
$LN38@Integral_t:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rsi
	or	rax, 15
	cmp	rax, rbp

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN48@Integral_t

; 2980 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN73@Integral_t:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN74@Integral_t
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], r14
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN48@Integral_t:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN65@Integral_t

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN68@Integral_t

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN144@Integral_t
	jmp	SHORT $LN73@Integral_t
$LN74@Integral_t:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	r14, QWORD PTR [rax+39]
	and	r14, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [r14-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN65@Integral_t
$LN68@Integral_t:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
$LN65@Integral_t:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rbx], r14
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 915  :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, r14
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 916  :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [r14+rsi], 0
$LN36@Integral_t:
	mov	rsi, QWORD PTR [rsp+144]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 460  :     return basic_string<_Elem>(_RNext, _Buff_end);

	mov	rax, rbx

; 461  : }

	mov	rbp, QWORD PTR [rsp+136]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	r14
	pop	rdi
	pop	rbx
	ret	0
$LN143@Integral_t:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 882  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN144@Integral_t:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN141@Integral_t:
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ENDP ; std::_Integral_to_string<char,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z
_TEXT	SEGMENT
_Array$ = 8
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z PROC		; std::end<char,21>, COMDAT

; 2032 :     return _Array + _Size;

	lea	rax, QWORD PTR [rcx+21]

; 2033 : }

	ret	0
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ENDP		; std::end<char,21>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z PROC ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>, COMDAT

; 2457 :     return __builtin_bit_cast(_To, _Val);

	mov	rax, QWORD PTR [rcx]

; 2458 : }

	ret	0
??$_Bit_cast@_KT_Addr_storage@error_category@std@@$0A@@std@@YA_KAEBT_Addr_storage@error_category@0@@Z ENDP ; std::_Bit_cast<unsigned __int64,std::error_category::_Addr_storage,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_System_error_category>, COMDAT

; 641  :     static constexpr _Ty _Static;
; 642  :     return _Static;

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@1@XZ@4V21@B ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static

; 643  : }

	ret	0
??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAAEBV_System_error_category@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_System_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }

	ret	0
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 64
_Capacity$ = 72
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 823  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN46:
	push	rbx
	sub	rsp, 48					; 00000030H

; 824  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 825  :         ++_Capacity; // Take null terminator into consideration

	mov	rcx, QWORD PTR [rdx]
	mov	rbx, rdx
	add	rcx, 1
	mov	QWORD PTR [rdx], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	jne	SHORT $LN12@Allocate_f

; 228  :         return nullptr;

	xor	eax, eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 845  :         --_Capacity;

	dec	QWORD PTR [rdx]

; 847  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN12@Allocate_f:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN14@Allocate_f

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN44@Allocate_f

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN20@Allocate_f
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN20@Allocate_f:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 845  :         --_Capacity;

	dec	QWORD PTR [rbx]

; 847  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN14@Allocate_f:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 845  :         --_Capacity;

	dec	QWORD PTR [rbx]

; 847  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN44@Allocate_f:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN42@Allocate_f:
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 69   :     return _Ptr;

	mov	rax, rcx

; 70   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 56
__$ReturnUdt$ = 112
_Left$dead$ = 120
_Right$ = 128
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3160 :     _In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

$LN133:
	push	rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 72					; 00000048H

; 3161 :     using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
; 3162 :     const auto _Left_size  = _Convert_size<_Size_type>(_Traits::length(_Left));
; 3163 :     const auto _Right_size = _Right.size();

	mov	r15, QWORD PTR [r8+16]
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	r12d, r12d

; 3164 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r14, r8
	mov	rax, rcx
	sub	rax, r15
	cmp	rax, 16
	jb	$LN130@operator

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [r8+24], 15
	mov	QWORD PTR [rsp+120], rbx
	mov	QWORD PTR [rsp+136], rbp
	mov	QWORD PTR [rsp+64], rdi
	jbe	SHORT $LN13@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r8]
$LN13@operator:
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rsi], xmm0

; 1056 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

	lea	rbp, QWORD PTR [r15+16]

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rsi+16], r12

; 1057 :         size_type _New_capacity = _Small_string_capacity;

	mov	edi, 15

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rsi+24], r12

; 1059 :         _Elem* _Ptr             = _My_data._Bx._Buf;

	mov	rbx, rsi

; 1060 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1061 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 1062 : 
; 1063 :         if (_New_capacity < _New_size) {

	cmp	rbp, rdi
	jbe	$LN20@operator

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rdi, rbp
	or	rdi, 15
	cmp	rdi, rcx

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN36@operator

; 2980 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rdi, rcx
	add	rax, 39					; 00000027H
$LN61@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN62@operator
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], r12
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN36@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, 22
	cmp	rdi, rax
	cmovb	rdi, rax

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rdi+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN54@operator

; 228  :         return nullptr;

	mov	rbx, r12
	jmp	SHORT $LN53@operator
$LN54@operator:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN56@operator

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN131@operator
	jmp	SHORT $LN61@operator
$LN62@operator:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN53@operator
$LN56@operator:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN53@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1067 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

	mov	QWORD PTR [rsi], rbx
$LN20@operator:

; 1068 :         }
; 1069 : 
; 1070 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR [rsi+16], rbp

; 1071 :         _My_data._Myres  = _New_capacity;
; 1072 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 1073 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

	lea	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rsi+24], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r15
	vmovups	xmm0, XMMWORD PTR ??_C@_0BB@PFCEIHCG@File?5not?5found?3?5@
	mov	rdx, r14
	vmovups	XMMWORD PTR [rbx], xmm0
	call	memcpy
	mov	rdi, QWORD PTR [rsp+64]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3168 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	rax, rsi

; 1074 :         _Traits::assign(_Ptr[_New_size], _Elem());

	mov	BYTE PTR [rbx+rbp], r12b
	mov	rbp, QWORD PTR [rsp+136]
	mov	rbx, QWORD PTR [rsp+120]

; 3169 : }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	r14
	pop	r12
	pop	rsi
	ret	0
$LN130@operator:

; 3165 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN131@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN128@operator:
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z
_TEXT	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z PROC ; Json::Parser::parse<MappedFile<0> >, COMDAT

; 581  : 		{

$LN93:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	esi, esi
	mov	DWORD PTR $T1[rsp], esi
	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rcx], xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rsi
	mov	QWORD PTR [rcx+8], rsi
	mov	QWORD PTR [rcx+16], rsi
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 582  : 			Document document;

	mov	DWORD PTR $T1[rsp], 1

; 583  : 			try {
; 584  : 				for (size_t i = 0; i < input.size();)

	mov	edx, esi
	mov	QWORD PTR i$33[rsp], rdx
	npad	6
$LL4@parse:
	cmp	rdx, QWORD PTR [rdi+8]
	jae	SHORT $LN3@parse

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >

; 585  : 				{
; 586  : 					i = skipWhitespace(input, i);

	mov	QWORD PTR i$33[rsp], rax

; 587  : 					if (i >= input.size())

	cmp	rax, QWORD PTR [rdi+8]
	jae	SHORT $LN3@parse

; 588  : 						break;
; 589  : 					document.m_roots.emplace_back(std::move(parseValue(input, i)));

	lea	r8, QWORD PTR i$33[rsp]
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseValue<MappedFile<0> >
	mov	r8, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+8]
	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN39@parse

; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rax]

; 861  :         } else {
; 862  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 863  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 864  :             _ASAN_VECTOR_RELEASE_GUARD;
; 865  :         }
; 866  : 
; 867  :         _Orphan_range(_Mylast, _Mylast);
; 868  :         _Ty& _Result = *_Mylast;
; 869  :         ++_Mylast;

	mov	QWORD PTR [r8], rsi
	mov	QWORD PTR [rdx], rax
	add	QWORD PTR [rbx+8], 8

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN38@parse
$LN39@parse:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, rbx
	call	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
	npad	1
$LN38@parse:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR $T6[rsp]
	test	rcx, rcx
	jne	SHORT $LN89@parse
	mov	rdx, QWORD PTR i$33[rsp]
	jmp	SHORT $LL4@parse
$LN89@parse:

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
	mov	rdx, QWORD PTR i$33[rsp]
	jmp	SHORT $LL4@parse
$LN3@parse:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 595  : 			return document;

	mov	rax, rbx

; 596  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
	int	3
$LN91@parse:
??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z ENDP ; Json::Parser::parse<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?dtor$0@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA PROC ; `Json::Parser::parse<MappedFile<0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1Document@Json@@QEAA@XZ
$LN11@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA ENDP ; `Json::Parser::parse<MappedFile<0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?dtor$1@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA PROC ; `Json::Parser::parse<MappedFile<0> >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
?dtor$1@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA ENDP ; `Json::Parser::parse<MappedFile<0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA PROC ; `Json::Parser::parse<MappedFile<0> >'::`1'::catch$5

; 592  : 			catch (const std::exception& e) {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$??$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z$0:

; 593  : 				throw std::runtime_error(std::string("JSON parsing failed: ") + e.what());

	mov	rcx, QWORD PTR e$32[rbp]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	mov	rbx, rax
	lea	rdx, OFFSET FLAT:??_C@_0BG@LNPEEPID@JSON?5parsing?5failed?3?5@
	lea	rcx, QWORD PTR $T29[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	r8, rbx
	mov	rdx, rax
	lea	rcx, QWORD PTR $T30[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T31[rbp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T31[rbp]
	call	_CxxThrowException
	npad	1
?catch$5@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA ENDP ; `Json::Parser::parse<MappedFile<0> >'::`1'::catch$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?dtor$2@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA PROC ; `Json::Parser::parse<MappedFile<0> >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T29[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA ENDP ; `Json::Parser::parse<MappedFile<0> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?dtor$3@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA PROC ; `Json::Parser::parse<MappedFile<0> >'::`1'::dtor$3
	lea	rcx, QWORD PTR $T30[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$parse@V?$MappedFile@$0A@@@@Parser@Json@@SA?AVDocument@1@AEAV?$MappedFile@$0A@@@@Z@4HA ENDP ; `Json::Parser::parse<MappedFile<0> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Document.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Document.h
;	COMDAT ??0Document@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Document@Json@@QEAA@XZ PROC				; Json::Document::Document, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Document.h

; 17   : 		Document() = default;

	mov	rax, rcx
	ret	0
??0Document@Json@@QEAA@XZ ENDP				; Json::Document::Document
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>, COMDAT

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1514 : }

	ret	0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 768  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

$LN139:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r12, rdx
	mov	rsi, rcx

; 769  :     // insert NTBS into char stream
; 770  :     using _Elem = char;
; 771  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 772  : 
; 773  :     ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

	mov	r14, -1
	npad	7
$LL132@operator:
	inc	r14
	cmp	BYTE PTR [rdx+r14], bl
	jne	SHORT $LL132@operator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 775  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	rax, QWORD PTR [rcx]
	movsxd	rcx, DWORD PTR [rax+4]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 278  :         return _Wide;

	mov	rdi, QWORD PTR [rcx+rsi+40]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 775  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	test	rdi, rdi
	jle	SHORT $LN17@operator
	cmp	rdi, r14
	jle	SHORT $LN17@operator
	sub	rdi, r14
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	edi, edi
$LN18@operator:

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	r15, rsi
	mov	QWORD PTR _Ok$[rsp], rsi

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rcx, QWORD PTR [rcx+rsi+72]

; 71   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN92@operator

; 72   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN92@operator:

; 91   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	jne	SHORT $LN86@operator

; 92   :                 _Ok = false;

	mov	BYTE PTR _Ok$[rsp+8], al

; 93   :                 return;

	jmp	SHORT $LN85@operator
$LN86@operator:

; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rsi+80]

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

	test	rcx, rcx
	je	SHORT $LN88@operator
	cmp	rcx, rsi
	je	SHORT $LN88@operator

; 99   :                 return;
; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	mov	BYTE PTR _Ok$[rsp+8], al
	jmp	SHORT $LN85@operator
$LN88@operator:

; 98   :                 _Ok = true;

	mov	BYTE PTR _Ok$[rsp+8], 1
	mov	al, 1
$LN85@operator:

; 776  :     const typename _Myos::sentry _Ok(_Ostr);
; 777  : 
; 778  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN8@operator

; 779  :         _State |= ios_base::badbit;

	mov	ebx, 4

; 780  :     } else { // state okay, insert

	jmp	$LN22@operator
$LN8@operator:

; 781  :         _TRY_IO_BEGIN
; 782  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	rdx, QWORD PTR [rsi]
	movsxd	rax, DWORD PTR [rdx+4]
	mov	ecx, DWORD PTR [rax+rsi+24]
	and	ecx, 448				; 000001c0H
	cmp	ecx, 64					; 00000040H
	je	SHORT $LN127@operator
$LL4@operator:

; 783  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	rdi, rdi
	jle	SHORT $LN129@operator

; 784  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN136@operator

; 783  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	rdi
	jmp	SHORT $LL4@operator
$LN129@operator:

; 785  :                     _State |= ios_base::badbit; // insertion failed, quit
; 786  :                     break;
; 787  :                 }
; 788  :             }
; 789  :         }
; 790  : 
; 791  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	mov	rdx, QWORD PTR [rsi]
$LN127@operator:
	movsxd	rcx, DWORD PTR [rdx+4]
	mov	r8, r14
	mov	rdx, r12
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	cmp	rax, r14
	jne	SHORT $LN136@operator
	npad	7
$LL7@operator:

; 792  :             _State |= ios_base::badbit;
; 793  :         }
; 794  : 
; 795  :         if (_State == ios_base::goodbit) {
; 796  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	rdi, rdi
	jle	SHORT $LN6@operator

; 797  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN136@operator

; 792  :             _State |= ios_base::badbit;
; 793  :         }
; 794  : 
; 795  :         if (_State == ios_base::goodbit) {
; 796  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	rdi
	jmp	SHORT $LL7@operator
$LN136@operator:

; 798  :                     _State |= ios_base::badbit; // insertion failed, quit
; 799  :                     break;
; 800  :                 }
; 801  :             }
; 802  :         }
; 803  : 
; 804  :         _Ostr.width(0);

	mov	ebx, 4
	mov	DWORD PTR _State$[rsp], ebx
$LN6@operator:
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

	mov	QWORD PTR [rcx+rsi+40], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
	jmp	SHORT $LN22@operator
$LN23@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase
	mov	rsi, QWORD PTR _Ostr$[rsp]
	mov	ebx, DWORD PTR _State$[rsp]
	mov	r15, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 808  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1

; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

	call	QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

	test	eax, eax
	jne	SHORT $LN25@operator

; 117  :                 this->_Myostr._Osfx();

	mov	rcx, r15
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN25@operator:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [r15]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+r15+72]

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN134@operator

; 79   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN134@operator:

; 809  :     return _Ostr;
; 810  : }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$11@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$11
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$11@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$17

; 805  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$17
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Ostr$ = 8
_Str$ = 16
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	r8, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN7@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3446 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	jmp	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1012 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1013 :     _Ostr.put(_Ostr.widen('\n'));

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	dl, 10
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
	movzx	edx, al
	mov	rcx, rbx
	call	QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 1014 :     _Ostr.flush();

	mov	rcx, rbx
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1015 :     return _Ostr;

	mov	rax, rbx

; 1016 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YA?A_TAEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YA?A_TAEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@@Z PROC ; std::_Get_unwrapped<std::istreambuf_iterator<char,std::char_traits<char> > &>, COMDAT

; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;
; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);

	mov	rax, rcx

; 1387 :     }
; 1388 : }

	ret	0
??$_Get_unwrapped@AEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YA?A_TAEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::istreambuf_iterator<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
_UFirst$ = 32
$T15 = 32
_ULast$ = 48
$T14 = 48
this$ = 128
_First$ = 136
_Last$ = 144
_Al$dead$ = 152
??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::istreambuf_iterator<char,std::char_traits<char> >,0>, COMDAT

; 799  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN72:
	push	rdi
	sub	rsp, 112				; 00000070H
	vmovaps	XMMWORD PTR [rsp+80], xmm6

; 802  :         auto _ULast  = _STD _Get_unwrapped(_Last);

	vmovups	xmm6, XMMWORD PTR [r8]
	vmovaps	XMMWORD PTR [rsp+64], xmm7
	vmovups	xmm7, XMMWORD PTR [rdx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

	vpextrb	al, xmm7, 8
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 799  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	QWORD PTR [rsp+96], rsi
	mov	rdi, rcx
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], 0

; 800  :         _STD _Adl_verify_range(_First, _Last);
; 801  :         auto _UFirst = _STD _Get_unwrapped(_First);

	vmovups	XMMWORD PTR _UFirst$[rsp], xmm7

; 802  :         auto _ULast  = _STD _Get_unwrapped(_Last);

	vmovups	XMMWORD PTR _ULast$[rsp], xmm6
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

	vmovq	rsi, xmm7
	test	al, al
	jne	SHORT $LN27@allocator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	test	rsi, rsi
	je	SHORT $LN37@allocator
	mov	rcx, rsi
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN37@allocator

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR _UFirst$[rsp+9], al
	jmp	SHORT $LN36@allocator
$LN37@allocator:

; 471  :             _Strbuf = nullptr;

	xor	esi, esi
	mov	QWORD PTR _UFirst$[rsp], rsi
$LN36@allocator:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR _UFirst$[rsp+8], 1

; 437  :         if (!_Got) {

	vmovups	xmm7, XMMWORD PTR _UFirst$[rsp]
$LN27@allocator:

; 438  :             _Peek();
; 439  :         }
; 440  : 
; 441  :         if (!_Right._Got) {

	vpextrb	al, xmm6, 8
	mov	QWORD PTR [rsp+104], rbx
	vmovq	rbx, xmm6
	test	al, al
	jne	SHORT $LN28@allocator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	test	rbx, rbx
	je	SHORT $LN48@allocator
	mov	rcx, rbx
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN48@allocator

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR _ULast$[rsp+9], al
	jmp	SHORT $LN47@allocator
$LN48@allocator:

; 471  :             _Strbuf = nullptr;

	xor	ebx, ebx
	mov	QWORD PTR _ULast$[rsp], rbx
$LN47@allocator:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR _ULast$[rsp+8], 1

; 441  :         if (!_Right._Got) {

	vmovups	xmm6, XMMWORD PTR _ULast$[rsp]
$LN28@allocator:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	test	rsi, rsi
	mov	rsi, QWORD PTR [rsp+96]
	jne	SHORT $LN58@allocator
	test	rbx, rbx
	je	SHORT $LN59@allocator
$LN2@allocator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 814  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));

	lea	r8, QWORD PTR $T14[rsp]
	mov	rcx, rdi
	lea	rdx, QWORD PTR $T15[rsp]
	vmovdqa	XMMWORD PTR $T14[rsp], xmm6
	vmovdqa	XMMWORD PTR $T15[rsp], xmm7
	call	??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>
$LN69@allocator:

; 815  :             }
; 816  :         }
; 817  :     }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rax, rdi
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	vmovaps	xmm7, XMMWORD PTR [rsp+64]
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
$LN58@allocator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	test	rbx, rbx
	je	SHORT $LN2@allocator
$LN59@allocator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0

; 803  :         if (_UFirst == _ULast) {
; 804  :             _Construct_empty();
; 805  :         } else {

	jmp	SHORT $LN69@allocator
??$?0V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@V?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><std::istreambuf_iterator<char,std::char_traits<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Left$ = 16
_Right$ = 24
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 221  :             return _MyDur;

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [r8]

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	QWORD PTR [rcx], rax

; 557  :         return _Left.time_since_epoch() - _Right.time_since_epoch();

	mov	rax, rcx

; 558  :     }

	ret	0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Dur$ = 16
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,1000000000>,0>, COMDAT

; 429  :         // convert duration to another duration; truncate
; 430  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 431  : 
; 432  :         using _ToRep = typename _To::rep;
; 433  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 434  : 
; 435  :         constexpr bool _Num_is_one = _CF::num == 1;
; 436  :         constexpr bool _Den_is_one = _CF::den == 1;
; 437  : 
; 438  :         if constexpr (_Den_is_one) {
; 439  :             if constexpr (_Num_is_one) {
; 440  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));
; 441  :             } else {
; 442  :                 return static_cast<_To>(
; 443  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 444  :             }
; 445  :         } else {
; 446  :             if constexpr (_Num_is_one) {
; 447  :                 return static_cast<_To>(

	mov	rax, 4835703278458516699		; 431bde82d7b634dbH
	imul	QWORD PTR [rdx]
	sar	rdx, 18
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	mov	rax, rcx

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	QWORD PTR [rcx], rdx

; 448  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 449  :             } else {
; 450  :                 return static_cast<_To>(static_cast<_ToRep>(
; 451  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 452  :             }
; 453  :         }
; 454  :     }

	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,1000000000>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 581  : 		{

$LN93:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	esi, esi
	mov	DWORD PTR $T1[rsp], esi
	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rcx], xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rsi
	mov	QWORD PTR [rcx+8], rsi
	mov	QWORD PTR [rcx+16], rsi
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 582  : 			Document document;

	mov	DWORD PTR $T1[rsp], 1

; 583  : 			try {
; 584  : 				for (size_t i = 0; i < input.size();)

	mov	edx, esi
	mov	QWORD PTR i$33[rsp], rdx
	npad	6
$LL4@parse:
	cmp	rdx, QWORD PTR [rdi+16]
	jae	SHORT $LN3@parse

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 585  : 				{
; 586  : 					i = skipWhitespace(input, i);

	mov	QWORD PTR i$33[rsp], rax

; 587  : 					if (i >= input.size())

	cmp	rax, QWORD PTR [rdi+16]
	jae	SHORT $LN3@parse

; 588  : 						break;
; 589  : 					document.m_roots.emplace_back(std::move(parseValue(input, i)));

	lea	r8, QWORD PTR i$33[rsp]
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
	mov	r8, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+8]
	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN39@parse

; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rax]

; 861  :         } else {
; 862  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 863  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 864  :             _ASAN_VECTOR_RELEASE_GUARD;
; 865  :         }
; 866  : 
; 867  :         _Orphan_range(_Mylast, _Mylast);
; 868  :         _Ty& _Result = *_Mylast;
; 869  :         ++_Mylast;

	mov	QWORD PTR [r8], rsi
	mov	QWORD PTR [rdx], rax
	add	QWORD PTR [rbx+8], 8

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN38@parse
$LN39@parse:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, rbx
	call	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
	npad	1
$LN38@parse:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR $T6[rsp]
	test	rcx, rcx
	jne	SHORT $LN89@parse
	mov	rdx, QWORD PTR i$33[rsp]
	jmp	SHORT $LL4@parse
$LN89@parse:

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
	mov	rdx, QWORD PTR i$33[rsp]
	jmp	SHORT $LL4@parse
$LN3@parse:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 595  : 			return document;

	mov	rax, rbx

; 596  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rdi
	ret	0
	int	3
$LN91@parse:
??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?dtor$0@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1Document@Json@@QEAA@XZ
$LN11@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?dtor$1@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
?dtor$1@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::catch$5

; 592  : 			catch (const std::exception& e) {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$??$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:

; 593  : 				throw std::runtime_error(std::string("JSON parsing failed: ") + e.what());

	mov	rcx, QWORD PTR e$32[rbp]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	mov	rbx, rax
	lea	rdx, OFFSET FLAT:??_C@_0BG@LNPEEPID@JSON?5parsing?5failed?3?5@
	lea	rcx, QWORD PTR $T29[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	r8, rbx
	mov	rdx, rax
	lea	rcx, QWORD PTR $T30[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T31[rbp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T31[rbp]
	call	_CxxThrowException
	npad	1
?catch$5@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::catch$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?dtor$2@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T29[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T6 = 40
__$ReturnUdt$GSCopy$ = 48
e$32 = 56
$T31 = 64
$T29 = 88
$T30 = 120
i$33 = 152
__$ArrayPad$ = 160
__$ReturnUdt$ = 192
input$ = 200
?dtor$3@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$3
	lea	rcx, QWORD PTR $T30[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$parse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@SA?AVDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Parser::parse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Dur$ = 16
??$duration_cast@V?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000> >,__int64,std::ratio<1,1000000000>,0>, COMDAT

; 429  :         // convert duration to another duration; truncate
; 430  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 431  : 
; 432  :         using _ToRep = typename _To::rep;
; 433  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 434  : 
; 435  :         constexpr bool _Num_is_one = _CF::num == 1;
; 436  :         constexpr bool _Den_is_one = _CF::den == 1;
; 437  : 
; 438  :         if constexpr (_Den_is_one) {
; 439  :             if constexpr (_Num_is_one) {
; 440  :                 return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));
; 441  :             } else {
; 442  :                 return static_cast<_To>(
; 443  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
; 444  :             }
; 445  :         } else {
; 446  :             if constexpr (_Num_is_one) {
; 447  :                 return static_cast<_To>(

	mov	rax, 2361183241434822607		; 20c49ba5e353f7cfH
	imul	QWORD PTR [rdx]
	sar	rdx, 7
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	mov	rax, rcx

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	QWORD PTR [rcx], rdx

; 448  :                     static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
; 449  :             } else {
; 450  :                 return static_cast<_To>(static_cast<_ToRep>(
; 451  :                     static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
; 452  :             }
; 453  :         }
; 454  :     }

	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@$0A@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0PECEA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000> >,__int64,std::ratio<1,1000000000>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 213  :             : _MyDur(_Other) {}

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::count, COMDAT

; 119  :             return _MyRep;

	mov	rax, QWORD PTR [rcx]

; 120  :         }

	ret	0
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count, COMDAT

; 119  :             return _MyRep;

	mov	rax, QWORD PTR [rcx]

; 120  :         }

	ret	0
?count@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
;	COMDAT ?isMapped@?$MappedFile@$0A@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isMapped@?$MappedFile@$0A@@@QEBA_NXZ PROC		; MappedFile<0>::isMapped, COMDAT

; 193  :     bool isMapped() const noexcept { return m_data != nullptr; };

	cmp	QWORD PTR [rcx], 0
	setne	al
	ret	0
?isMapped@?$MappedFile@$0A@@@QEBA_NXZ ENDP		; MappedFile<0>::isMapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
;	COMDAT ??1?$MappedFile@$0A@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$MappedFile@$0A@@@QEAA@XZ PROC			; MappedFile<0>::~MappedFile<0>, COMDAT

; 41   :     {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 176  :         if (m_data) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN5@MappedFile

; 177  : #ifdef _WIN32
; 178  :             UnmapViewOfFile(m_data);

	call	QWORD PTR __imp_UnmapViewOfFile

; 179  :             CloseHandle(m_mapping_handle);

	mov	rcx, QWORD PTR [rbx+24]
	call	QWORD PTR __imp_CloseHandle

; 180  :             CloseHandle(m_file_handle);

	mov	rcx, QWORD PTR [rbx+16]
	call	QWORD PTR __imp_CloseHandle

; 181  :             m_file_handle = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 182  :             m_mapping_handle = nullptr;

	mov	QWORD PTR [rbx+24], rax

; 183  : #else
; 184  :             munmap(const_cast<char*>(m_data), m_size);
; 185  :             close(m_fd);
; 186  :             m_fd = -1;
; 187  : #endif
; 188  :             m_data = nullptr;

	mov	QWORD PTR [rbx], rax

; 189  :             m_size = 0;

	mov	QWORD PTR [rbx+8], rax
$LN5@MappedFile:

; 42   :         unmap();
; 43   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$MappedFile@$0A@@@QEAA@XZ ENDP			; MappedFile<0>::~MappedFile<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
;	COMDAT ??0?$MappedFile@$0A@@@QEAA@PEBD@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
file_size$4 = 104
__$ArrayPad$ = 112
this$ = 144
filename$ = 152
??0?$MappedFile@$0A@@@QEAA@PEBD@Z PROC			; MappedFile<0>::MappedFile<0>, COMDAT

; 35   :     MappedFile(const char* filename)

$LN17:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 23   :     DataPointer m_data = nullptr;

	xor	edi, edi
	mov	rax, rdx
	mov	QWORD PTR [rcx], rdi
	mov	rbx, rcx

; 24   :     size_t m_size = 0;

	mov	QWORD PTR [rcx+8], rdi

; 105  :         else         m_file_handle = CreateFileA(

	xor	r9d, r9d

; 25   : #ifdef _WIN32
; 26   :     void* m_file_handle = nullptr;

	mov	QWORD PTR [rcx+16], rdi

; 105  :         else         m_file_handle = CreateFileA(

	mov	edx, -2147483648			; 80000000H

; 27   :     void* m_mapping_handle = nullptr;

	mov	QWORD PTR [rcx+24], rdi

; 105  :         else         m_file_handle = CreateFileA(

	mov	r8d, 1
	mov	QWORD PTR [rsp+48], rdi
	mov	rcx, rax
	mov	DWORD PTR [rsp+40], 128			; 00000080H
	mov	DWORD PTR [rsp+32], 3
	call	QWORD PTR __imp_CreateFileA
	mov	QWORD PTR [rbx+16], rax

; 106  :             filename, GENERIC_READ, FILE_SHARE_READ, NULL,
; 107  :             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
; 108  :         );
; 109  : 
; 110  :         if (m_file_handle == INVALID_HANDLE_VALUE) {

	cmp	rax, -1
	je	$LN14@MappedFile

; 112  :         }
; 113  : 
; 114  :         LARGE_INTEGER file_size;
; 115  :         GetFileSizeEx(m_file_handle, &file_size);

	lea	rdx, QWORD PTR file_size$4[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_GetFileSizeEx

; 116  :         m_size = static_cast<std::size_t>(file_size.QuadPart);

	mov	rax, QWORD PTR file_size$4[rsp]

; 117  : 
; 118  :         if constexpr (writable)
; 119  :             m_mapping_handle = CreateFileMappingA(
; 120  :                 m_file_handle, NULL, PAGE_READWRITE, 0, 0, NULL
; 121  :             );
; 122  :         else m_mapping_handle = CreateFileMappingA(

	xor	r9d, r9d
	mov	rcx, QWORD PTR [rbx+16]
	xor	edx, edx
	mov	QWORD PTR [rsp+40], rdi
	mov	r8d, 2
	mov	QWORD PTR [rbx+8], rax
	mov	DWORD PTR [rsp+32], edi
	call	QWORD PTR __imp_CreateFileMappingA
	mov	QWORD PTR [rbx+24], rax
	mov	rcx, rax

; 123  :             m_file_handle, NULL, PAGE_READONLY, 0, 0, NULL
; 124  :         );
; 125  : 
; 126  : 
; 127  :         if (!m_mapping_handle) {

	test	rax, rax
	je	SHORT $LN15@MappedFile

; 130  :         }
; 131  : 
; 132  :         if constexpr (writable)
; 133  :             m_data = static_cast<const char*>(MapViewOfFile(
; 134  :                 m_mapping_handle, FILE_MAP_WRITE, 0, 0, m_size
; 135  :             ));
; 136  :         else m_data = static_cast<const char*>(MapViewOfFile(

	mov	rax, QWORD PTR [rbx+8]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rax
	mov	edx, 4
	call	QWORD PTR __imp_MapViewOfFile
	mov	QWORD PTR [rbx], rax

; 137  :             m_mapping_handle, FILE_MAP_READ, 0, 0, m_size
; 138  :         ));
; 139  : 
; 140  :         if (!m_data) {

	test	rax, rax
	je	$LN16@MappedFile

; 36   :     {
; 37   :         map(filename);
; 38   :     }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
$LN14@MappedFile:

; 111  :             throw std::system_error(GetLastError(), std::system_category());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	call	?system_category@std@@YAAEBVerror_category@1@XZ ; std::system_category
	mov	r8, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN15@MappedFile:

; 128  :             CloseHandle(m_file_handle);

	mov	rcx, QWORD PTR [rbx+16]
	call	QWORD PTR __imp_CloseHandle

; 129  :             throw std::system_error(GetLastError(), std::system_category());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	call	?system_category@std@@YAAEBVerror_category@1@XZ ; std::system_category
	mov	r8, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T2[rsp]
	call	_CxxThrowException
	int	3
$LN16@MappedFile:

; 141  :             CloseHandle(m_mapping_handle);

	mov	rcx, QWORD PTR [rbx+24]
	call	QWORD PTR __imp_CloseHandle

; 142  :             CloseHandle(m_file_handle);

	mov	rcx, QWORD PTR [rbx+16]
	call	QWORD PTR __imp_CloseHandle

; 143  :             throw std::system_error(GetLastError(), std::system_category());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	call	?system_category@std@@YAAEBVerror_category@1@XZ ; std::system_category
	mov	r8, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
	int	3
$LN12@MappedFile:
??0?$MappedFile@$0A@@@QEAA@PEBD@Z ENDP			; MappedFile<0>::MappedFile<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >, COMDAT

; 316  :     ~_Hash_vec() {

$LN33:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 307  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN5@Hash_vec

; 279  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@Hash_vec

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN21@Hash_vec

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN22@Hash_vec:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 310  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 311  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 312  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN5@Hash_vec:

; 322  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN21@Hash_vec:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	eax, eax
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rax
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN30@Hash_vec:
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >, COMDAT

; 1060 :     ~list() noexcept {

$LN99:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1518 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]

; 1060 :     ~list() noexcept {

	mov	rsi, rcx

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rdi, QWORD PTR [rdx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rdi, rdi
	je	SHORT $LN92@list
	mov	QWORD PTR [rsp+56], rbx
	npad	8
$LL10@list:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdi]

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rdi+16]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rdi, rbx
	test	rbx, rbx
	jne	SHORT $LL10@list
	mov	rbx, QWORD PTR [rsp+56]
$LN92@list:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rsi]
	mov	edx, 56					; 00000038H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 1066 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map
;	COMDAT ??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 64
??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >, COMDAT

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

$LN73:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	xor	edi, edi
	mov	DWORD PTR [rcx], edi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi

; 1852 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rax], rax

; 1853 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1854 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx+8], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 371  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	lea	rcx, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 371  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR [rbx+48], 7
	mov	QWORD PTR [rbx+56], 8

; 372  :         // construct empty hash table
; 373  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [rbx], 1065353216		; 3f800000H

; 374  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 16
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Assign_grow
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map

; 101  :     unordered_map() : _Mybase(_Key_compare(), allocator_type()) {}

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 64
?dtor$1@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
?dtor$1@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 64
?dtor$2@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >
?dtor$2@?0???0?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::size, COMDAT

; 1914 :         auto& _My_data = _Mypair._Myval2;
; 1915 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1916 :     }

	ret	0
?size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 829  :     _CONSTEXPR20 ~vector() noexcept {

$LN61:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 48					; 00000030H

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]

; 829  :     _CONSTEXPR20 ~vector() noexcept {

	mov	rsi, rcx

; 2090 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN5@vector
	mov	QWORD PTR [rsp+72], rdi

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN10@vector
$LL11@vector:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN29@vector

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN29@vector:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL11@vector
$LN10@vector:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN43@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN42@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN43@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2096 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2097 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN5@vector:

; 835  :     }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN42@vector:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	eax, eax
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rax
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN58@vector:
??1?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 671  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 672  :     }

	mov	rax, rcx
	ret	0
??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 435  :         value_type* _Result = _Bx._Buf;
; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN8@Myptr

; 437  :             _Result = _Unfancy(_Bx._Ptr);
; 438  :         }
; 439  : 
; 440  :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 441  :     }

	ret	0
$LN8@Myptr:

; 437  :             _Result = _Unfancy(_Bx._Ptr);
; 438  :         }
; 439  : 
; 440  :         return _Result;

	mov	rax, rcx

; 441  :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rcx+24], 15
	seta	al

; 454  :     }

	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@AEAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Istr$ = 16
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@AEAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >, COMDAT

; 381  :     istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
	mov	rax, QWORD PTR [r8+rdx+72]
	test	rax, rax
	mov	QWORD PTR [rcx], rax
	mov	BYTE PTR [rcx+9], 0
	sete	al
	mov	BYTE PTR [rcx+8], al
	mov	rax, rcx
	ret	0
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@AEAV?$basic_istream@DU?$char_traits@D@std@@@1@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >, COMDAT

; 376  :     constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}

	mov	QWORD PTR [rcx], 0
	mov	rax, rcx
	mov	WORD PTR [rcx+8], 1
	ret	0
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Requested$ = 8
_Old$ = 16
_Max$ = 24
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rcx, 15
	cmp	rcx, r8

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN9@Calculate_

; 2980 :             return _Max;
; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r9, rdx
	mov	rax, r8
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN9@Calculate_

; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r9+rdx]
	cmp	rcx, rax
	cmovb	rcx, rax
	mov	rax, rcx

; 2988 :     }

	ret	0
$LN9@Calculate_:

; 2984 :             return _Max;

	mov	rax, r8

; 2988 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 2374 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]

; 2375 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN11@data

; 2365 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 2366 :     }

	ret	0
$LN11@data:

; 2365 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 2366 :     }

	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN11@c_str

; 2356 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 2357 :     }

	ret	0
$LN11@c_str:

; 2356 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 2357 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1533 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN59:
	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

	mov	rbx, -1
$LL53@append:
	inc	rbx
	cmp	BYTE PTR [rdx+rbx], 0
	jne	SHORT $LL53@append
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1513 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	r8, QWORD PTR [rsi+24]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, r8
	sub	rax, rcx
	cmp	rbx, rax
	ja	SHORT $LN7@append
	mov	QWORD PTR [rsp+64], rdi

; 1514 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+rbx]
	mov	QWORD PTR [rsi+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 436  :         if (_Large_mode_engaged()) {

	cmp	r8, 15
	jbe	SHORT $LN10@append

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN10@append:

; 1517 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	rdi, QWORD PTR [rax+rcx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0

; 1534 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+64]

; 1535 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN7@append:

; 1522 :         return _Reallocate_grow_by(

	mov	r9, rdx
	mov	QWORD PTR [rsp+32], rbx
	mov	rdx, rbx
	mov	rcx, rsi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>

; 1535 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1482 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

$LN62:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 48					; 00000030H

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15

; 1482 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

	mov	rbx, rcx

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN4@append

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN4@append:

; 1512 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rbp, QWORD PTR [rcx+16]

; 1513 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, rcx
	sub	rax, rbp
	cmp	rdi, rax
	ja	SHORT $LN11@append
	mov	QWORD PTR [rsp+64], rsi

; 1514 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rdi+rbp]
	mov	QWORD PTR [rbx+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rsi, rbx

; 436  :         if (_Large_mode_engaged()) {

	cmp	rcx, 15
	jbe	SHORT $LN14@append

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rbx]
$LN14@append:

; 1517 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	rcx, QWORD PTR [rsi+rbp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	call	memmove
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	lea	rcx, QWORD PTR [rdi+rsi]

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, rbx
	mov	rsi, QWORD PTR [rsp+64]

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rcx+rbp], 0

; 1484 :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN11@append:

; 1522 :         return _Reallocate_grow_by(

	mov	r9, rdx
	mov	QWORD PTR [rsp+32], rdi
	mov	rdx, rdi
	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>

; 1484 :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1382 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN37:
	push	rbx
	sub	rsp, 48					; 00000030H

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 1382 :     _CONSTEXPR20 ~basic_string() noexcept {

	mov	rbx, rcx

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN17@basic_stri
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN24@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN25@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN17@basic_stri:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 1390 :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN24@basic_stri:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN34@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rcx], ymm0

; 1029 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 1030 :         _Take_contents(_Right);
; 1031 :     }

	mov	BYTE PTR [rdx], al
	mov	QWORD PTR [rdx+16], rax
	mov	rax, rcx
	mov	QWORD PTR [rdx+24], 15
	vzeroupper
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 755  :         : _Mypair(_Zero_then_variadic_args_t{}) {

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax

; 755  :         : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	rbx, rcx
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax

; 756  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 757  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 708  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 860  :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 709  :         _Construct_empty();
; 710  :     }

	mov	rax, rcx

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 709  :         _Construct_empty();
; 710  :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
;	COMDAT ?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::close, COMDAT

; 161  :     void close() {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 162  :         if (!_Filebuffer.close()) {

	add	rcx, 16
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
	test	rax, rax
	jne	SHORT $LN2@close

; 163  :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR [rbx]
	xor	r8d, r8d
	mov	edx, 2
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx

; 164  :         }
; 165  :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 163  :             _Myios::setstate(ios_base::failbit);

	rex_jmp	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@close:

; 164  :         }
; 165  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
;	COMDAT ?is_open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?is_open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::is_open, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 277  :         return static_cast<bool>(_Myfile);

	cmp	QWORD PTR [rcx+144], 0
	setne	al
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 138  :     }

	ret	0
?is_open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::is_open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rax, QWORD PTR [rcx-176]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rdx+rcx-176], rax
	mov	rax, QWORD PTR [rcx-176]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-176]
	mov	DWORD PTR [rdx+rcx-180], r8d
	lea	rbx, QWORD PTR [rcx-160]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 175  :     __CLR_OR_THIS_CALL ~basic_filebuf() noexcept override {

	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rbx], rax

; 176  :         if (_Myfile) {

	cmp	QWORD PTR [rbx+128], 0
	je	SHORT $LN21@basic_ifst
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	rcx, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rbx+112]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN21@basic_ifst

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	r8, QWORD PTR [rbx+144]
	mov	rdx, QWORD PTR [rbx+136]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [rcx], rdx

; 208  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rdx

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	r8d, edx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], r8d
$LN21@basic_ifst:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 180  :         if (_Closef) {

	cmp	BYTE PTR [rbx+124], 0
	je	SHORT $LN6@basic_ifst

; 181  :             close();

	mov	rcx, rbx
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN6@basic_ifst:

; 182  :         }
; 183  :     }

	mov	rcx, rbx
	call	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 130  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

	lea	rcx, QWORD PTR [rdi-152]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	rex_jmp	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
_TEXT	SEGMENT
this$ = 64
_Str$ = 72
_Mode$dead$ = 80
_Prot$dead$ = 88
$initVBases$dead$ = 96
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 40   :     explicit basic_ifstream(

$LN17:
	push	rbx
	sub	rsp, 48					; 00000030H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 40   :     explicit basic_ifstream(

	mov	rbx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@basic_ifst

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN8@basic_ifst:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 42   :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	rax, QWORD PTR [rbx]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rdx+rbx], rax
	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rax, rbx
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR [rcx+rbx-4], edx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
_TEXT	SEGMENT
this$ = 48
_Loc$ = 56
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT

; 673  :     void __CLR_OR_THIS_CALL imbue(const locale& _Loc) override {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 674  :         // set locale to argument (capture nontrivial codecvt facet)
; 675  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

	mov	rcx, rdx
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >

; 743  :         if (_Newcvt.always_noconv()) {

	mov	rcx, rax

; 674  :         // set locale to argument (capture nontrivial codecvt facet)
; 675  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

	mov	rdi, rax

; 743  :         if (_Newcvt.always_noconv()) {

	call	QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN4@imbue

; 744  :             _Pcvt = nullptr; // nothing to do

	mov	QWORD PTR [rbx+104], 0

; 676  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@imbue:

; 747  :             _Mysb::_Init(); // reset any buffering

	mov	rcx, rbx
	mov	QWORD PTR [rbx+104], rdi

; 676  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 747  :             _Mysb::_Init(); // reset any buffering

	rex_jmp	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT

; 665  :     int __CLR_OR_THIS_CALL sync() override { // synchronize C stream with external file

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 666  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

	cmp	QWORD PTR [rcx+128], 0
	mov	rbx, rcx
	je	SHORT $LN3@sync
	mov	rax, QWORD PTR [rcx]
	mov	edx, -1
	call	QWORD PTR [rax+24]
	cmp	eax, -1
	je	SHORT $LN3@sync
	mov	rcx, QWORD PTR [rbx+128]
	call	QWORD PTR __imp_fflush
	xor	ecx, ecx
	test	eax, eax
	setns	cl
	lea	eax, DWORD PTR [rcx-1]

; 668  :         }
; 669  : 
; 670  :         return -1;
; 671  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@sync:

; 667  :             return 0;

	xor	eax, eax

; 668  :         }
; 669  : 
; 670  :         return -1;
; 671  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
_TEXT	SEGMENT
_Pb$1 = 32
_Pn$2 = 40
_Nr$3 = 48
__$ArrayPad$ = 56
this$ = 96
_Buffer$ = 104
_Count$ = 112
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT

; 646  :     _Mysb* __CLR_OR_THIS_CALL setbuf(_Elem* _Buffer, streamsize _Count) override { // offer _Buffer to C stream

$LN23:
	push	rbx
	push	rsi
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 647  :         int _Mode;
; 648  :         if (!_Buffer && _Count == 0) {

	xor	esi, esi
	mov	r9, r8
	mov	rbx, rcx
	test	rdx, rdx
	jne	SHORT $LN2@setbuf
	test	r8, r8

; 649  :             _Mode = _IONBF;

	mov	r8d, 4
	je	SHORT $LN3@setbuf
$LN2@setbuf:

; 650  :         } else {
; 651  :             _Mode = _IOFBF;

	mov	r8d, esi
$LN3@setbuf:

; 652  :         }
; 653  : 
; 654  :         const size_t _Size = static_cast<size_t>(_Count) * sizeof(_Elem);
; 655  : 
; 656  :         if (!_Myfile || _CSTD setvbuf(_Myfile, reinterpret_cast<char*>(_Buffer), _Mode, _Size) != 0) {

	mov	rcx, QWORD PTR [rcx+128]
	test	rcx, rcx
	je	$LN5@setbuf
	call	QWORD PTR __imp_setvbuf
	test	eax, eax
	jne	$LN5@setbuf
	mov	QWORD PTR [rsp+64], rdi

; 686  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rbx

; 658  :         }
; 659  : 
; 660  :         // new buffer, reinitialize pointers
; 661  :         _Init(_Myfile, _Openfl);

	mov	rdi, QWORD PTR [rbx+128]

; 683  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rbx+124], 1

; 684  :         _Wrotesome = false;

	mov	BYTE PTR [rbx+113], sil

; 685  : 
; 686  :         _Mysb::_Init(); // initialize stream buffer base object

	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 687  : 
; 688  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

	test	rdi, rdi
	je	SHORT $LN12@setbuf

; 689  :             _Elem** _Pb = nullptr;
; 690  :             _Elem** _Pn = nullptr;
; 691  :             int* _Nr    = nullptr;
; 692  : 
; 693  :             ::_get_stream_buffer_pointers(

	lea	r9, QWORD PTR _Nr$3[rsp]
	mov	QWORD PTR _Pb$1[rsp], rsi
	lea	r8, QWORD PTR _Pn$2[rsp]
	mov	QWORD PTR _Pn$2[rsp], rsi
	lea	rdx, QWORD PTR _Pb$1[rsp]
	mov	QWORD PTR _Nr$3[rsp], rsi
	mov	rcx, rdi
	call	QWORD PTR __imp__get_stream_buffer_pointers
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 277  :         _IGfirst = _Gf;

	mov	rcx, QWORD PTR _Pb$1[rsp]
	mov	QWORD PTR [rbx+24], rcx

; 278  :         _IPfirst = _Pf;

	mov	QWORD PTR [rbx+32], rcx

; 279  :         _IGnext  = _Gn;

	mov	rcx, QWORD PTR _Pn$2[rsp]
	mov	QWORD PTR [rbx+56], rcx

; 280  :         _IPnext  = _Pn;

	mov	QWORD PTR [rbx+64], rcx

; 281  :         _IGcount = _Gc;

	mov	rcx, QWORD PTR _Nr$3[rsp]
	mov	QWORD PTR [rbx+80], rcx

; 282  :         _IPcount = _Pc;

	mov	QWORD PTR [rbx+88], rcx
$LN12@setbuf:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 701  :         _State  = _Stinit;

	mov	rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit

; 662  :         return this;

	mov	rax, rbx

; 700  :         _Myfile = _File;

	mov	QWORD PTR [rbx+128], rdi

; 662  :         return this;

	mov	rdi, QWORD PTR [rsp+64]

; 701  :         _State  = _Stinit;

	mov	QWORD PTR [rbx+116], rcx

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rsi

; 662  :         return this;

	jmp	SHORT $LN1@setbuf
$LN5@setbuf:

; 657  :             return nullptr; // failed

	xor	eax, eax
$LN1@setbuf:

; 663  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 72					; 00000048H
	pop	rsi
	pop	rbx
	ret	0
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_Off$ = 32
__$ArrayPad$ = 40
this$ = 80
__$ReturnUdt$ = 88
_Pos$ = 96
__formal$ = 104
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT

; 633  :     pos_type __CLR_OR_THIS_CALL seekpos(pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

$LN35:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 67   :         return _Myoff + _Fpos;

	mov	rax, QWORD PTR [r8+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 633  :     pos_type __CLR_OR_THIS_CALL seekpos(pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

	mov	rsi, r8
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 67   :         return _Myoff + _Fpos;

	add	rax, QWORD PTR [r8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 633  :     pos_type __CLR_OR_THIS_CALL seekpos(pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

	mov	rbx, rdx

; 634  :         // change position to _Pos
; 635  :         off_type _Off = static_cast<off_type>(_Pos);
; 636  : 
; 637  :         if (!_Myfile || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0) {

	cmp	QWORD PTR [rcx+128], 0
	mov	rdi, rcx
	mov	QWORD PTR _Off$[rsp], rax
	je	SHORT $LN3@seekpos
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	SHORT $LN3@seekpos
	mov	rcx, QWORD PTR [rdi+128]
	lea	rdx, QWORD PTR _Off$[rsp]
	call	QWORD PTR __imp_fsetpos
	test	eax, eax
	jne	SHORT $LN3@seekpos

; 641  :         _State = _Pos.state();

	mov	rax, QWORD PTR [rsi+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	rcx, QWORD PTR [rdi+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 641  :         _State = _Pos.state();

	mov	QWORD PTR [rdi+116], rax

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rdi+112]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN22@seekpos

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rdi+136]
	mov	r8, QWORD PTR [rdi+144]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [rcx], rdx

; 208  :         *_IGnext  = _Next;
; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	r8d, edx
	mov	rcx, QWORD PTR [rdi+56]
	mov	QWORD PTR [rcx], rdx
	mov	rcx, QWORD PTR [rdi+80]
	mov	DWORD PTR [rcx], r8d
$LN22@seekpos:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 643  :         return pos_type{_State, _Off}; // return new position

	mov	rdx, QWORD PTR [rdi+116]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

	mov	rcx, QWORD PTR _Off$[rsp]
	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+16], rdx
	mov	QWORD PTR [rbx+8], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 643  :         return pos_type{_State, _Off}; // return new position

	jmp	SHORT $LN32@seekpos
$LN3@seekpos:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	xor	eax, eax
	mov	QWORD PTR [rbx], -1
	mov	QWORD PTR [rbx+8], 0
	mov	QWORD PTR [rbx+16], rax
$LN32@seekpos:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 644  :     }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_Fileposition$ = 32
__$ArrayPad$ = 40
this$ = 96
__$ReturnUdt$ = 104
_Off$ = 112
_Way$ = 120
__formal$ = 128
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT

; 614  :         ios_base::openmode = ios_base::in | ios_base::out) override { // change position by _Off

$LN42:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

	mov	rax, QWORD PTR [rcx+56]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 619  :             && !_Pcvt) { // not converting

	lea	r14, QWORD PTR [rcx+112]
	mov	ebp, r9d
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	QWORD PTR [rax], r14
	jne	SHORT $LN2@seekoff
	cmp	r9d, 1
	jne	SHORT $LN2@seekoff
	cmp	QWORD PTR [rcx+104], 0
	jne	SHORT $LN2@seekoff

; 620  :             _Off -= static_cast<off_type>(sizeof(_Elem)); // back up over _Elem bytes

	dec	rsi
$LN2@seekoff:

; 621  :         }
; 622  : 
; 623  :         if (!_Myfile || !_Endwrite()
; 624  :             || ((_Off != 0 || _Way != ios_base::cur) && _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 625  :             || _CSTD fgetpos(_Myfile, &_Fileposition) != 0) {

	cmp	QWORD PTR [rcx+128], 0
	je	$LN4@seekoff
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	SHORT $LN4@seekoff
	test	rsi, rsi
	jne	SHORT $LN6@seekoff
	cmp	ebp, 1
	je	SHORT $LN5@seekoff
$LN6@seekoff:
	mov	rcx, QWORD PTR [rbx+128]
	mov	r8d, ebp
	mov	rdx, rsi
	call	QWORD PTR __imp__fseeki64
	test	eax, eax
	jne	SHORT $LN4@seekoff
$LN5@seekoff:
	mov	rcx, QWORD PTR [rbx+128]
	lea	rdx, QWORD PTR _Fileposition$[rsp]
	call	QWORD PTR __imp_fgetpos
	test	eax, eax
	jne	SHORT $LN4@seekoff
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	rax, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	cmp	QWORD PTR [rax], r14
	jne	SHORT $LN25@seekoff

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rbx+136]
	mov	r8, QWORD PTR [rbx+144]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [rax], rdx

; 208  :         *_IGnext  = _Next;
; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	r8d, edx
	mov	rcx, QWORD PTR [rbx+56]
	mov	QWORD PTR [rcx], rdx
	mov	rcx, QWORD PTR [rbx+80]
	mov	DWORD PTR [rcx], r8d
$LN25@seekoff:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 630  :         return pos_type{_State, _Fileposition}; // return new position

	mov	rdx, QWORD PTR [rbx+116]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

	mov	rcx, QWORD PTR _Fileposition$[rsp]
	mov	QWORD PTR [rdi], rcx
	mov	QWORD PTR [rdi+16], rdx
	mov	QWORD PTR [rdi+8], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 630  :         return pos_type{_State, _Fileposition}; // return new position

	jmp	SHORT $LN39@seekoff
$LN4@seekoff:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	xor	eax, eax
	mov	QWORD PTR [rdi], -1
	mov	QWORD PTR [rdi+8], 0
	mov	QWORD PTR [rdi+16], rax
$LN39@seekoff:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 631  :     }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsputn, COMDAT

; 583  :     streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) override {

$LN49:
	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 32					; 00000020H

; 584  :         // put _Count characters to stream
; 585  :         if constexpr (sizeof(_Elem) == 1) {
; 586  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

	cmp	QWORD PTR [rcx+104], 0
	mov	rbx, r8
	mov	rbp, rdx
	mov	rdi, rcx
	je	SHORT $LN2@xsputn

; 608  :         } else { // non-chars always get element-by-element processing
; 609  :             return _Mysb::xsputn(_Ptr, _Count);
; 610  :         }
; 611  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rbp
	pop	rbx

; 587  :                 return _Mysb::xsputn(_Ptr, _Count);

	rex_jmp	QWORD PTR __imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
$LN2@xsputn:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

	mov	rax, QWORD PTR [rcx+64]
	mov	QWORD PTR [rsp+64], rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 590  :             const streamsize _Start_count = _Count;

	mov	rsi, rbx
	mov	QWORD PTR [rsp+72], r14
	mov	QWORD PTR [rsp+88], r15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 261  :         return *_IPnext ? *_IPcount : 0;

	mov	r9, QWORD PTR [rax]
	test	r9, r9
	je	SHORT $LN9@xsputn
	mov	rax, QWORD PTR [rcx+88]
	mov	ecx, DWORD PTR [rax]
	jmp	SHORT $LN10@xsputn
$LN9@xsputn:
	xor	ecx, ecx
$LN10@xsputn:
	movsxd	r15, ecx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 592  :             if (0 < _Count && 0 < _Size) { // copy to write buffer

	test	rbx, rbx
	jle	SHORT $LN5@xsputn
	test	ecx, ecx
	jle	SHORT $LN41@xsputn

; 593  :                 if (_Count < _Size) {

	cmp	rbx, r15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 593  :                 if (_Count < _Size) {

	cmovl	r15, rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r15
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 237  :         *_IPcount -= _Off;

	mov	rax, QWORD PTR [rdi+88]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 599  :                 _Count -= _Size;

	sub	rbx, r15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 238  :         *_IPnext += _Off;

	add	rbp, r15
	sub	DWORD PTR [rax], r15d
	mov	rcx, QWORD PTR [rdi+64]
	movsxd	rax, r15d
	add	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 603  :             if (0 < _Count && _Myfile) { // open C stream, attempt write

	test	rbx, rbx
	jle	SHORT $LN5@xsputn
$LN41@xsputn:
	mov	r9, QWORD PTR [rdi+128]
	test	r9, r9
	je	SHORT $LN5@xsputn

; 604  :                 _Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

	mov	r8, rbx
	mov	edx, 1
	mov	rcx, rbp
	call	QWORD PTR __imp_fwrite
	sub	rbx, rax
$LN5@xsputn:

; 605  :             }
; 606  : 
; 607  :             return _Start_count - _Count;

	mov	r15, QWORD PTR [rsp+88]
	sub	rsi, rbx
	mov	r14, QWORD PTR [rsp+72]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+64]

; 608  :         } else { // non-chars always get element-by-element processing
; 609  :             return _Mysb::xsputn(_Ptr, _Count);
; 610  :         }
; 611  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn, COMDAT

; 535  :     streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) override {

$LN79:
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	r14, r8
	mov	rbp, rdx
	mov	rsi, rcx

; 536  :         // get _Count characters from stream
; 537  :         if constexpr (sizeof(_Elem) == 1) {
; 538  :             if (_Count <= 0) {

	test	r8, r8
	jg	SHORT $LN4@xsgetn

; 539  :                 return 0;

	xor	eax, eax

; 578  :         } else { // non-chars always get element-by-element processing
; 579  :             return _Mysb::xsgetn(_Ptr, _Count);
; 580  :         }
; 581  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN4@xsgetn:

; 540  :             }
; 541  : 
; 542  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

	cmp	QWORD PTR [rcx+104], 0
	je	SHORT $LN5@xsgetn

; 578  :         } else { // non-chars always get element-by-element processing
; 579  :             return _Mysb::xsgetn(_Ptr, _Count);
; 580  :         }
; 581  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbp

; 543  :                 return _Mysb::xsgetn(_Ptr, _Count);

	rex_jmp	QWORD PTR __imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
$LN5@xsgetn:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

	mov	rax, QWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+40], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 547  :             auto _Count_s           = static_cast<size_t>(_Count);

	mov	rbx, r14
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 232  :         return *_IGnext ? *_IGcount : 0;

	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	je	SHORT $LN13@xsgetn
	mov	rax, QWORD PTR [rcx+80]
	mov	ecx, DWORD PTR [rax]
	jmp	SHORT $LN14@xsgetn
$LN13@xsgetn:
	xor	ecx, ecx
$LN14@xsgetn:
	movsxd	rax, ecx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 549  :             const auto _Available   = static_cast<size_t>(_Mysb::_Gnavail());

	test	ecx, ecx

; 550  :             if (0 < _Available) { // copy from get area

	je	SHORT $LN34@xsgetn
	mov	QWORD PTR [rsp+32], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 101  :     return _Right < _Left ? _Right : _Left;

	cmp	rax, r14
	mov	rdi, r14
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 101  :     return _Right < _Left ? _Right : _Left;

	cmovb	rdi, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 201  :         *_IGcount -= _Off;

	mov	rax, QWORD PTR [rsi+80]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 553  :                 _Ptr += _Read_size;

	add	rbp, rdi

; 554  :                 _Count_s -= _Read_size;

	sub	rbx, rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 201  :         *_IGcount -= _Off;

	sub	DWORD PTR [rax], edi

; 202  :         *_IGnext += _Off;

	mov	rcx, QWORD PTR [rsi+56]
	movsxd	rax, edi
	mov	rdi, QWORD PTR [rsp+32]
	add	QWORD PTR [rcx], rax
$LN34@xsgetn:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 558  :             if (_Myfile) { // open C stream, attempt read

	cmp	QWORD PTR [rsi+128], 0
	je	$LN9@xsgetn
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	r8, QWORD PTR [rsi+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rsi+112]
	cmp	QWORD PTR [r8], rax
	jne	SHORT $LN48@xsgetn

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rcx, QWORD PTR [rsi+136]
	mov	rdx, QWORD PTR [rsi+144]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [r8], rcx

; 208  :         *_IGnext  = _Next;
; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR [rsi+56]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR [rsi+80]
	mov	DWORD PTR [rax], edx
$LN48@xsgetn:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 563  :                 while (_Read_size < _Count_s) {

	cmp	rbx, 4095				; 00000fffH
	jbe	SHORT $LN3@xsgetn
	npad	10
$LL2@xsgetn:

; 564  :                     const auto _Actual_read = _CSTD fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);

	mov	r9, QWORD PTR [rsi+128]
	mov	edx, 1
	mov	r8d, 4095				; 00000fffH
	mov	rcx, rbp
	call	QWORD PTR __imp_fread

; 565  :                     _Ptr += _Actual_read;

	add	rbp, rax

; 566  :                     _Count_s -= _Actual_read;

	sub	rbx, rax

; 567  :                     if (_Actual_read != _Read_size) {

	cmp	rax, 4095				; 00000fffH
	jne	SHORT $LN9@xsgetn

; 563  :                 while (_Read_size < _Count_s) {

	cmp	rbx, rax
	ja	SHORT $LL2@xsgetn
$LN3@xsgetn:

; 568  :                         return static_cast<streamsize>(_Start_count - _Count_s);
; 569  :                     }
; 570  :                 }
; 571  : 
; 572  :                 if (0 < _Count_s) {

	test	rbx, rbx
	je	SHORT $LN9@xsgetn

; 573  :                     _Count_s -= _CSTD fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);

	mov	r9, QWORD PTR [rsi+128]
	mov	r8, rbx
	mov	edx, 1
	mov	rcx, rbp
	call	QWORD PTR __imp_fread
	sub	rbx, rax
$LN9@xsgetn:

; 574  :                 }
; 575  :             }
; 576  : 
; 577  :             return static_cast<streamsize>(_Start_count - _Count_s);

	sub	r14, rbx
	mov	rbx, QWORD PTR [rsp+40]
	mov	rax, r14

; 578  :         } else { // non-chars always get element-by-element processing
; 579  :             return _Mysb::xsgetn(_Ptr, _Count);
; 580  :         }
; 581  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
_Src$47 = 64
_Dest$48 = 72
_Ch$49 = 80
_Str$ = 88
__$ArrayPad$ = 120
this$ = 144
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT

; 478  :     int_type __CLR_OR_THIS_CALL uflow() override { // get an element from stream, point past it

$LN267:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-128], rax
	mov	rdi, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

	mov	rax, QWORD PTR [rcx+56]
	mov	rcx, QWORD PTR [rax]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 479  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

	test	rcx, rcx
	je	SHORT $LN258@uflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 196  :         return *_IGnext + *_IGcount;

	mov	rdx, QWORD PTR [rdi+80]
	movsxd	r9, DWORD PTR [rdx]
	lea	rax, QWORD PTR [rcx+r9]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 479  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

	cmp	rcx, rax
	jae	SHORT $LN258@uflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 222  :         --*_IGcount;

	lea	eax, DWORD PTR [r9-1]
	mov	DWORD PTR [rdx], eax

; 223  :         return (*_IGnext)++;

	mov	rcx, QWORD PTR [rdi+56]
	mov	rdx, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [rdx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 480  :             return _Traits::to_int_type(*_Mysb::_Gninc()); // return buffered

	jmp	$LN1@uflow
$LN258@uflow:

; 481  :         }
; 482  : 
; 483  :         if (!_Myfile) {

	cmp	QWORD PTR [rdi+128], 0
	jne	SHORT $LN10@uflow

; 484  :             return _Traits::eof(); // no open C stream, fail

	mov	eax, -1
	jmp	$LN1@uflow
$LN10@uflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	r9, QWORD PTR [rdi+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rdi+112]
	cmp	QWORD PTR [r9], rax
	jne	SHORT $LN113@uflow

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rdi+144]
	mov	rcx, QWORD PTR [rdi+136]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [r9], rcx

; 208  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rax], rcx

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR [rdi+80]
	mov	DWORD PTR [rax], edx
$LN113@uflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 488  :         if (!_Pcvt) { // no codecvt facet, just get it

	mov	rcx, QWORD PTR [rdi+128]
	cmp	QWORD PTR [rdi+104], 0
	jne	SHORT $LN11@uflow

; 75   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

	call	QWORD PTR __imp_fgetc
	cmp	eax, -1

; 490  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

	mov	ebx, -1

; 75   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

	je	$LN43@uflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

	movzx	ebx, al
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 490  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

	jmp	$LN43@uflow
$LN11@uflow:
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR _Str$[rbp-128], xmm0

; 860  :         _My_data._Mysize = 0;

	mov	QWORD PTR _Str$[rbp-112], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR _Str$[rbp-104], 15

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR _Str$[rbp-128], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 498  :             int _Meta = _CSTD fgetc(_Myfile);

	call	QWORD PTR __imp_fgetc
	mov	r9d, eax

; 499  : 
; 500  :             if (_Meta == EOF) {

	cmp	eax, -1
	je	$LN226@uflow
	npad	3
$LL4@uflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR _Str$[rbp-112]
	mov	r8, QWORD PTR _Str$[rbp-104]
	cmp	rdx, r8

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN64@uflow

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rcx, QWORD PTR [rdx+1]
	mov	QWORD PTR _Str$[rbp-112], rcx

; 435  :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR _Str$[rbp-128]

; 436  :         if (_Large_mode_engaged()) {

	cmp	r8, 15
	cmova	rax, QWORD PTR _Str$[rbp-128]

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rdx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rdx+1], 0

; 2299 :             return;

	jmp	SHORT $LN63@uflow
$LN64@uflow:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR _Str$[rbp-128]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN63@uflow:

; 435  :         value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR _Str$[rbp-128]

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR _Str$[rbp-104], 15
	cmova	r9, QWORD PTR _Str$[rbp-128]

; 435  :         value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR _Str$[rbp-128]

; 436  :         if (_Large_mode_engaged()) {

	cmova	r8, QWORD PTR _Str$[rbp-128]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 510  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {

	add	r9, QWORD PTR _Str$[rbp-112]
	lea	rax, QWORD PTR _Dest$48[rbp-128]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR _Ch$49[rbp-127]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR _Ch$49[rbp-128]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR _Src$47[rbp-128]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rdi+116]
	mov	rcx, QWORD PTR [rdi+104]
	call	QWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
	test	eax, eax
	je	SHORT $LN13@uflow
	sub	eax, 1
	jne	$LN259@uflow
$LN13@uflow:

; 511  :             case codecvt_base::partial:
; 512  :             case codecvt_base::ok:
; 513  :                 if (_Dest != &_Ch) { // got an element, put back excess and deliver it

	lea	rax, QWORD PTR _Ch$49[rbp-128]
	mov	rbx, QWORD PTR _Str$[rbp-112]
	cmp	QWORD PTR _Dest$48[rbp-128], rax
	lea	rax, QWORD PTR _Str$[rbp-128]
	jne	$LN227@uflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR _Str$[rbp-104], 15
	cmova	rax, QWORD PTR _Str$[rbp-128]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 522  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

	mov	r9, QWORD PTR _Src$47[rbp-128]
	sub	r9, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 487  :         return (_STD min)(_Size, _Mysize - _Off);

	cmp	rbx, r9
	cmovb	r9, rbx

; 435  :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR _Str$[rbp-128]

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR _Str$[rbp-104], 15
	cmova	rcx, QWORD PTR _Str$[rbp-128]

; 1881 :         const size_type _New_size = _Old_size - _Count;

	sub	rbx, r9

; 1882 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	lea	r8, QWORD PTR [rbx+1]
	lea	rdx, QWORD PTR [r9+rcx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	memmove
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1884 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR _Str$[rbp-112], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 498  :             int _Meta = _CSTD fgetc(_Myfile);

	mov	rcx, QWORD PTR [rdi+128]
	call	QWORD PTR __imp_fgetc
	mov	r9d, eax

; 499  : 
; 500  :             if (_Meta == EOF) {

	cmp	eax, -1
	jne	$LL4@uflow
$LN226@uflow:

; 528  : 
; 529  :             default:
; 530  :                 return _Traits::eof(); // conversion failed

	mov	ebx, -1
$LN24@uflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR _Str$[rbp-104]
	cmp	rdx, 15
	jbe	$LN43@uflow

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Str$[rbp-128]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	$LN51@uflow

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	$LN51@uflow
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	npad	1
$LN259@uflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 510  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {

	cmp	eax, 2
	jne	SHORT $LN226@uflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 435  :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR _Str$[rbp-128]

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR _Str$[rbp-104], 15
	cmova	rax, QWORD PTR _Str$[rbp-128]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 527  :                 return static_cast<int_type>(_Str.front());

	movsx	ebx, BYTE PTR [rax]
	jmp	SHORT $LN24@uflow
$LN227@uflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR _Str$[rbp-104], 15
	cmova	rax, QWORD PTR _Str$[rbp-128]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 514  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

	mov	rcx, QWORD PTR _Src$47[rbp-128]
	sub	rbx, rcx
	add	rbx, rax

; 515  :                     while (0 < _Nleft) {

	test	rbx, rbx
	jle	SHORT $LN262@uflow
	npad	9
$LL243@uflow:

; 516  :                         _CSTD ungetc(_Src[--_Nleft], _Myfile);

	dec	rbx
	movsx	ecx, BYTE PTR [rbx+rcx]
	mov	rdx, QWORD PTR [rdi+128]
	call	QWORD PTR __imp_ungetc

; 515  :                     while (0 < _Nleft) {

	test	rbx, rbx
	jle	SHORT $LN262@uflow
	mov	rcx, QWORD PTR _Src$47[rbp-128]
	jmp	SHORT $LL243@uflow
$LN262@uflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

	movzx	ebx, BYTE PTR _Ch$49[rbp-128]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 519  :                     return _Traits::to_int_type(_Ch);

	jmp	$LN24@uflow
$LN51@uflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN43@uflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 533  :     }

	mov	eax, ebx
$LN1@uflow:
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-128]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
$LN264@uflow:
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Src$47 = 64
_Dest$48 = 72
_Ch$49 = 80
_Str$ = 88
__$ArrayPad$ = 120
this$ = 144
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
	lea	rcx, QWORD PTR _Str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT

; 466  :     int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

$LN39:
	push	rbx
	sub	rsp, 32					; 00000020H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

	mov	rax, QWORD PTR [rcx+56]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 466  :     int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

	mov	rbx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

	mov	rcx, QWORD PTR [rax]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 468  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

	test	rcx, rcx
	je	SHORT $LN2@underflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 196  :         return *_IGnext + *_IGcount;

	mov	rax, QWORD PTR [rbx+80]
	movsxd	rdx, DWORD PTR [rax]
	add	rdx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 468  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

	cmp	rcx, rdx
	jae	SHORT $LN2@underflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [rcx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 476  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@underflow:

; 469  :             return _Traits::to_int_type(*_Mysb::gptr()); // return buffered
; 470  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+48], rdi
	call	QWORD PTR [rax+56]
	mov	edi, eax
	cmp	eax, -1
	jne	SHORT $LN4@underflow
	mov	rdi, QWORD PTR [rsp+48]

; 476  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@underflow:

; 471  :             return _Meta; // uflow failed, return EOF
; 472  :         } else { // get a char, don't point past it
; 473  :             pbackfail(_Meta);

	mov	rax, QWORD PTR [rbx]
	mov	edx, edi
	mov	rcx, rbx
	call	QWORD PTR [rax+32]

; 474  :             return _Meta;

	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+48]

; 476  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 48
_Meta$ = 56
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT

; 445  :     int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

$LN110:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

	mov	rax, QWORD PTR [rcx+56]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 445  :     int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

	mov	rbx, rcx
	mov	edi, edx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

	mov	rcx, QWORD PTR [rax]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 448  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	test	rcx, rcx
	je	SHORT $LN2@pbackfail
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	rax, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 448  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN2@pbackfail
	cmp	edx, -1
	je	SHORT $LN4@pbackfail
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 518  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [rcx-1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 448  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	eax, edx
	jne	SHORT $LN2@pbackfail
$LN4@pbackfail:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 217  :         ++*_IGcount;

	mov	rax, QWORD PTR [rbx+80]
	inc	DWORD PTR [rax]

; 218  :         return --*_IGnext;

	mov	rax, QWORD PTR [rbx+56]
	dec	QWORD PTR [rax]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 452  :             return _Traits::not_eof(_Meta);

	xor	eax, eax
	cmp	edi, -1
	cmove	edi, eax
$LN107@pbackfail:

; 461  :         } else {
; 462  :             return _Traits::eof(); // nowhere to put back
; 463  :         }
; 464  :     }

	mov	eax, edi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@pbackfail:

; 453  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

	mov	rdx, QWORD PTR [rbx+128]
	test	rdx, rdx
	je	SHORT $LN7@pbackfail
	cmp	edi, -1
	je	SHORT $LN7@pbackfail

; 454  :             return _Traits::eof(); // no open C stream or EOF, fail
; 455  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

	cmp	QWORD PTR [rbx+104], 0
	jne	SHORT $LN96@pbackfail

; 136  :     return _CSTD ungetc(static_cast<unsigned char>(_Byte), _File) != EOF;

	movzx	ecx, dil
	call	QWORD PTR __imp_ungetc

; 454  :             return _Traits::eof(); // no open C stream or EOF, fail
; 455  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

	cmp	eax, -1
	jne	SHORT $LN107@pbackfail
$LN96@pbackfail:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 184  :         return *_IGnext;

	mov	r9, QWORD PTR [rbx+56]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 457  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

	lea	rdx, QWORD PTR [rbx+112]
	cmp	QWORD PTR [r9], rdx
	je	SHORT $LN7@pbackfail
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	r10, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 766  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

	lea	r8, QWORD PTR [rbx+80]

; 458  :             _Mychar = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [rdx], dil
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	rax, QWORD PTR [r10]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 766  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

	cmp	rax, rdx
	je	SHORT $LN95@pbackfail

; 767  :             _Set_eback = _Mysb::eback();

	mov	QWORD PTR [rbx+136], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 196  :         return *_IGnext + *_IGcount;

	mov	rax, QWORD PTR [r8]
	movsxd	rcx, DWORD PTR [rax]
	add	rcx, QWORD PTR [r9]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 768  :             _Set_egptr = _Mysb::egptr();

	mov	QWORD PTR [rbx+144], rcx
$LN95@pbackfail:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [r10], rdx

; 208  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rbx+56]

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	ebx, edx
	add	ebx, 113				; 00000071H
	mov	QWORD PTR [rax], rdx
	mov	rax, QWORD PTR [r8]
	mov	DWORD PTR [rax], ebx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 460  :             return _Meta;

	mov	eax, edi

; 461  :         } else {
; 462  :             return _Traits::eof(); // nowhere to put back
; 463  :         }
; 464  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN7@pbackfail:
	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, -1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
_Dest$ = 64
_Src$ = 72
_Ch$ = 80
_Str$ = 88
__$ArrayPad$ = 120
this$ = 144
_Meta$ = 152
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT

; 392  :     int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

$LN89:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	edi, edx
	mov	rbx, rcx

; 393  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

	cmp	edx, -1
	jne	SHORT $LN4@overflow

; 394  :             return _Traits::not_eof(_Meta); // EOF, return success code

	xor	eax, eax
	jmp	$LN1@overflow
$LN4@overflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 192  :         return *_IPnext;

	mov	rax, QWORD PTR [rcx+64]
	mov	rdx, QWORD PTR [rax]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 397  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

	test	rdx, rdx
	je	SHORT $LN5@overflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 213  :         return *_IPnext + *_IPcount;

	mov	rax, QWORD PTR [rcx+88]
	movsxd	r8, DWORD PTR [rax]
	lea	rcx, QWORD PTR [rdx+r8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 397  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

	cmp	rdx, rcx
	jae	SHORT $LN5@overflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 256  :         --*_IPcount;

	lea	ecx, DWORD PTR [r8-1]
	mov	DWORD PTR [rax], ecx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 399  :             return _Meta;

	mov	eax, edi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 257  :         return (*_IPnext)++;

	mov	rdx, QWORD PTR [rbx+64]
	mov	r8, QWORD PTR [rdx]
	lea	rcx, QWORD PTR [r8+1]
	mov	QWORD PTR [rdx], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 398  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [r8], dil

; 399  :             return _Meta;

	jmp	$LN1@overflow
$LN5@overflow:

; 400  :         }
; 401  : 
; 402  :         if (!_Myfile) {

	cmp	QWORD PTR [rbx+128], 0
	mov	QWORD PTR [rsp+160], rsi
	je	$LN11@overflow
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	r8, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rbx+112]
	cmp	QWORD PTR [r8], rax
	jne	SHORT $LN52@overflow

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rcx, QWORD PTR [rbx+136]
	mov	rdx, QWORD PTR [rbx+144]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [r8], rcx

; 208  :         *_IGnext  = _Next;
; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], edx
$LN52@overflow:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 407  :         if (!_Pcvt) { // no codecvt facet, put as is

	mov	rcx, QWORD PTR [rbx+104]
	test	rcx, rcx
	jne	SHORT $LN7@overflow

; 114  :     return _CSTD fputc(_Byte, _File) != EOF;

	mov	rdx, QWORD PTR [rbx+128]
	movsx	ecx, dil
	call	QWORD PTR __imp_fputc

; 408  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

	mov	ecx, -1
	cmp	eax, ecx
	cmovne	ecx, edi
	mov	eax, ecx
	jmp	$LN86@overflow
$LN7@overflow:

; 409  :         }
; 410  : 
; 411  :         // put using codecvt facet
; 412  :         constexpr size_t _Codecvt_temp_buf = 32;
; 413  :         char _Str[_Codecvt_temp_buf];
; 414  :         const _Elem _Ch = _Traits::to_char_type(_Meta);
; 415  :         const _Elem* _Src;
; 416  :         char* _Dest;
; 417  : 
; 418  :         // test result of converting one element
; 419  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf, _Dest)) {

	lea	rax, QWORD PTR _Dest$[rsp]
	mov	BYTE PTR _Ch$[rsp], dil
	mov	QWORD PTR [rsp+56], rax
	lea	rdx, QWORD PTR [rbx+116]
	lea	rax, QWORD PTR _Str$[rsp+32]
	mov	QWORD PTR [rsp+48], rax
	lea	r9, QWORD PTR _Ch$[rsp+1]
	lea	rax, QWORD PTR _Str$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	r8, QWORD PTR _Ch$[rsp]
	lea	rax, QWORD PTR _Src$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
	test	eax, eax
	je	SHORT $LN8@overflow
	sub	eax, 1
	je	SHORT $LN8@overflow
	cmp	eax, 2
	jne	SHORT $LN11@overflow

; 114  :     return _CSTD fputc(_Byte, _File) != EOF;

	movsx	ecx, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR [rbx+128]
	call	QWORD PTR __imp_fputc

; 434  :             }
; 435  : 
; 436  :         case codecvt_base::noconv:
; 437  :             // no conversion, put as is
; 438  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

	mov	ecx, -1
	cmp	eax, ecx
	cmovne	ecx, edi
	mov	eax, ecx
	jmp	SHORT $LN86@overflow
$LN8@overflow:

; 420  :         case codecvt_base::partial:
; 421  :         case codecvt_base::ok:
; 422  :             { // converted something, try to put it out
; 423  :                 const auto _Count = static_cast<size_t>(_Dest - _Str);

	mov	rsi, QWORD PTR _Dest$[rsp]
	lea	rax, QWORD PTR _Str$[rsp]
	sub	rsi, rax

; 424  :                 if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

	je	SHORT $LN10@overflow
	mov	r9, QWORD PTR [rbx+128]
	lea	rcx, QWORD PTR _Str$[rsp]
	mov	r8, rsi
	mov	edx, 1
	call	QWORD PTR __imp_fwrite
	cmp	rsi, rax
	jne	SHORT $LN11@overflow
$LN10@overflow:

; 425  :                     return _Traits::eof(); // write failed
; 426  :                 }
; 427  : 
; 428  :                 _Wrotesome = true; // write succeeded
; 429  :                 if (_Src != &_Ch) {

	lea	rax, QWORD PTR _Ch$[rsp]
	mov	BYTE PTR [rbx+113], 1
	cmp	QWORD PTR _Src$[rsp], rax
	mov	ecx, -1
	cmovne	ecx, edi

; 430  :                     return _Meta; // converted whole element

	mov	eax, ecx
	jmp	SHORT $LN86@overflow
$LN11@overflow:

; 431  :                 }
; 432  : 
; 433  :                 return _Traits::eof(); // conversion failed

	mov	eax, -1
$LN86@overflow:
	mov	rsi, QWORD PTR [rsp+160]
$LN1@overflow:

; 439  : 
; 440  :         default:
; 441  :             return _Traits::eof(); // conversion failed
; 442  :         }
; 443  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT

; 381  :         if (_Myfile) {

	mov	rcx, QWORD PTR [rcx+128]
	test	rcx, rcx
	je	SHORT $LN2@Unlock

; 382  :             _CSTD _unlock_file(_Myfile);

	rex_jmp	QWORD PTR __imp__unlock_file
$LN2@Unlock:

; 383  :         }
; 384  :     }

	ret	0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT

; 375  :         if (_Myfile) {

	mov	rcx, QWORD PTR [rcx+128]
	test	rcx, rcx
	je	SHORT $LN2@Lock

; 376  :             _CSTD _lock_file(_Myfile);

	rex_jmp	QWORD PTR __imp__lock_file
$LN2@Lock:

; 377  :         }
; 378  :     }

	ret	0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT

; 175  :     __CLR_OR_THIS_CALL ~basic_filebuf() noexcept override {

$LN22:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rcx], rax

; 176  :         if (_Myfile) {

	cmp	QWORD PTR [rcx+128], 0
	je	SHORT $LN16@basic_file
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	rcx, QWORD PTR [rcx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rbx+112]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN16@basic_file

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	r8, QWORD PTR [rbx+144]
	mov	rdx, QWORD PTR [rbx+136]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [rcx], rdx

; 208  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rdx

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	r8d, edx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], r8d
$LN16@basic_file:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 180  :         if (_Closef) {

	cmp	BYTE PTR [rbx+124], 0
	je	SHORT $LN3@basic_file

; 181  :             close();

	mov	rcx, rbx
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN3@basic_file:

; 182  :         }
; 183  :     }

	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Document.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Document.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Document.h
;	COMDAT ??0Document@Json@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0Document@Json@@QEAA@$$QEAV01@@Z PROC			; Json::Document::Document, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Document.h

; 20   : 		Document(Document&&) = default;

	mov	rax, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Document.h

; 20   : 		Document(Document&&) = default;

	ret	0
??0Document@Json@@QEAA@$$QEAV01@@Z ENDP			; Json::Document::Document
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rcx], xmm0
	ret	0
?__autoclassinit2@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rdi, QWORD PTR [rcx-176]
	mov	ebx, edx
	mov	rcx, rdi
	call	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	test	bl, 1
	je	SHORT $LN5@scalar
	mov	edx, 272				; 00000110H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN5@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN29:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
	mov	rbx, rcx

; 175  :     __CLR_OR_THIS_CALL ~basic_filebuf() noexcept override {

	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rcx], rax

; 176  :         if (_Myfile) {

	cmp	QWORD PTR [rcx+128], 0
	je	SHORT $LN22@scalar
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	r8, QWORD PTR [rcx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rcx+112]
	cmp	QWORD PTR [r8], rax
	jne	SHORT $LN22@scalar

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rcx+144]
	mov	rcx, QWORD PTR [rcx+136]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [r8], rcx

; 208  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rcx

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], edx
$LN22@scalar:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 180  :         if (_Closef) {

	cmp	BYTE PTR [rbx+124], 0
	je	SHORT $LN7@scalar

; 181  :             close();

	mov	rcx, rbx
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$LN7@scalar:

; 182  :         }
; 183  :     }

	mov	rcx, rbx
	call	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
	test	dil, 1
	je	SHORT $LN26@scalar
	mov	edx, 152				; 00000098H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN26@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3245 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

$LN58:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, r8
	mov	r9, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

	mov	r8, -1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3245 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	mov	rbx, rcx
	xor	edi, edi
	npad	4
$LL54@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

	inc	r8
	cmp	BYTE PTR [rax+r8], dil
	jne	SHORT $LL54@operator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1534 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rax
	mov	rcx, r9
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rbx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rbx+16], rdi

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rbx+24], rdi

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rax]
	vmovups	YMMWORD PTR [rbx], ymm0

; 3246 :     return _STD move(_Left.append(_Right));

	mov	BYTE PTR [rax], dil
	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	rax, rbx
	vzeroupper

; 3247 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
_TEXT	SEGMENT
_RNext$ = 8
_UVal$ = 16
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z PROC	; std::_UIntegral_to_buff<char,unsigned int>, COMDAT

; 2754 : _NODISCARD _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { // used by both to_string and thread::id output

	mov	r8d, edx
	npad	13
$LL4@UIntegral_:

; 2755 :     // format _UVal into buffer *ending at* _RNext
; 2756 :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 2757 : 
; 2758 : #ifdef _WIN64
; 2759 :     auto _UVal_trunc = _UVal;
; 2760 : #else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv
; 2761 : 
; 2762 :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 2763 :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 2764 :         while (_UVal > 0xFFFFFFFFU) {
; 2765 :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 2766 :             _UVal /= 1000000000;
; 2767 : 
; 2768 :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 2769 :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 2770 :                 _UVal_chunk /= 10;
; 2771 :             }
; 2772 :         }
; 2773 :     }
; 2774 : 
; 2775 :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 2776 : #endif // ^^^ !defined(_WIN64) ^^^
; 2777 : 
; 2778 :     do {
; 2779 :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	rcx
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	r9d, DWORD PTR [rax+rdx]
	add	r9b, r9b
	sub	r8b, r9b
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [rcx], r8b

; 2780 :         _UVal_trunc /= 10;

	mov	r8d, edx

; 2781 :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL4@UIntegral_

; 2782 :     return _RNext;

	mov	rax, rcx

; 2783 : }

	ret	0
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ENDP	; std::_UIntegral_to_buff<char,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z PROC	; std::_Get_unwrapped<char * &>, COMDAT

; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);
; 1387 :     }
; 1388 : }

	ret	0
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ENDP	; std::_Get_unwrapped<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Last$ = 112
_Al$dead$ = 120
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>, COMDAT

; 799  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN119:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	esi, esi

; 799  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, r8
	mov	r14, rdx
	mov	rbx, rcx
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rsi

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rsi

; 800  :         _STD _Adl_verify_range(_First, _Last);
; 801  :         auto _UFirst = _STD _Get_unwrapped(_First);
; 802  :         auto _ULast  = _STD _Get_unwrapped(_Last);
; 803  :         if (_UFirst == _ULast) {

	cmp	rdx, r8
	jne	SHORT $LN2@allocator

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 817  :     }

	mov	rax, rcx

; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], sil

; 817  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN2@allocator:

; 804  :             _Construct_empty();
; 805  :         } else {
; 806  :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 807  :                 _Construct<_Construct_strategy::_From_ptr>(

	sub	rdi, r14

; 881  :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdi, rbp
	ja	$LN116@allocator

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

	cmp	rdi, 15
	ja	SHORT $LN22@allocator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 890  :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rdi

; 891  :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 817  :     }

	mov	rax, rbx

; 898  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rbx+rdi], sil

; 817  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN22@allocator:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rdi
	or	rax, 15
	cmp	rax, rbp

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN32@allocator

; 2980 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN57@allocator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN58@allocator
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN32@allocator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	je	SHORT $LN49@allocator

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN52@allocator

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN117@allocator
	jmp	SHORT $LN57@allocator
$LN58@allocator:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rsi, QWORD PTR [rax+39]
	and	rsi, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rsi-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN49@allocator
$LN52@allocator:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
$LN49@allocator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rbx], rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 915  :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 916  :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 817  :     }

	mov	rax, rbx

; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rsi+rdi], 0

; 817  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN116@allocator:

; 882  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN117@allocator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN114@allocator:
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ
_TEXT	SEGMENT
_Lock$1 = 32
__$ArrayPad$ = 40
this$ = 64
??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ PROC		; std::locale::id::_Get_index<0>, COMDAT

; 90   :         size_t _Get_index() { // get stamp, with lazy allocation

$LN10:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 91   :             if (_Id == 0) { // still zero, allocate stamp

	cmp	QWORD PTR [rcx], 0
	mov	rbx, rcx
	jne	SHORT $LN5@Get_index

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 93   :                 if (_Id == 0) {

	cmp	QWORD PTR [rbx], 0
	jne	SHORT $LN3@Get_index

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	rax, QWORD PTR __imp_?_Id_cnt@id@locale@std@@0HA
	inc	DWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax]
	mov	QWORD PTR [rbx], rax
$LN3@Get_index:

; 95   :                 }
; 96   :                 _END_LOCK()

	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ

; 97   :             }
; 98   :             return _Id;

	mov	rax, QWORD PTR [rbx]

; 99   :         }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN5@Get_index:

; 97   :             }
; 98   :             return _Id;

	mov	rax, QWORD PTR [rcx]

; 99   :         }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$_Get_index@$0A@@id@locale@std@@QEAA_KXZ ENDP		; std::locale::id::_Get_index<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3370 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 64
_Count$ = 72
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2294 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN26:
	sub	rsp, 56					; 00000038H

; 2295 : #if _HAS_CXX23
; 2296 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2297 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2298 :         _Count                  = _Allocated;
; 2299 :         return _Ptr;
; 2300 :     } else
; 2301 : #endif // _HAS_CXX23
; 2302 :     {
; 2303 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN6@Allocate_a

; 228  :         return nullptr;

	xor	eax, eax

; 2304 :     }
; 2305 : }

	add	rsp, 56					; 00000038H
	ret	0
$LN6@Allocate_a:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@Allocate_a

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN25@Allocate_a

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN14@Allocate_a
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN14@Allocate_a:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2304 :     }
; 2305 : }

	add	rsp, 56					; 00000038H
	ret	0
$LN8@Allocate_a:
	add	rsp, 56					; 00000038H

; 136  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN25@Allocate_a:

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN23@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@D$$V@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@D$$V@std@@YAPEADQEAD@Z PROC		; std::construct_at<char>, COMDAT

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	BYTE PTR [rcx], al
	mov	rax, rcx

; 464  : }

	ret	0
??$construct_at@D$$V@std@@YAPEADQEAD@Z ENDP		; std::construct_at<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &>, COMDAT

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 464  : }

	ret	0
??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$skipWhitespace@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
_TEXT	SEGMENT
input$ = 8
i$ = 16
??$skipWhitespace@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z PROC ; Json::Parser::skipWhitespace<MappedFile<0> >, COMDAT

; 372  : #ifdef HAS_AVX2
; 373  : 			return skipWhitespaceSIMD16(input, i);

	jmp	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >
??$skipWhitespace@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ENDP ; Json::Parser::skipWhitespace<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
_TEXT	SEGMENT
$T5 = 48
$T40 = 48
$T65 = 48
__$ReturnUdt$GSCopy$ = 48
$T89 = 48
$T3 = 56
$T111 = 56
$T38 = 56
$T63 = 56
$T88 = 56
$T109 = 96
$T110 = 128
__$ReturnUdt$ = 192
input$ = 200
i$ = 208
??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z PROC ; Json::Parser::parseValue<MappedFile<0> >, COMDAT

; 547  : 		{

$LN388:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	r10, r8
	mov	r9, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	esi, esi
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	r8, QWORD PTR [r8]
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 548  : 			char c = input[i];

	mov	rcx, QWORD PTR [rdx]
	movsx	rbx, BYTE PTR [r8+rcx]

; 549  : 			if (c == beginObject) {

	cmp	bl, 123					; 0000007bH
	jne	SHORT $LN2@parseValue

; 550  : 				return parseObject(input, i);

	mov	r8, r10
	mov	rcx, rdi
	call	??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseObject<MappedFile<0> >

; 576  : 		}

	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN2@parseValue:

; 551  : 			}
; 552  : 			else if (c == beginArray) {

	cmp	bl, 91					; 0000005bH
	jne	SHORT $LN4@parseValue

; 553  : 				return parseArray(input, i);

	mov	r8, r10
	mov	rcx, rdi
	call	??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseArray<MappedFile<0> >

; 576  : 		}

	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN4@parseValue:

; 554  : 			}
; 555  : 			else if (c == stringStart) {

	cmp	bl, 34					; 00000022H
	jne	$LN6@parseValue

; 556  : 				return std::make_unique<String>(parseString(input, i));

	mov	r8, r10
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseString<MappedFile<0> >
	mov	rbx, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 40					; 00000028H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T5[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	lea	rcx, OFFSET FLAT:??_7String@Json@@6B@
	mov	QWORD PTR [rax], rcx
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rax+8], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rax+24], rsi

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rax+32], rsi

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	YMMWORD PTR [rax+8], ymm0

; 1287 : 
; 1288 :                 _Right_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 1289 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 1290 :                 _Right_data._Activate_SSO_buffer();
; 1291 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T3[rsp+24]
	cmp	rdx, 15

; 3083 :         if (_My_data._Large_mode_engaged()) {

	jbe	$LN384@parseValue

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T3[rsp]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN125@parseValue

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN125@parseValue
	mov	QWORD PTR [rsp+32], rsi
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	vzeroupper
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN125@parseValue:

; 289  :         ::operator delete(_Ptr, _Bytes);

	vzeroupper
	call	??3@YAXPEAX_K@Z				; operator delete
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 576  : 		}

	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN6@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	r11, OFFSET FLAT:?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::trueLiteral

; 445  :         if (_Large_mode_engaged()) {

	mov	rax, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 558  : 			else if (c == trueLiteral[0]) {

	cmp	bl, BYTE PTR [rax]
	jne	$LN8@parseValue

; 436  : 			++i;

	inc	r8
	mov	QWORD PTR [r10], r8

; 437  : 			for (size_t j = 1; j < trueLiteral.size() && i < input.size(); ++j, ++i) {

	mov	eax, 1
	cmp	rax, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jae	SHORT $LN144@parseValue
$LL145@parseValue:
	cmp	r8, QWORD PTR [r9+8]
	jae	SHORT $LN144@parseValue
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rdx, QWORD PTR [r9]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rcx, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 438  : 				if (input[i] != trueLiteral[j]) {

	movzx	ecx, BYTE PTR [rcx+rax]
	cmp	BYTE PTR [rdx+r8], cl
	jne	$LN358@parseValue

; 437  : 			for (size_t j = 1; j < trueLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rax
	inc	r8
	mov	QWORD PTR [r10], r8
	cmp	rax, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL145@parseValue
$LN144@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T40[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Bool@Json@@6B@
	mov	QWORD PTR [rax], rcx
	mov	BYTE PTR [rax+8], 1
$LN385@parseValue:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 576  : 		}

	mov	QWORD PTR [rdi], rax
$LN384@parseValue:
	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN8@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	r11, OFFSET FLAT:?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::falseLiteral

; 445  :         if (_Large_mode_engaged()) {

	mov	rax, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 561  : 			else if (c == falseLiteral[0]) {

	cmp	bl, BYTE PTR [rax]
	jne	SHORT $LN10@parseValue

; 448  : 			++i;

	inc	r8
	mov	QWORD PTR [r10], r8

; 449  : 			for (size_t j = 1; j < falseLiteral.size() && i < input.size(); ++j, ++i) {

	mov	eax, 1
	cmp	rax, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jae	SHORT $LN214@parseValue
$LL215@parseValue:
	cmp	r8, QWORD PTR [r9+8]
	jae	SHORT $LN214@parseValue
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rdx, QWORD PTR [r9]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rcx, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 450  : 				if (input[i] != falseLiteral[j]) {

	movzx	ecx, BYTE PTR [rcx+rax]
	cmp	BYTE PTR [rdx+r8], cl
	jne	$LN359@parseValue

; 449  : 			for (size_t j = 1; j < falseLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rax
	inc	r8
	mov	QWORD PTR [r10], r8
	cmp	rax, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL215@parseValue
$LN214@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T65[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Bool@Json@@6B@
	mov	QWORD PTR [rax], rcx
	mov	BYTE PTR [rax+8], sil
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 562  : 				return parseBoolFalse(input, i);

	jmp	$LN385@parseValue
$LN10@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	r11, OFFSET FLAT:?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::nullLiteral

; 445  :         if (_Large_mode_engaged()) {

	mov	rax, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 564  : 			else if (c == nullLiteral[0]) {

	cmp	bl, BYTE PTR [rax]
	jne	SHORT $LN12@parseValue

; 460  : 			++i;

	inc	r8
	mov	QWORD PTR [r10], r8

; 461  : 			for (size_t j = 1; j < nullLiteral.size() && i < input.size(); ++j, ++i) {

	mov	eax, 1
	cmp	rax, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jae	SHORT $LN284@parseValue
$LL285@parseValue:
	cmp	r8, QWORD PTR [r9+8]
	jae	SHORT $LN284@parseValue
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rdx, QWORD PTR [r9]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rcx, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 462  : 				if (input[i] != nullLiteral[j]) {

	movzx	ecx, BYTE PTR [rcx+rax]
	cmp	BYTE PTR [rdx+r8], cl
	jne	SHORT $LN360@parseValue

; 461  : 			for (size_t j = 1; j < nullLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rax
	inc	r8
	mov	QWORD PTR [r10], r8
	cmp	rax, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL285@parseValue
$LN284@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 8
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T89[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h

; 9    : 		Null() : Value() {};

	lea	rcx, OFFSET FLAT:??_7Null@Json@@6B@
	mov	QWORD PTR [rax], rcx
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 565  : 				return parseNull(input, i);

	jmp	$LN385@parseValue
$LN12@parseValue:

; 566  : 			}
; 567  : 			else if (c == numberStartCharacters[11]
; 568  : 				|| c == numberStartCharacters[10]
; 569  : 				|| (c >= numberStartCharacters[0]

	cmp	bl, 57					; 00000039H
	ja	SHORT $LN14@parseValue
	mov	rcx, 287992881640112128			; 03ff280000000000H
	bt	rcx, rbx
	jae	SHORT $LN14@parseValue

; 570  : 					&& c <= numberStartCharacters[9])) {
; 571  : 				return parseNumber(input, i);

	mov	r8, r10
	mov	rcx, rdi
	call	??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseNumber<MappedFile<0> >

; 576  : 		}

	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN360@parseValue:

; 463  : 					throw std::runtime_error("Invalid null literal");

	lea	rdx, OFFSET FLAT:??_C@_0BF@GONMNCPG@Invalid?5null?5literal@
	lea	rcx, QWORD PTR $T88[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T88[rsp]
	call	_CxxThrowException
	int	3
$LN14@parseValue:

; 572  : 			}
; 573  : 			else {
; 574  : 				throw std::runtime_error(std::string("Invalid value syntax: ") + c);

	lea	rdx, OFFSET FLAT:??_C@_0BH@HJFABALL@Invalid?5value?5syntax?3?5@
	lea	rcx, QWORD PTR $T109[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	movzx	r8d, bl
	mov	rdx, rax
	lea	rcx, QWORD PTR $T110[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T111[rsp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T111[rsp]
	call	_CxxThrowException
	npad	1
$LN358@parseValue:

; 439  : 					throw std::runtime_error("Invalid bool true literal");

	lea	rdx, OFFSET FLAT:??_C@_0BK@GDBLDPAM@Invalid?5bool?5true?5literal@
	lea	rcx, QWORD PTR $T38[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T38[rsp]
	call	_CxxThrowException
	int	3
$LN359@parseValue:

; 451  : 					throw std::runtime_error("Invalid bool false literal");

	lea	rdx, OFFSET FLAT:??_C@_0BL@MHJMKGJM@Invalid?5bool?5false?5literal@
	lea	rcx, QWORD PTR $T63[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T63[rsp]
	call	_CxxThrowException
	int	3
$LN383@parseValue:
??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ENDP ; Json::Parser::parseValue<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T40 = 48
$T65 = 48
__$ReturnUdt$GSCopy$ = 48
$T89 = 48
$T3 = 56
$T111 = 56
$T38 = 56
$T63 = 56
$T88 = 56
$T109 = 96
$T110 = 128
__$ReturnUdt$ = 192
input$ = 200
i$ = 208
?dtor$1@?0???$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseValue<MappedFile<0> >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseValue<MappedFile<0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T40 = 48
$T65 = 48
__$ReturnUdt$GSCopy$ = 48
$T89 = 48
$T3 = 56
$T111 = 56
$T38 = 56
$T63 = 56
$T88 = 56
$T109 = 96
$T110 = 128
__$ReturnUdt$ = 192
input$ = 200
i$ = 208
?dtor$3@?0???$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseValue<MappedFile<0> >'::`1'::dtor$3
	lea	rcx, QWORD PTR $T109[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseValue<MappedFile<0> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 48
$T40 = 48
$T65 = 48
__$ReturnUdt$GSCopy$ = 48
$T89 = 48
$T3 = 56
$T111 = 56
$T38 = 56
$T63 = 56
$T88 = 56
$T109 = 96
$T110 = 128
__$ReturnUdt$ = 192
input$ = 200
i$ = 208
?dtor$4@?0???$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseValue<MappedFile<0> >'::`1'::dtor$4
	lea	rcx, QWORD PTR $T110[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseValue<MappedFile<0> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z PROC ; std::move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1514 : }

	ret	0
??$move@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z ENDP ; std::move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::emplace_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 844  :         if (_Mylast != _My_data._Myend) {

	mov	r9, QWORD PTR [rcx+8]
	cmp	r9, QWORD PTR [rcx+16]
	je	SHORT $LN4@emplace_ba

; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rdx]

; 861  :         } else {
; 862  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 863  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 864  :             _ASAN_VECTOR_RELEASE_GUARD;
; 865  :         }
; 866  : 
; 867  :         _Orphan_range(_Mylast, _Mylast);
; 868  :         _Ty& _Result = *_Mylast;

	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [r9], rax
	mov	rax, QWORD PTR [rcx+8]

; 869  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 923  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 924  :         _Ty& _Result = _Emplace_one_at_back(_STD forward<_Valty>(_Val)...);
; 925  : #if _HAS_CXX17
; 926  :         return _Result;
; 927  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 928  :         (void) _Result;
; 929  : #endif // ^^^ !_HAS_CXX17 ^^^
; 930  :     }

	ret	0
$LN4@emplace_ba:

; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, r9
	jmp	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
??$emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::emplace_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QEA_NAEA_N@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@_N@std@@YA$$QEA_NAEA_N@Z PROC		; std::forward<bool>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@_N@std@@YA$$QEA_NAEA_N@Z ENDP		; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>, COMDAT

; 547  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

$LN139:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r15, r8
	mov	r12, rdx
	mov	rsi, rcx

; 548  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 549  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 550  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx

; 553  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	mov	rax, QWORD PTR [rcx]
	movsxd	r9, DWORD PTR [rax+4]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 278  :         return _Wide;

	mov	rdi, QWORD PTR [r9+rcx+40]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 553  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	test	rdi, rdi
	jle	SHORT $LN10@Insert_str
	cmp	rdi, r8
	jbe	SHORT $LN10@Insert_str

; 555  :     } else {
; 556  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

	sub	rdi, r8
	jmp	SHORT $LN9@Insert_str
$LN10@Insert_str:

; 554  :         _Pad = 0;

	xor	edi, edi
$LN9@Insert_str:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	r14, rsi
	mov	QWORD PTR _Ok$[rsp], rsi

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rcx, QWORD PTR [r9+rcx+72]

; 71   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN90@Insert_str

; 72   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN90@Insert_str:

; 91   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	jne	SHORT $LN84@Insert_str

; 92   :                 _Ok = false;

	mov	BYTE PTR _Ok$[rsp+8], al

; 93   :                 return;

	jmp	SHORT $LN83@Insert_str
$LN84@Insert_str:

; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rsi+80]

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

	test	rcx, rcx
	je	SHORT $LN86@Insert_str
	cmp	rcx, rsi
	je	SHORT $LN86@Insert_str

; 99   :                 return;
; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	mov	BYTE PTR _Ok$[rsp+8], al
	jmp	SHORT $LN83@Insert_str
$LN86@Insert_str:

; 98   :                 _Ok = true;

	mov	BYTE PTR _Ok$[rsp+8], 1
	mov	al, 1
$LN83@Insert_str:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 561  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN11@Insert_str

; 562  :         _State |= _Ostr_t::badbit;

	mov	ebx, 4

; 563  :     } else { // state okay, insert characters

	jmp	$LN23@Insert_str
$LN11@Insert_str:

; 564  :         _TRY_IO_BEGIN
; 565  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

	mov	rdx, QWORD PTR [rsi]
	movsxd	rax, DWORD PTR [rdx+4]
	mov	ecx, DWORD PTR [rax+rsi+24]
	and	ecx, 448				; 000001c0H
	cmp	ecx, 64					; 00000040H
	je	SHORT $LN128@Insert_str
$LL4@Insert_str:

; 566  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	rdi, rdi
	je	SHORT $LN130@Insert_str

; 567  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	jne	SHORT $LN2@Insert_str

; 568  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	ebx, 4
	mov	DWORD PTR _State$[rsp], ebx
	npad	4
$LL7@Insert_str:

; 578  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	rdi, rdi
	je	SHORT $LN6@Insert_str

; 579  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	jne	SHORT $LN5@Insert_str

; 580  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	or	ebx, 4
$LN136@Insert_str:

; 581  :                     break;
; 582  :                 }
; 583  :             }
; 584  :         }
; 585  : 
; 586  :         _Ostr.width(0);

	mov	DWORD PTR _State$[rsp], ebx
$LN6@Insert_str:
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase

; 284  :         _Wide                      = _Newwidth;

	mov	QWORD PTR [rcx+rsi+40], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
	jmp	SHORT $LN23@Insert_str
$LN2@Insert_str:

; 566  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	rdi
	jmp	SHORT $LL4@Insert_str
$LN130@Insert_str:

; 569  :                     break;
; 570  :                 }
; 571  :             }
; 572  :         }
; 573  : 
; 574  :         if (_State == _Ostr_t::goodbit
; 575  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	mov	rdx, QWORD PTR [rsi]
$LN128@Insert_str:
	movsxd	rcx, DWORD PTR [rdx+4]
	mov	r8, r15
	mov	rdx, r12
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	cmp	rax, r15
	je	SHORT $LL7@Insert_str

; 576  :             _State |= _Ostr_t::badbit;

	mov	ebx, 4

; 577  :         } else {

	jmp	SHORT $LN136@Insert_str
$LN5@Insert_str:

; 578  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	rdi
	jmp	SHORT $LL7@Insert_str
$LN24@Insert_str:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xiosbase
	mov	rsi, QWORD PTR _Ostr$[rsp]
	mov	ebx, DWORD PTR _State$[rsp]
	mov	r14, QWORD PTR _Ok$[rsp]
$LN23@Insert_str:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 587  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 588  :     }
; 589  : 
; 590  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp

; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

	call	QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

	test	eax, eax
	jne	SHORT $LN26@Insert_str

; 117  :                 this->_Myostr._Osfx();

	mov	rcx, r14
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN26@Insert_str:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [r14]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+r14+72]

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN134@Insert_str

; 79   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN134@Insert_str:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 592  : }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?dtor$11@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$11
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$11@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Data$ = 104
_Size$ = 112
_State$ = 120
?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$17

; 587  :         _CATCH_IO_(_Ostr_t, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$17@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$17
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }

	ret	0
??$_Adl_verify_range@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@@std@@YAXAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@@std@@YA_NAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator==<char,std::char_traits<char> >, COMDAT

; 487  :     const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {

$LN48:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 437  :         if (!_Got) {

	cmp	BYTE PTR [rcx+8], 0

; 487  :     const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {

	mov	rbx, rdx
	mov	rdi, rcx

; 437  :         if (!_Got) {

	jne	SHORT $LN38@operator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN14@operator
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN14@operator

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [rdi+9], al
	jmp	SHORT $LN13@operator
$LN14@operator:

; 471  :             _Strbuf = nullptr;

	mov	QWORD PTR [rdi], 0
$LN13@operator:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR [rdi+8], 1
$LN38@operator:

; 441  :         if (!_Right._Got) {

	cmp	BYTE PTR [rbx+8], 0
	jne	SHORT $LN5@operator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN25@operator
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN25@operator

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [rbx+9], al
	jmp	SHORT $LN24@operator
$LN25@operator:

; 471  :             _Strbuf = nullptr;

	mov	QWORD PTR [rbx], 0
$LN24@operator:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR [rbx+8], 1
$LN5@operator:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	cmp	QWORD PTR [rdi], 0
	mov	rax, QWORD PTR [rbx]
	jne	SHORT $LN37@operator
	test	rax, rax
	je	SHORT $LN9@operator
$LN8@operator:

; 488  :     return _Left.equal(_Right);

	xor	al, al

; 489  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN37@operator:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	test	rax, rax
	je	SHORT $LN8@operator
$LN9@operator:

; 489  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	al, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?8DU?$char_traits@D@std@@@std@@YA_NAEBV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::move<std::istreambuf_iterator<char,std::char_traits<char> > &>, COMDAT

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1514 : }

	ret	0
??$move@AEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::move<std::istreambuf_iterator<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z
_TEXT	SEGMENT
_Guard$ = 48
this$ = 128
_First$ = 136
_Last$ = 144
_Count$dead$ = 152
??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>, COMDAT

; 932  :     _CONSTEXPR20 void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {}) {

$LN240:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	r12, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 933  :         // Pre: _Iter models input_iterator or meets the Cpp17InputIterator requirements.
; 934  :         // Pre: [_First, _Last) is a valid range.
; 935  :         // Pre: if _Iter models forward_iterator or meets the Cpp17ForwardIterator requirements,
; 936  :         //      then is_same_v<_Size, size_type> holds.
; 937  :         // Pre: if is_same_v<_Size, size_type>, _Count is the length of [_First, _Last).
; 938  :         // Pre: *this is in small mode; the lifetime of the SSO elements has already begun.
; 939  : 
; 940  :         auto& _My_data  = _Mypair._Myval2;
; 941  :         auto& _Al       = _Getal();
; 942  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 943  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 944  : 
; 945  :         _My_data._Mysize = 0;

	xor	r13d, r13d
	mov	QWORD PTR [rcx+16], r13

; 946  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 947  : 
; 948  :         if constexpr (is_same_v<_Size, size_type>) {
; 949  :             if (_Count > max_size()) {
; 950  :                 _Xlen_string(); // result too long
; 951  :             }
; 952  : 
; 953  :             if (_Count > _Small_string_capacity) {
; 954  :                 size_type _New_capacity = _Calculate_growth(_Count);
; 955  :                 const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 956  :                 _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 957  :                 _My_data._Myres = _New_capacity;
; 958  :             }
; 959  :         }
; 960  : 
; 961  :         _Tidy_deallocate_guard<basic_string> _Guard{this};

	mov	QWORD PTR _Guard$[rsp], rcx
	mov	rbx, QWORD PTR [rdx]
	lea	r14, QWORD PTR [rdx+9]
$LN237@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 437  :         if (!_Got) {

	mov	r15, 9223372036854775807		; 7fffffffffffffffH
	cmp	BYTE PTR [rdi+8], 0
	jne	SHORT $LN53@Construct_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	rbx, QWORD PTR [rdi]
	test	rbx, rbx
	je	SHORT $LN63@Construct_
	mov	rcx, rbx
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN63@Construct_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [r14], al
	jmp	SHORT $LN62@Construct_
$LN63@Construct_:

; 471  :             _Strbuf = nullptr;

	mov	QWORD PTR [rdi], r13
	mov	rbx, r13
$LN62@Construct_:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR [rdi+8], 1
$LN53@Construct_:

; 441  :         if (!_Right._Got) {

	cmp	BYTE PTR [r12+8], 0
	jne	SHORT $LN228@Construct_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	rcx, QWORD PTR [r12]
	test	rcx, rcx
	je	SHORT $LN74@Construct_
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN74@Construct_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [r12+9], al
	jmp	SHORT $LN73@Construct_
$LN74@Construct_:

; 471  :             _Strbuf = nullptr;

	mov	QWORD PTR [r12], r13
$LN73@Construct_:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR [r12+8], 1
$LN228@Construct_:

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	mov	rax, QWORD PTR [r12]
	test	rbx, rbx
	jne	SHORT $LN225@Construct_
	test	rax, rax
	jne	SHORT $LN57@Construct_
$LN58@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rcx, rsi

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rsi+24], 15
	jbe	SHORT $LN12@Construct_

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rsi]
$LN12@Construct_:

; 997  :             }
; 998  : 
; 999  :             _Elem* const _Ptr = _My_data._Myptr();
; 1000 :             _Traits::assign(_Ptr[_My_data._Mysize], _Elem());

	mov	rax, QWORD PTR [rsi+16]
	mov	BYTE PTR [rcx+rax], 0

; 1001 :         }
; 1002 : 
; 1003 :         _ASAN_STRING_CREATE(*this);
; 1004 :         _Guard._Target = nullptr;
; 1005 :         _Proxy._Release();
; 1006 :     }

	mov	rbx, QWORD PTR [rsp+152]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN225@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	test	rax, rax
	jne	SHORT $LN58@Construct_
$LN57@Construct_:
	mov	r14, QWORD PTR [rsi+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 974  :                     if (_My_data._Mysize == _My_data._Myres) { // Need to grow

	mov	rcx, QWORD PTR [rsi+16]
	cmp	rcx, r14
	jne	$LN226@Construct_

; 975  :                         if (_My_data._Mysize == max_size()) {

	cmp	rcx, r15
	je	$LN194@Construct_

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rbp, rsi

; 436  :         if (_Large_mode_engaged()) {

	cmp	r14, 15
	jbe	SHORT $LN230@Construct_

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbp, QWORD PTR [rsi]
$LN230@Construct_:

; 977  :                         }
; 978  : 
; 979  :                         _Elem* const _Old_ptr   = _My_data._Myptr();
; 980  :                         size_type _New_capacity = _Calculate_growth(_My_data._Mysize + 1);

	inc	rcx

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rcx, 15
	cmp	rcx, r15

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN124@Construct_
$LN236@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

	mov	r14, r15
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rcx, 39					; 00000027H
	jmp	SHORT $LN233@Construct_
$LN124@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, r14
	shr	rdx, 1
	mov	rax, r15
	sub	rax, rdx
	cmp	r14, rax
	ja	SHORT $LN236@Construct_

; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r14+rdx]
	mov	r14, rcx
	cmp	rcx, rax
	cmovb	r14, rax

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rax, QWORD PTR [r14+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rax, rax
	jne	SHORT $LN142@Construct_

; 228  :         return nullptr;

	mov	rbx, r13
	jmp	SHORT $LN141@Construct_
$LN142@Construct_:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN144@Construct_

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rax
	jbe	$LN195@Construct_
$LN233@Construct_:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN197@Construct_

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN141@Construct_
$LN144@Construct_:

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN141@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR [rsi+16]
	mov	rdx, rbp
	mov	rcx, rbx
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rsi+24]

; 981  :                         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 982  : 
; 983  :                         _Traits::copy(_Unfancy(_New_ptr), _Old_ptr, _My_data._Mysize);
; 984  :                         if (_My_data._Large_mode_engaged()) { // Need to deallocate old storage

	cmp	rdx, 15
	jbe	SHORT $LN7@Construct_

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rsi]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN187@Construct_

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	$LN197@Construct_

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN187@Construct_:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN7@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 990  :                         _My_data._Myres = _New_capacity;

	mov	QWORD PTR [rsi], rbx
	mov	QWORD PTR [rsi+24], r14
	mov	rbx, QWORD PTR [rdi]
$LN226@Construct_:

; 435  :         value_type* _Result = _Bx._Buf;

	mov	r15, rsi

; 436  :         if (_Large_mode_engaged()) {

	cmp	r14, 15
	jbe	SHORT $LN227@Construct_

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [rsi]
	mov	rbx, QWORD PTR [rdi]
$LN227@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 406  :         if (!_Got) {

	cmp	BYTE PTR [rdi+8], 0
	jne	SHORT $LN100@Construct_

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	rbx, QWORD PTR [rdi]
	test	rbx, rbx
	je	SHORT $LN220@Construct_
	mov	rcx, rbx
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN220@Construct_

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [rdi+9], al
	jmp	SHORT $LN100@Construct_
$LN220@Construct_:

; 471  :             _Strbuf = nullptr;

	mov	QWORD PTR [rdi], r13
	mov	rbx, r13
$LN100@Construct_:

; 414  :         return _Val;

	lea	r14, QWORD PTR [rdi+9]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 995  :                 _Traits::assign(_Ptr[_My_data._Mysize], *_First);

	mov	rcx, QWORD PTR [rsi+16]
	movzx	eax, BYTE PTR [r14]
	mov	BYTE PTR [r15+rcx], al

; 996  :                 ++_My_data._Mysize;

	inc	QWORD PTR [rsi+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

	test	rbx, rbx
	je	SHORT $LN229@Construct_
	mov	rcx, rbx
	call	QWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN229@Construct_

; 464  :             _Got = false;

	mov	BYTE PTR [rdi+8], 0
	jmp	$LN237@Construct_
$LN229@Construct_:

; 461  :             _Strbuf = nullptr;

	mov	QWORD PTR [rdi], r13

; 462  :             _Got    = true;

	mov	BYTE PTR [rdi+8], 1
	mov	rbx, r13

; 463  :         } else {

	jmp	$LN237@Construct_
$LN197@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	mov	QWORD PTR [rsp+32], r13
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN195@Construct_:

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN194@Construct_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 976  :                             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN235@Construct_:
??$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Guard$ = 48
this$ = 128
_First$ = 136
_Last$ = 144
_Count$dead$ = 152
?dtor$0@?0???$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>'::`1'::dtor$0
	lea	rcx, QWORD PTR _Guard$[rdx]
	jmp	??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
?dtor$0@?0???$_Construct_from_iter@V?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@V12@$$T@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@V21@$$T@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_from_iter<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,std::nullptr_t>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Left$ = 16
_Right$ = 24
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 299  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 300  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [r8]

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	QWORD PTR [rcx], rax

; 299  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 300  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	rax, rcx

; 301  :     }

	ret	0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,0>, COMDAT

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$skipWhitespace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
_TEXT	SEGMENT
input$ = 8
i$ = 16
??$skipWhitespace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z PROC ; Json::Parser::skipWhitespace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 372  : #ifdef HAS_AVX2
; 373  : 			return skipWhitespaceSIMD16(input, i);

	jmp	??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
??$skipWhitespace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ENDP ; Json::Parser::skipWhitespace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
_TEXT	SEGMENT
$T7 = 48
$T44 = 48
$T71 = 48
__$ReturnUdt$GSCopy$ = 48
$T97 = 48
$T5 = 56
$T119 = 56
$T42 = 56
$T69 = 56
$T96 = 56
$T117 = 96
$T118 = 128
__$ReturnUdt$ = 192
input$ = 200
i$ = 208
??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z PROC ; Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 547  : 		{

$LN420:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	r9, r8
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	esi, esi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rbx, rdx

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN28@parseValue

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rdx]
$LN28@parseValue:

; 2281 :         return _Mypair._Myval2._Myptr()[_Off];

	mov	r8, QWORD PTR [r8]
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 548  : 			char c = input[i];

	movsx	rbx, BYTE PTR [r8+rbx]

; 549  : 			if (c == beginObject) {

	cmp	bl, 123					; 0000007bH
	jne	SHORT $LN2@parseValue

; 550  : 				return parseObject(input, i);

	mov	r8, r9
	call	??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >

; 576  : 		}

	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN2@parseValue:

; 551  : 			}
; 552  : 			else if (c == beginArray) {

	cmp	bl, 91					; 0000005bH
	jne	SHORT $LN4@parseValue

; 553  : 				return parseArray(input, i);

	mov	r8, r9
	call	??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseArray<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >

; 576  : 		}

	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN4@parseValue:

; 554  : 			}
; 555  : 			else if (c == stringStart) {

	cmp	bl, 34					; 00000022H
	jne	$LN6@parseValue

; 556  : 				return std::make_unique<String>(parseString(input, i));

	mov	r8, r9
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z ; Json::Parser::parseString<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
	mov	rbx, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 40					; 00000028H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T7[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	lea	rcx, OFFSET FLAT:??_7String@Json@@6B@
	mov	QWORD PTR [rax], rcx
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rax+8], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rax+24], rsi

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rax+32], rsi

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	YMMWORD PTR [rax+8], ymm0

; 1287 : 
; 1288 :                 _Right_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 1289 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 1290 :                 _Right_data._Activate_SSO_buffer();
; 1291 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR $T5[rsp+24]
	cmp	rdx, 15

; 3083 :         if (_My_data._Large_mode_engaged()) {

	jbe	$LN416@parseValue

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rsp]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN133@parseValue

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN133@parseValue
	mov	QWORD PTR [rsp+32], rsi
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	vzeroupper
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN133@parseValue:

; 289  :         ::operator delete(_Ptr, _Bytes);

	vzeroupper
	call	??3@YAXPEAX_K@Z				; operator delete
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 576  : 		}

	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN6@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	r11, OFFSET FLAT:?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::trueLiteral

; 445  :         if (_Large_mode_engaged()) {

	mov	rax, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 558  : 			else if (c == trueLiteral[0]) {

	cmp	bl, BYTE PTR [rax]
	jne	$LN8@parseValue

; 436  : 			++i;

	inc	r8
	mov	QWORD PTR [r9], r8

; 437  : 			for (size_t j = 1; j < trueLiteral.size() && i < input.size(); ++j, ++i) {

	mov	ecx, 1
	cmp	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, rcx
	jbe	SHORT $LN152@parseValue
$LL153@parseValue:
	cmp	r8, QWORD PTR [rdx+16]
	jae	SHORT $LN152@parseValue
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	r10, rdx

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN163@parseValue

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [rdx]
$LN163@parseValue:

; 445  :         if (_Large_mode_engaged()) {

	mov	rax, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 438  : 				if (input[i] != trueLiteral[j]) {

	movzx	eax, BYTE PTR [rax+rcx]
	cmp	BYTE PTR [r8+r10], al
	jne	$LN390@parseValue

; 437  : 			for (size_t j = 1; j < trueLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rcx
	inc	r8
	mov	QWORD PTR [r9], r8
	cmp	rcx, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL153@parseValue
$LN152@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T44[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Bool@Json@@6B@
	mov	QWORD PTR [rax], rcx
	mov	BYTE PTR [rax+8], 1
$LN417@parseValue:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 576  : 		}

	mov	QWORD PTR [rdi], rax
$LN416@parseValue:
	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN8@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	r11, OFFSET FLAT:?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::falseLiteral

; 445  :         if (_Large_mode_engaged()) {

	mov	rax, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 561  : 			else if (c == falseLiteral[0]) {

	cmp	bl, BYTE PTR [rax]
	jne	SHORT $LN10@parseValue

; 448  : 			++i;

	inc	r8
	mov	QWORD PTR [r9], r8

; 449  : 			for (size_t j = 1; j < falseLiteral.size() && i < input.size(); ++j, ++i) {

	mov	ecx, 1
	cmp	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, rcx
	jbe	SHORT $LN230@parseValue
$LL231@parseValue:
	cmp	r8, QWORD PTR [rdx+16]
	jae	SHORT $LN230@parseValue
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	r10, rdx

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN241@parseValue

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [rdx]
$LN241@parseValue:

; 445  :         if (_Large_mode_engaged()) {

	mov	rax, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 450  : 				if (input[i] != falseLiteral[j]) {

	movzx	eax, BYTE PTR [rax+rcx]
	cmp	BYTE PTR [r10+r8], al
	jne	$LN391@parseValue

; 449  : 			for (size_t j = 1; j < falseLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rcx
	inc	r8
	mov	QWORD PTR [r9], r8
	cmp	rcx, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL231@parseValue
$LN230@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T71[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Bool@Json@@6B@
	mov	QWORD PTR [rax], rcx
	mov	BYTE PTR [rax+8], sil
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 562  : 				return parseBoolFalse(input, i);

	jmp	$LN417@parseValue
$LN10@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	r11, OFFSET FLAT:?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::nullLiteral

; 445  :         if (_Large_mode_engaged()) {

	mov	rax, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 564  : 			else if (c == nullLiteral[0]) {

	cmp	bl, BYTE PTR [rax]
	jne	SHORT $LN12@parseValue

; 460  : 			++i;

	inc	r8
	mov	QWORD PTR [r9], r8

; 461  : 			for (size_t j = 1; j < nullLiteral.size() && i < input.size(); ++j, ++i) {

	mov	ecx, 1
	cmp	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, rcx
	jbe	SHORT $LN308@parseValue
	npad	6
$LL309@parseValue:
	cmp	r8, QWORD PTR [rdx+16]
	jae	SHORT $LN308@parseValue
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	r10, rdx

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN319@parseValue

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r10, QWORD PTR [rdx]
$LN319@parseValue:

; 445  :         if (_Large_mode_engaged()) {

	mov	rax, r11

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 462  : 				if (input[i] != nullLiteral[j]) {

	movzx	eax, BYTE PTR [rax+rcx]
	cmp	BYTE PTR [r10+r8], al
	jne	SHORT $LN392@parseValue

; 461  : 			for (size_t j = 1; j < nullLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rcx
	inc	r8
	mov	QWORD PTR [r9], r8
	cmp	rcx, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL309@parseValue
$LN308@parseValue:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 8
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T97[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h

; 9    : 		Null() : Value() {};

	lea	rcx, OFFSET FLAT:??_7Null@Json@@6B@
	mov	QWORD PTR [rax], rcx
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 565  : 				return parseNull(input, i);

	jmp	$LN417@parseValue
$LN12@parseValue:

; 566  : 			}
; 567  : 			else if (c == numberStartCharacters[11]
; 568  : 				|| c == numberStartCharacters[10]
; 569  : 				|| (c >= numberStartCharacters[0]

	cmp	bl, 57					; 00000039H
	ja	SHORT $LN14@parseValue
	mov	rcx, 287992881640112128			; 03ff280000000000H
	bt	rcx, rbx
	jae	SHORT $LN14@parseValue

; 570  : 					&& c <= numberStartCharacters[9])) {
; 571  : 				return parseNumber(input, i);

	mov	r8, r9
	mov	rcx, rdi
	call	??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseNumber<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >

; 576  : 		}

	mov	rax, rdi
	vzeroupper
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN392@parseValue:

; 463  : 					throw std::runtime_error("Invalid null literal");

	lea	rdx, OFFSET FLAT:??_C@_0BF@GONMNCPG@Invalid?5null?5literal@
	lea	rcx, QWORD PTR $T96[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T96[rsp]
	call	_CxxThrowException
	int	3
$LN14@parseValue:

; 572  : 			}
; 573  : 			else {
; 574  : 				throw std::runtime_error(std::string("Invalid value syntax: ") + c);

	lea	rdx, OFFSET FLAT:??_C@_0BH@HJFABALL@Invalid?5value?5syntax?3?5@
	lea	rcx, QWORD PTR $T117[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	movzx	r8d, bl
	mov	rdx, rax
	lea	rcx, QWORD PTR $T118[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T119[rsp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T119[rsp]
	call	_CxxThrowException
	npad	1
$LN390@parseValue:

; 439  : 					throw std::runtime_error("Invalid bool true literal");

	lea	rdx, OFFSET FLAT:??_C@_0BK@GDBLDPAM@Invalid?5bool?5true?5literal@
	lea	rcx, QWORD PTR $T42[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T42[rsp]
	call	_CxxThrowException
	int	3
$LN391@parseValue:

; 451  : 					throw std::runtime_error("Invalid bool false literal");

	lea	rdx, OFFSET FLAT:??_C@_0BL@MHJMKGJM@Invalid?5bool?5false?5literal@
	lea	rcx, QWORD PTR $T69[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T69[rsp]
	call	_CxxThrowException
	int	3
$LN415@parseValue:
??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ENDP ; Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T7 = 48
$T44 = 48
$T71 = 48
__$ReturnUdt$GSCopy$ = 48
$T97 = 48
$T5 = 56
$T119 = 56
$T42 = 56
$T69 = 56
$T96 = 56
$T117 = 96
$T118 = 128
__$ReturnUdt$ = 192
input$ = 200
i$ = 208
?dtor$1@?0???$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T7 = 48
$T44 = 48
$T71 = 48
__$ReturnUdt$GSCopy$ = 48
$T97 = 48
$T5 = 56
$T119 = 56
$T42 = 56
$T69 = 56
$T96 = 56
$T117 = 96
$T118 = 128
__$ReturnUdt$ = 192
input$ = 200
i$ = 208
?dtor$3@?0???$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$3
	lea	rcx, QWORD PTR $T117[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T7 = 48
$T44 = 48
$T71 = 48
__$ReturnUdt$GSCopy$ = 48
$T97 = 48
$T5 = 56
$T119 = 56
$T42 = 56
$T69 = 56
$T96 = 56
$T117 = 96
$T118 = 128
__$ReturnUdt$ = 192
input$ = 200
i$ = 208
?dtor$4@?0???$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$4
	lea	rcx, QWORD PTR $T118[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ??$?0_J$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000> >::duration<__int64,std::ratio<1,1000000> ><__int64,0>, COMDAT

; 108  :             : _MyRep(static_cast<_Rep>(_Val)) {}

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0_J$0A@@?$duration@_JU?$ratio@$00$0PECEA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000> >::duration<__int64,std::ratio<1,1000000> ><__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$_Hash_array_representation@D@std@@YA_KQEBD_K@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
??$_Hash_array_representation@D@std@@YA_KQEBD_K@Z PROC	; std::_Hash_array_representation<char>, COMDAT

; 2290 :     const _Kty* const _First, const size_t _Count) noexcept { // bitwise hashes the representation of an array

	xor	r9d, r9d

; 2291 :     static_assert(is_trivially_copyable_v<_Kty>, "Only trivially copyable types can be directly hashed.");
; 2292 :     return _Fnv1a_append_bytes(

	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	rdx, rdx
	je	SHORT $LN17@Hash_array
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	4
$LL13@Hash_array:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rcx+r9]
	inc	r9
	xor	rax, r8

; 2261 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	r9, rdx
	jb	SHORT $LL13@Hash_array
$LN17@Hash_array:

; 2293 :         _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
; 2294 : }

	ret	0
??$_Hash_array_representation@D@std@@YA_KQEBD_K@Z ENDP	; std::_Hash_array_representation<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1><>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1514 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], rax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
_Psave$10 = 32
_Lock$11 = 40
_Psave_guard$12 = 48
_Lock$13 = 48
__$ArrayPad$ = 56
_Loc$ = 80
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT

; 435  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

$LN54:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbp, rcx

; 436  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$11[rsp]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
	npad	1

; 437  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	rax, QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
	mov	QWORD PTR _Psave$10[rsp], rax

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();

	mov	rbx, QWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A

; 91   :             if (_Id == 0) { // still zero, allocate stamp

	cmp	QWORD PTR [rbx], 0
	jne	SHORT $LN11@use_facet

; 92   :                 _BEGIN_LOCK(_LOCK_LOCALE)

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$13[rsp]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 93   :                 if (_Id == 0) {

	cmp	QWORD PTR [rbx], 0
	jne	SHORT $LN12@use_facet

; 94   :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	rax, QWORD PTR __imp_?_Id_cnt@id@locale@std@@0HA
	inc	DWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax]
	mov	QWORD PTR [rbx], rax
$LN12@use_facet:

; 95   :                 }
; 96   :                 _END_LOCK()

	lea	rcx, QWORD PTR _Lock$13[rsp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
$LN11@use_facet:

; 438  : 
; 439  :     const size_t _Id         = _Facet::id._Get_index();

	mov	rsi, QWORD PTR [rbx]

; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	rcx, QWORD PTR [rbp+8]
	lea	rdi, QWORD PTR [rsi*8]
	cmp	rsi, QWORD PTR [rcx+24]
	jae	SHORT $LN19@use_facet
	mov	rax, QWORD PTR [rcx+16]
	mov	rbx, QWORD PTR [rdi+rax]

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

	test	rbx, rbx
	jne	SHORT $LN42@use_facet
	jmp	SHORT $LN46@use_facet
$LN19@use_facet:

; 97   :             }
; 98   :             return _Id;
; 99   :         }
; 100  : 
; 101  : #ifdef _CRTBLD // TRANSITION, ABI: preserved for binary compatibility
; 102  :         __CLR_OR_THIS_CALL operator size_t() {
; 103  :             return _Get_index();
; 104  :         }
; 105  : #endif // defined(_CRTBLD)
; 106  : 
; 107  :     private:
; 108  :         size_t _Id = 0; // the identifier stamp
; 109  : 
; 110  :         __PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 111  :     };
; 112  : 
; 113  :     struct _Facet_guard;
; 114  : 
; 115  :     class _CRTIMP2_PURE_IMPORT facet : public _Facet_base, public _Crt_new_delete {
; 116  :         // base class for all locale facets, performs reference counting
; 117  :     private:
; 118  :         friend _Facet_guard;
; 119  : 
; 120  :     public:
; 121  :         static size_t __CLRCALL_OR_CDECL _Getcat(const facet** = nullptr, const locale* = nullptr) {
; 122  :             // get category value, or -1 if no corresponding C category
; 123  :             return static_cast<size_t>(-1);
; 124  :         }
; 125  : 
; 126  :         void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count
; 127  :             _MT_INCR(_Myrefs);
; 128  :         }
; 129  : 
; 130  :         _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count
; 131  :             if (_MT_DECR(_Myrefs) == 0) {
; 132  :                 return this;
; 133  :             }
; 134  : 
; 135  :             return nullptr;
; 136  :         }
; 137  : 
; 138  :     private:
; 139  :         _Atomic_counter_t _Myrefs; // the reference count
; 140  : 
; 141  :     protected:
; 142  :         explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0) noexcept // strengthened
; 143  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization
; 144  :         {}
; 145  : 
; 146  :         __CLR_OR_THIS_CALL ~facet() noexcept override {}
; 147  : 
; 148  :     public:
; 149  :         __CLR_OR_THIS_CALL facet(const facet&)            = delete;
; 150  :         facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 151  :     };
; 152  : 
; 153  :     struct _NODISCARD _Facet_guard {
; 154  :         facet* _Target;
; 155  :         ~_Facet_guard() {
; 156  :             if (_Target) {
; 157  :                 delete _Target->_Decref();
; 158  :             }
; 159  :         }
; 160  :     };
; 161  : 
; 162  :     class _CRTIMP2_PURE_IMPORT _Locimp : public facet { // reference-counted actual implementation of a locale
; 163  :     protected:
; 164  :         __CLR_OR_THIS_CALL ~_Locimp() noexcept {
; 165  :             _Locimp_dtor(this);
; 166  :         }
; 167  : 
; 168  :     private:
; 169  :         static _Locimp* __CLRCALL_PURE_OR_CDECL _New_Locimp(bool _Transparent = false);
; 170  :         static _Locimp* __CLRCALL_PURE_OR_CDECL _New_Locimp(const _Locimp& _Right);
; 171  : 
; 172  :         static void __CLRCALL_PURE_OR_CDECL _Locimp_dtor(_Locimp*);
; 173  :         static void __CLRCALL_PURE_OR_CDECL _Locimp_Addfac(_Locimp*, facet*, size_t); // add a facet
; 174  :         static void __CLRCALL_PURE_OR_CDECL _Locimp_ctor(_Locimp*, const _Locimp&);
; 175  : 
; 176  :         friend locale;
; 177  : 
; 178  :         __CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 179  :             : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*") {
; 180  :         }
; 181  : 
; 182  :         __CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 183  :             : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
; 184  :               _Xparent(_Right._Xparent), _Name(_Right._Name.c_str()) {
; 185  :             _Locimp_ctor(this, _Right);
; 186  :         }
; 187  : 
; 188  :         void __CLR_OR_THIS_CALL _Addfac(facet* _Pfacet, size_t _Id) { // add a facet
; 189  :             _Locimp_Addfac(this, _Pfacet, _Id);
; 190  :         }
; 191  : 
; 192  :         static _Locimp* __CLRCALL_OR_CDECL _Makeloc(
; 193  :             const _Locinfo&, category, _Locimp*, const locale*); // make essential facets
; 194  : 
; 195  :         static void __CLRCALL_OR_CDECL _Makewloc(
; 196  :             const _Locinfo&, category, _Locimp*, const locale*); // make wchar_t facets
; 197  : 
; 198  : #if defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
; 199  :         static void __CLRCALL_OR_CDECL _Makeushloc(
; 200  :             const _Locinfo&, category, _Locimp*, const locale*); // make ushort facets
; 201  : #endif // defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
; 202  : 
; 203  :         static void __CLRCALL_OR_CDECL _Makexloc(
; 204  :             const _Locinfo&, category, _Locimp*, const locale*); // make remaining facets
; 205  : 
; 206  :         facet** _Facetvec; // pointer to vector of facets
; 207  :         size_t _Facetcount; // size of vector of facets
; 208  :         category _Catmask; // mask describing implemented categories
; 209  :         bool _Xparent; // true if locale is transparent
; 210  :         _Yarn<char> _Name; // locale name, or "*" if not known
; 211  : 
; 212  :         __PURE_APPDOMAIN_GLOBAL static _Locimp* _Clocptr;
; 213  : 
; 214  :     public:
; 215  :         _Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 216  :     };
; 217  : 
; 218  :     template <class _Elem, class _Traits, class _Alloc>
; 219  :     bool operator()(
; 220  :         const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) const {
; 221  :         // compare _Left and _Right strings using collate facet in locale
; 222  :         const auto& _Coll_fac = _STD use_facet<_STD collate<_Elem>>(*this);
; 223  : 
; 224  :         const _Elem* const _Left_data  = _Left.data();
; 225  :         const _Elem* const _Right_data = _Right.data();
; 226  :         return _Coll_fac.compare(_Left_data, _Left_data + _Left.size(), _Right_data, _Right_data + _Right.size()) < 0;
; 227  :     }
; 228  : 
; 229  :     template <class _Facet>
; 230  :     locale combine(const locale& _Loc) const { // combine two locales
; 231  :         _Facet* _Facptr;
; 232  : 
; 233  :         _TRY_BEGIN
; 234  :         _Facptr = const_cast<_Facet*>(_STD addressof(_STD use_facet<_Facet>(_Loc)));
; 235  :         _CATCH_ALL
; 236  :         _Xruntime_error("locale::combine facet missing");
; 237  :         _CATCH_END
; 238  : 
; 239  :         _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
; 240  :         _Newimp->_Addfac(_Facptr, _Facet::id._Get_index());
; 241  :         _Newimp->_Catmask = none;
; 242  :         _Newimp->_Name    = "*";
; 243  :         return locale{_Secret_locale_construct_tag{}, _Newimp};
; 244  :     }
; 245  : 
; 246  :     template <class _Facet>
; 247  :     locale(const locale& _Loc, const _Facet* _Facptr) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 248  :         if (_Facptr) { // replace facet
; 249  :             _Ptr->_Addfac(const_cast<_Facet*>(_Facptr), _Facet::id._Get_index());
; 250  :             _Ptr->_Catmask = none;
; 251  :             _Ptr->_Name    = "*";
; 252  :         }
; 253  :     }
; 254  : 
; 255  : #pragma warning(push)
; 256  : #pragma warning(disable : 26495) // Variable 'std::locale::_Ptr' is uninitialized.
; 257  :                                  // Always initialize a member variable (type.6).
; 258  : 
; 259  :     // We must not explicitly initialize _Ptr here; we rely on it maintaining the value
; 260  :     // previously created in its storage. To be precise:
; 261  :     // In locale0.cpp, locale::_Init() uses True Placement New at classic_locale's address,
; 262  :     // and classic_locale is constructed from the _Noinit enumerator of type _Uninitialized.
; 263  :     // The sequencing is highly unusual; the True Placement New happens before the _Uninitialized construction,
; 264  :     // so while _Ptr here formally has indeterminate value, we expect it to actually keep the previous value.
; 265  :     locale(_Uninitialized) {} // defer construction
; 266  : #pragma warning(pop)
; 267  : 
; 268  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {
; 269  :         _Ptr->_Incref();
; 270  :     }
; 271  : 
; 272  :     locale() noexcept : _Ptr(_Init(true)) {}
; 273  : 
; 274  : #if !defined(MRTDLL) || !defined(_CRTBLD)
; 275  :     locale(const locale& _Loc, const locale& _Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 276  :         // construct a locale by copying named facets
; 277  :         if (_Cat != none) { // worth adding, do it
; 278  :             _STL_ASSERT((_Cat & all) == _Cat, "the bitmask value specifying category must be valid");
; 279  :             _Facet_guard _Guard{_Ptr};
; 280  :             _BEGIN_LOCINFO(_Lobj)
; 281  :             _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
; 282  :             _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
; 283  :             _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
; 284  :             _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
; 285  :             _Ptr->_Name    = _Lobj._Getname();
; 286  :             _END_LOCINFO()
; 287  :             _Guard._Target = nullptr;
; 288  :         }
; 289  :     }
; 290  : 
; 291  : private:
; 292  :     void _Construct(const string& _Str, category _Cat) {
; 293  :         _STL_ASSERT((_Cat & all) == _Cat, "the bitmask value specifying category must be valid");
; 294  :         // construct a locale with named facets
; 295  :         bool _Bad = false;
; 296  :         _Init();
; 297  :         if (_Cat != none) { // worth adding, do it
; 298  :             _Facet_guard _Guard{_Ptr};
; 299  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 300  :             if (_Badname(_Lobj)) {
; 301  :                 _Bad = true;
; 302  :             } else { // name okay, build the locale
; 303  :                 _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
; 304  :                 _Ptr->_Catmask = _Cat;
; 305  :                 _Ptr->_Name    = _Str.c_str();
; 306  :             }
; 307  :             _END_LOCINFO()
; 308  :             _Guard._Target = nullptr;
; 309  :         }
; 310  : 
; 311  :         if (_Bad) { // Don't throw within _BEGIN_LOCINFO if we can avoid it
; 312  :             delete _Ptr->_Decref();
; 313  :             _Xruntime_error("bad locale name");
; 314  :         }
; 315  :     }
; 316  : 
; 317  : public:
; 318  :     explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
; 319  :         // construct a locale with named facets
; 320  :         // _Locname might have been returned from setlocale().
; 321  :         // Therefore, _Construct() takes const string&.
; 322  :         if (_Locname) {
; 323  :             _Construct(_Locname, _Cat);
; 324  :             return;
; 325  :         }
; 326  : 
; 327  :         _Xruntime_error("bad locale name");
; 328  :     }
; 329  : 
; 330  :     locale(const locale& _Loc, const char* _Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 331  :         // construct a locale by copying, replacing named facets
; 332  :         // _Locname might have been returned from setlocale().
; 333  :         // Therefore, _Construct() takes const string&.
; 334  :         if (_Locname) {
; 335  :             _Construct(_Locname, _Cat);
; 336  :             return;
; 337  :         }
; 338  : 
; 339  :         _Xruntime_error("bad locale name");
; 340  :     }
; 341  : 
; 342  :     explicit locale(const string& _Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
; 343  :         // construct a locale with named facets
; 344  :         _Construct(_Str, _Cat);
; 345  :     }
; 346  : 
; 347  :     locale(const locale& _Loc, const string& _Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
; 348  :         // construct a locale by copying, replacing named facets
; 349  :         _Construct(_Str, _Cat);
; 350  :     }
; 351  : #endif // !MRTDLL || !_CRTBLD
; 352  : 
; 353  :     ~locale() noexcept {
; 354  :         if (_Ptr) {
; 355  :             delete _Ptr->_Decref();
; 356  :         }
; 357  :     }
; 358  : 
; 359  :     const locale& operator=(const locale& _Right) noexcept {
; 360  :         if (_Ptr != _Right._Ptr) { // different implementation, point at new one
; 361  :             delete _Ptr->_Decref();
; 362  :             _Ptr = _Right._Ptr;
; 363  :             _Ptr->_Incref();
; 364  :         }
; 365  :         return *this;
; 366  :     }
; 367  : 
; 368  :     string name() const {
; 369  :         return _Ptr ? _Ptr->_Name.c_str() : string{};
; 370  :     }
; 371  : 
; 372  :     _Ret_z_ const char* _C_str() const noexcept {
; 373  :         return _Ptr ? _Ptr->_Name.c_str() : "";
; 374  :     }
; 375  : 
; 376  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 377  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	ebx, ebx
$LN46@use_facet:

; 378  :         if (_Facptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [rcx+36], 0
	je	SHORT $LN14@use_facet

; 379  :             return _Facptr; // found facet or not transparent
; 380  :         }
; 381  : 
; 382  :         // look in current locale
; 383  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 384  :         if (_Id < _Ptr0->_Facetcount) {

	cmp	rsi, QWORD PTR [rax+24]
	jae	SHORT $LN47@use_facet

; 385  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

	mov	rax, QWORD PTR [rax+16]
	mov	rbx, QWORD PTR [rdi+rax]
$LN14@use_facet:

; 440  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 441  : 
; 442  :     if (!_Pf) {

	test	rbx, rbx
	jne	SHORT $LN42@use_facet
$LN47@use_facet:

; 443  :         if (_Psave) {

	mov	rbx, QWORD PTR _Psave$10[rsp]
	test	rbx, rbx
	jne	SHORT $LN42@use_facet

; 444  :             _Pf = _Psave; // lazy facet already allocated
; 445  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	rdx, rbp
	lea	rcx, QWORD PTR _Psave$10[rsp]
	call	QWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
	cmp	rax, -1
	je	SHORT $LN52@use_facet

; 448  : #else
; 449  :             _CSTD abort(); // lazy disallowed
; 450  : #endif
; 451  :         } else { // queue up lazy facet for destruction
; 452  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	rbx, QWORD PTR _Psave$10[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR _Psave_guard$12[rsp], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale

; 458  :             _Facet_Register(_Pfmod);

	mov	rcx, rbx
	call	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 459  : #endif // ^^^ !defined(_M_CEE) ^^^
; 460  : 
; 461  :             _Pfmod->_Incref();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]

; 462  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	rbx, QWORD PTR _Psave$10[rsp]
	mov	QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB, rbx ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
$LN42@use_facet:

; 463  :             _Pf                       = _Psave;
; 464  : 
; 465  :             (void) _Psave_guard.release();
; 466  :         }
; 467  :     }
; 468  : 
; 469  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	rcx, QWORD PTR _Lock$11[rsp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
	mov	rax, rbx

; 470  :     _END_LOCK()
; 471  : } // end of use_facet body

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN52@use_facet:

; 446  : #if _HAS_EXCEPTIONS
; 447  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1
$LN49@use_facet:
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Psave$10 = 32
_Lock$11 = 40
_Psave_guard$12 = 48
_Lock$13 = 48
__$ArrayPad$ = 56
_Loc$ = 80
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Lock$11[rdx]
	rex_jmp	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Psave$10 = 32
_Lock$11 = 40
_Psave_guard$12 = 48
_Lock$13 = 48
__$ArrayPad$ = 56
_Loc$ = 80
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Psave_guard$12[rdx]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT

; 221  :             return _MyDur;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax
	mov	rax, rdx

; 222  :         }

	ret	0
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT

; 119  :             return _MyRep;

	mov	rax, QWORD PTR [rcx]

; 120  :         }

	ret	0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
;	COMDAT ?unmap@?$MappedFile@$0A@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?unmap@?$MappedFile@$0A@@@QEAAXXZ PROC			; MappedFile<0>::unmap, COMDAT

; 175  :     {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 176  :         if (m_data) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@unmap

; 177  : #ifdef _WIN32
; 178  :             UnmapViewOfFile(m_data);

	call	QWORD PTR __imp_UnmapViewOfFile

; 179  :             CloseHandle(m_mapping_handle);

	mov	rcx, QWORD PTR [rbx+24]
	call	QWORD PTR __imp_CloseHandle

; 180  :             CloseHandle(m_file_handle);

	mov	rcx, QWORD PTR [rbx+16]
	call	QWORD PTR __imp_CloseHandle

; 181  :             m_file_handle = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 182  :             m_mapping_handle = nullptr;

	mov	QWORD PTR [rbx+24], rax

; 183  : #else
; 184  :             munmap(const_cast<char*>(m_data), m_size);
; 185  :             close(m_fd);
; 186  :             m_fd = -1;
; 187  : #endif
; 188  :             m_data = nullptr;

	mov	QWORD PTR [rbx], rax

; 189  :             m_size = 0;

	mov	QWORD PTR [rbx+8], rax
$LN2@unmap:

; 190  :         }
; 191  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?unmap@?$MappedFile@$0A@@@QEAAXXZ ENDP			; MappedFile<0>::unmap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
;	COMDAT ?map@?$MappedFile@$0A@@@QEAAXPEBD@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
file_size$ = 104
__$ArrayPad$ = 112
this$ = 144
filename$ = 152
?map@?$MappedFile@$0A@@@QEAAXPEBD@Z PROC		; MappedFile<0>::map, COMDAT

; 96   :     {

$LN14:
	push	rbx
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, rdx

; 97   : #ifdef _WIN32
; 98   :         // Windows implementation
; 99   : 
; 100  :         if constexpr (writable)
; 101  :             m_file_handle = CreateFileA(
; 102  :                 filename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL,
; 103  :                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
; 104  :             );
; 105  :         else         m_file_handle = CreateFileA(

	mov	QWORD PTR [rsp+48], 0
	mov	rbx, rcx
	mov	DWORD PTR [rsp+40], 128			; 00000080H
	mov	rcx, rax
	mov	DWORD PTR [rsp+32], 3
	xor	r9d, r9d
	mov	edx, -2147483648			; 80000000H
	mov	r8d, 1
	call	QWORD PTR __imp_CreateFileA
	mov	QWORD PTR [rbx+16], rax

; 106  :             filename, GENERIC_READ, FILE_SHARE_READ, NULL,
; 107  :             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
; 108  :         );
; 109  : 
; 110  :         if (m_file_handle == INVALID_HANDLE_VALUE) {

	cmp	rax, -1
	je	$LN11@map

; 112  :         }
; 113  : 
; 114  :         LARGE_INTEGER file_size;
; 115  :         GetFileSizeEx(m_file_handle, &file_size);

	lea	rdx, QWORD PTR file_size$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_GetFileSizeEx

; 116  :         m_size = static_cast<std::size_t>(file_size.QuadPart);

	mov	rax, QWORD PTR file_size$[rsp]

; 117  : 
; 118  :         if constexpr (writable)
; 119  :             m_mapping_handle = CreateFileMappingA(
; 120  :                 m_file_handle, NULL, PAGE_READWRITE, 0, 0, NULL
; 121  :             );
; 122  :         else m_mapping_handle = CreateFileMappingA(

	xor	r9d, r9d
	mov	rcx, QWORD PTR [rbx+16]
	xor	edx, edx
	mov	QWORD PTR [rsp+40], 0
	mov	r8d, 2
	mov	QWORD PTR [rbx+8], rax
	mov	DWORD PTR [rsp+32], 0
	call	QWORD PTR __imp_CreateFileMappingA
	mov	QWORD PTR [rbx+24], rax
	mov	rcx, rax

; 123  :             m_file_handle, NULL, PAGE_READONLY, 0, 0, NULL
; 124  :         );
; 125  : 
; 126  : 
; 127  :         if (!m_mapping_handle) {

	test	rax, rax
	je	SHORT $LN12@map

; 130  :         }
; 131  : 
; 132  :         if constexpr (writable)
; 133  :             m_data = static_cast<const char*>(MapViewOfFile(
; 134  :                 m_mapping_handle, FILE_MAP_WRITE, 0, 0, m_size
; 135  :             ));
; 136  :         else m_data = static_cast<const char*>(MapViewOfFile(

	mov	rax, QWORD PTR [rbx+8]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rax
	mov	edx, 4
	call	QWORD PTR __imp_MapViewOfFile
	mov	QWORD PTR [rbx], rax

; 137  :             m_mapping_handle, FILE_MAP_READ, 0, 0, m_size
; 138  :         ));
; 139  : 
; 140  :         if (!m_data) {

	test	rax, rax
	je	SHORT $LN13@map

; 144  :         }
; 145  : #else
; 146  :         // Unix-like (Linux, macOS)
; 147  :         m_fd = open(filename, O_RDONLY);
; 148  :         if (m_fd == -1) {
; 149  :             throw std::system_error(errno, std::generic_category());
; 150  :         }
; 151  : 
; 152  :         struct stat sb;
; 153  :         if (fstat(m_fd, &sb) == -1) {
; 154  :             close(m_fd);
; 155  :             throw std::system_error(errno, std::generic_category());
; 156  :         }
; 157  :         m_size = sb.st_size;
; 158  : 
; 159  :         if constexpr (writable) {
; 160  :             m_data = static_cast<char*>(mmap(
; 161  :                 nullptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0
; 162  :             ));
; 163  :         }
; 164  :         else m_data = static_cast<const char*>(mmap(
; 165  :             nullptr, m_size, PROT_READ, MAP_PRIVATE, m_fd, 0
; 166  :         ));
; 167  : 
; 168  :         if (m_data == MAP_FAILED) {
; 169  :             close(m_fd);
; 170  :             throw std::system_error(errno, std::generic_category());
; 171  :         }
; 172  : #endif
; 173  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 128				; 00000080H
	pop	rbx
	ret	0
$LN11@map:

; 111  :             throw std::system_error(GetLastError(), std::system_category());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	call	?system_category@std@@YAAEBVerror_category@1@XZ ; std::system_category
	mov	r8, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN12@map:

; 128  :             CloseHandle(m_file_handle);

	mov	rcx, QWORD PTR [rbx+16]
	call	QWORD PTR __imp_CloseHandle

; 129  :             throw std::system_error(GetLastError(), std::system_category());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	call	?system_category@std@@YAAEBVerror_category@1@XZ ; std::system_category
	mov	r8, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T2[rsp]
	call	_CxxThrowException
	int	3
$LN13@map:

; 141  :             CloseHandle(m_mapping_handle);

	mov	rcx, QWORD PTR [rbx+24]
	call	QWORD PTR __imp_CloseHandle

; 142  :             CloseHandle(m_file_handle);

	mov	rcx, QWORD PTR [rbx+16]
	call	QWORD PTR __imp_CloseHandle

; 143  :             throw std::system_error(GetLastError(), std::system_category());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	call	?system_category@std@@YAAEBVerror_category@1@XZ ; std::system_category
	mov	r8, rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0system_error@std@@QEAA@HAEBVerror_category@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
	int	3
$LN9@map:
?map@?$MappedFile@$0A@@@QEAAXPEBD@Z ENDP		; MappedFile<0>::map
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
;	COMDAT ?size@?$MappedFile@$0A@@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$MappedFile@$0A@@@QEBA_KXZ PROC			; MappedFile<0>::size, COMDAT

; 76   :     inline size_t size() const noexcept { return m_size; }

	mov	rax, QWORD PTR [rcx+8]
	ret	0
?size@?$MappedFile@$0A@@@QEBA_KXZ ENDP			; MappedFile<0>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 64
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Tidy, COMDAT

; 306  :     void _Tidy() noexcept {

$LN29:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 307  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 279  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN19@Tidy

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN18@Tidy

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN19@Tidy:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 310  :             _Mypair._Myval2._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 311  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 312  :             _Mypair._Myval2._Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 314  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN18@Tidy:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	eax, eax
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rax
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN26@Tidy:
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Tidy, COMDAT

; 1514 :     void _Tidy() noexcept {

$LN95:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1515 :         auto& _Al      = _Getal();
; 1516 :         auto& _My_data = _Mypair._Myval2;
; 1517 :         _My_data._Orphan_all();
; 1518 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	rsi, rcx

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rdi, QWORD PTR [rdx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rdi, rdi
	je	SHORT $LN88@Tidy
	mov	QWORD PTR [rsp+56], rbx
	npad	8
$LL7@Tidy:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdi]

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rdi+16]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rdi, rbx
	test	rbx, rbx
	jne	SHORT $LL7@Tidy
	mov	rbx, QWORD PTR [rsp+56]
$LN88@Tidy:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rsi]
	mov	edx, 56					; 00000038H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 1520 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Parg$ = 72
_Al$dead$ = 80
??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >, COMDAT

; 371  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

$LN60:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	edi, edi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi

; 1852 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rax], rax

; 1853 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1854 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx+8], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 371  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	lea	rcx, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 371  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR [rbx+48], 7
	mov	QWORD PTR [rbx+56], 8

; 372  :         // construct empty hash table
; 373  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [rbx], 1065353216		; 3f800000H

; 374  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 16
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Assign_grow
	npad	1

; 375  : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 376  :         _Stl_internal_check_container_invariants();
; 377  : #endif // _ENABLE_STL_INTERNAL_CHECK
; 378  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Parg$ = 72
_Al$dead$ = 80
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Parg$ = 72
_Al$dead$ = 80
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??0?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	DWORD PTR [rcx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 130  :         : _Mypair(_Zero_then_variadic_args_t{}, _Zero_then_variadic_args_t{}, 0.0f) {}

	mov	rax, rcx
	ret	0
??0?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 974  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 64
?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Tidy, COMDAT

; 2081 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN57:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 48					; 00000030H

; 2082 :         auto& _Al         = _Getal();
; 2083 :         auto& _My_data    = _Mypair._Myval2;
; 2084 :         pointer& _Myfirst = _My_data._Myfirst;
; 2085 :         pointer& _Mylast  = _My_data._Mylast;
; 2086 :         pointer& _Myend   = _My_data._Myend;
; 2087 : 
; 2088 :         _My_data._Orphan_all();
; 2089 : 
; 2090 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy
	mov	QWORD PTR [rsp+72], rdi

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN7@Tidy
$LL8@Tidy:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN26@Tidy

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN26@Tidy:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL8@Tidy
$LN7@Tidy:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@Tidy

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN39@Tidy

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN40@Tidy:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2095 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 2096 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 2097 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN2@Tidy:

; 2099 :     }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN39@Tidy:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	eax, eax
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rax
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN54@Tidy:
?_Tidy@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 764  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 765  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 766  :     }

	mov	rax, rcx

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 764  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 765  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 766  :     }

	ret	0
??0?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >, COMDAT

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

	ret	0
??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 123  :             return _Ok;

	movzx	eax, BYTE PTR [rcx+8]

; 124  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 107  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN19:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 108  : #if !_HAS_EXCEPTIONS
; 109  :             const bool _Zero_uncaught_exceptions = true;
; 110  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

	call	QWORD PTR __imp_?uncaught_exceptions@std@@YAHXZ

; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

	test	eax, eax
	jne	SHORT $LN2@sentry

; 117  :                 this->_Myostr._Osfx();

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN2@sentry:

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rdx+72]

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN16@sentry

; 79   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN16@sentry:

; 118  :             }
; 119  :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN22:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	QWORD PTR [rcx], rdx

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [r8+rdx+72]

; 71   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN8@sentry

; 72   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN8@sentry:

; 91   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN1@sentry

; 92   :                 _Ok = false;
; 93   :                 return;
; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rbx+80]

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

	test	rcx, rcx
	je	SHORT $LN4@sentry
	cmp	rcx, rbx
	je	SHORT $LN4@sentry

; 99   :                 return;
; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	jmp	SHORT $LN1@sentry
$LN4@sentry:

; 98   :                 _Ok = true;

	mov	al, 1
$LN1@sentry:

; 104  :         }

	mov	BYTE PTR [rdi+8], al
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Ostr$ = 56
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT

; 417  :     istreambuf_iterator& operator++() {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN6@operator
	call	QWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN6@operator

; 418  : #if _ITERATOR_DEBUG_LEVEL == 2
; 419  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not incrementable");
; 420  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 421  : 
; 422  :         _Inc();
; 423  :         return *this;
; 424  :     }

	mov	BYTE PTR [rbx+8], 0
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@operator:

; 461  :             _Strbuf = nullptr;

	mov	QWORD PTR [rbx], 0

; 418  : #if _ITERATOR_DEBUG_LEVEL == 2
; 419  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not incrementable");
; 420  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 421  : 
; 422  :         _Inc();
; 423  :         return *this;
; 424  :     }

	mov	rax, rbx
	mov	BYTE PTR [rbx+8], 1
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBADXZ
_TEXT	SEGMENT
this$ = 48
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBADXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT

; 405  :     _NODISCARD _Elem operator*() const {

$LN23:
	push	rbx
	sub	rsp, 32					; 00000020H

; 406  :         if (!_Got) {

	cmp	BYTE PTR [rcx+8], 0
	mov	rbx, rcx
	jne	SHORT $LN17@operator

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@operator
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN7@operator

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [rbx+9], al

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR [rbx+8], 1

; 415  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@operator:

; 407  :             _Peek();
; 408  :         }
; 409  : 
; 410  : #if _ITERATOR_DEBUG_LEVEL == 2
; 411  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not dereferenceable");
; 412  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 413  : 
; 414  :         return _Val;

	movzx	eax, BYTE PTR [rbx+9]

; 471  :             _Strbuf = nullptr;

	mov	QWORD PTR [rbx], 0

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR [rbx+8], 1

; 415  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@operator:

; 407  :             _Peek();
; 408  :         }
; 409  : 
; 410  : #if _ITERATOR_DEBUG_LEVEL == 2
; 411  :         _STL_VERIFY(_Strbuf, "istreambuf_iterator is not dereferenceable");
; 412  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 413  : 
; 414  :         return _Val;

	movzx	eax, BYTE PTR [rcx+9]

; 415  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBADXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3466 :     }

	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

	ret	0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 444  :         const value_type* _Result = _Bx._Buf;
; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN8@Myptr

; 446  :             _Result = _Unfancy(_Bx._Ptr);
; 447  :         }
; 448  : 
; 449  :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 450  :     }

	ret	0
$LN8@Myptr:

; 446  :             _Result = _Unfancy(_Bx._Ptr);
; 447  :         }
; 448  : 
; 449  :         return _Result;

	mov	rax, rcx

; 450  :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 750  :         return _Al;

	mov	rax, rcx

; 751  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 64
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3080 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN33:
	push	rbx
	sub	rsp, 48					; 00000030H

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rcx+24]

; 3080 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	mov	rbx, rcx

; 3081 :         auto& _My_data = _Mypair._Myval2;
; 3082 :         _My_data._Orphan_all();
; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN14@Tidy_deall
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@Tidy_deall

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN21@Tidy_deall

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN22@Tidy_deall:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN14@Tidy_deall:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 3094 :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN21@Tidy_deall:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN30@Tidy_deall:
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN11@data

; 2360 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 2361 :     }

	ret	0
$LN11@data:

; 2360 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 2361 :     }

	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ
_TEXT	SEGMENT
this$ = 8
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front, COMDAT

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN11@front

; 2324 : #if _MSVC_STL_HARDENING_BASIC_STRING || _ITERATOR_DEBUG_LEVEL != 0
; 2325 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 2326 : #endif
; 2327 : 
; 2328 :         return _Mypair._Myval2._Myptr()[0];

	mov	rax, QWORD PTR [rcx]

; 2329 :     }

	ret	0
$LN11@front:

; 2324 : #if _MSVC_STL_HARDENING_BASIC_STRING || _ITERATOR_DEBUG_LEVEL != 0
; 2325 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 2326 : #endif
; 2327 : 
; 2328 :         return _Mypair._Myval2._Myptr()[0];

	mov	rax, rcx

; 2329 :     }

	ret	0
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
_TEXT	SEGMENT
this$ = 8
_Ch$ = 16
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [rcx+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	r9, QWORD PTR [rcx+24]
	cmp	r8, r9
	jae	SHORT $LN2@push_back

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [r8+1]
	mov	QWORD PTR [rcx+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN5@push_back

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN5@push_back:

; 2296 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rcx+r8], dl

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rcx+r8+1], 0

; 2303 :             1,
; 2304 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch)
; 2305 :                 _STATIC_LAMBDA {
; 2306 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);
; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 2309 :                 },
; 2310 :             _Ch);
; 2311 :     }

	ret	0
$LN2@push_back:

; 2299 :             return;
; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	movzx	r9d, dl
	jmp	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ch$ = 80
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator(), COMDAT

; 2305 :                 _STATIC_LAMBDA {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rax
	mov	rcx, rbx
	mov	r8, r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2305 :                 _STATIC_LAMBDA {

	mov	rdi, r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

	movzx	eax, BYTE PTR _Ch$[rsp]
	mov	BYTE PTR [rbx+rdi], al

; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rbx+rdi+1], 0

; 2309 :                 },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@QEBA@QEADQEBD_KD@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN11@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]

; 2277 : #if _MSVC_STL_HARDENING_BASIC_STRING || _ITERATOR_DEBUG_LEVEL != 0
; 2278 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 2279 : #endif
; 2280 : 
; 2281 :         return _Mypair._Myval2._Myptr()[_Off];

	add	rax, rdx

; 2282 :     }

	ret	0
$LN11@operator:

; 2277 : #if _MSVC_STL_HARDENING_BASIC_STRING || _ITERATOR_DEBUG_LEVEL != 0
; 2278 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 2279 : #endif
; 2280 : 
; 2281 :         return _Mypair._Myval2._Myptr()[_Off];

	lea	rax, QWORD PTR [rcx+rdx]

; 2282 :     }

	ret	0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
_TEXT	SEGMENT
this$ = 48
_Off$dead$ = 56
_Count$ = 64
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 1889 :     _CONSTEXPR20 basic_string& erase(const size_type _Off, const size_type _Count) {

$LN59:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 487  :         return (_STD min)(_Size, _Mysize - _Off);

	mov	rbx, QWORD PTR [rcx+16]

; 1889 :     _CONSTEXPR20 basic_string& erase(const size_type _Off, const size_type _Count) {

	mov	rax, r8

; 487  :         return (_STD min)(_Size, _Mysize - _Off);

	cmp	rbx, r8

; 1889 :     _CONSTEXPR20 basic_string& erase(const size_type _Off, const size_type _Count) {

	mov	rdi, rcx

; 487  :         return (_STD min)(_Size, _Mysize - _Off);

	cmovb	rax, rbx

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN13@erase

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN13@erase:

; 1881 :         const size_type _New_size = _Old_size - _Count;

	sub	rbx, rax

; 1882 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	lea	rdx, QWORD PTR [rax+rcx]
	lea	r8, QWORD PTR [rbx+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	memmove
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1884 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], rbx

; 1890 :         // erase elements [_Off, _Off + _Count)
; 1891 :         _Mypair._Myval2._Check_offset(_Off);
; 1892 :         return _Erase_noexcept(_Off, _Count);

	mov	rax, rdi

; 1893 :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1510 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN52:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	rsi, r8

; 1511 :         // append [_Ptr, _Ptr + _Count)
; 1512 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 1513 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	r8, QWORD PTR [rdi+24]
	mov	rax, r8
	sub	rax, rcx
	cmp	rsi, rax
	ja	SHORT $LN2@append
	mov	QWORD PTR [rsp+64], rbx

; 1514 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+rsi]
	mov	QWORD PTR [rdi+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 436  :         if (_Large_mode_engaged()) {

	cmp	r8, 15
	jbe	SHORT $LN5@append

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN5@append:

; 1516 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 1517 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	rbx, QWORD PTR [rax+rcx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi
	mov	rcx, rbx
	call	memmove
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+rsi], 0

; 1519 :             return *this;

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+64]

; 1523 :             _Count,
; 1524 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 1525 :                 const size_type _Count) _STATIC_LAMBDA {
; 1526 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1527 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1529 :             },
; 1530 :             _Ptr, _Count);
; 1531 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@append:

; 1520 :         }
; 1521 : 
; 1522 :         return _Reallocate_grow_by(

	mov	r9, rdx
	mov	QWORD PTR [rsp+32], rsi
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>

; 1523 :             _Count,
; 1524 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 1525 :                 const size_type _Count) _STATIC_LAMBDA {
; 1526 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1527 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1529 :             },
; 1530 :             _Ptr, _Count);
; 1531 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ptr$ = 80
_Count$ = 88
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator(), COMDAT

; 1525 :                 const size_type _Count) _STATIC_LAMBDA {

$LN39:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rax
	mov	rcx, rbx
	mov	r8, r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1525 :                 const size_type _Count) _STATIC_LAMBDA {

	mov	rdi, r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
	mov	rdx, QWORD PTR _Ptr$[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1527 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	add	rdi, rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rbx, QWORD PTR _Count$[rsp]
	mov	rcx, rdi
	mov	r8, rbx
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0

; 1529 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@QEBD_K@Z@QEBA@QEAD0101@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 1259 :         // assign by stealing _Right's buffer
; 1260 :         // pre: this != &_Right
; 1261 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1262 :         // pre: *this owns no memory, iterators orphaned
; 1263 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1264 :         auto& _My_data    = _Mypair._Myval2;
; 1265 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1266 : 
; 1267 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1268 :         if constexpr (_Can_memcpy_val) {
; 1269 : #if _HAS_CXX20
; 1270 :             if (!_STD is_constant_evaluated())
; 1271 : #endif // _HAS_CXX20
; 1272 :             {
; 1273 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1274 :                 if (_Right_data._Large_mode_engaged()) {
; 1275 :                     // take ownership of _Right's iterators along with its buffer
; 1276 :                     _Swap_proxy_and_iterators(_Right);
; 1277 :                 } else {
; 1278 :                     _Right_data._Orphan_all();
; 1279 :                 }
; 1280 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1281 : 
; 1282 :                 const auto _My_data_mem =
; 1283 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1284 :                 const auto _Right_data_mem =
; 1285 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rcx], ymm0

; 1287 : 
; 1288 :                 _Right_data._Mysize = 0;
; 1289 :                 _Right_data._Myres  = _Small_string_capacity;
; 1290 :                 _Right_data._Activate_SSO_buffer();
; 1291 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());
; 1292 :                 return;
; 1293 :             }
; 1294 :         }
; 1295 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1296 : 
; 1297 :         if (_Right_data._Large_mode_engaged()) { // steal buffer
; 1298 :             _Swap_proxy_and_iterators(_Right);
; 1299 : 
; 1300 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 1301 :             _Right_data._Bx._Switch_to_buf();
; 1302 :         } else { // copy small string buffer
; 1303 :             _Right_data._Orphan_all();
; 1304 : 
; 1305 :             _My_data._Activate_SSO_buffer();
; 1306 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 1307 :         }
; 1308 : 
; 1309 :         _My_data._Myres  = _Right_data._Myres;
; 1310 :         _My_data._Mysize = _Right_data._Mysize;
; 1311 : 
; 1312 :         _Right_data._Mysize = 0;
; 1313 :         _Right_data._Myres  = _Small_string_capacity;
; 1314 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());
; 1315 :     }

	mov	BYTE PTR [rdx], 0
	mov	QWORD PTR [rdx+16], 0
	mov	QWORD PTR [rdx+24], 15
	vzeroupper
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z
_TEXT	SEGMENT
this$ = 96
__formal$dead$ = 104
_Source_of_al$dead$ = 112
_Left_ptr$dead$ = 120
_Left_size$ = 128
_Right_ptr$ = 136
_Right_size$ = 144
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1052 :               _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

$LN108:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r14, QWORD PTR _Left_size$[rsp]

; 1057 :         size_type _New_capacity = _Small_string_capacity;

	mov	edi, 15
	mov	r15, QWORD PTR _Right_size$[rsp]
	mov	rsi, rcx
	mov	r12, QWORD PTR _Right_ptr$[rsp]

; 1058 :         auto& _My_data          = _Mypair._Myval2;
; 1059 :         _Elem* _Ptr             = _My_data._Bx._Buf;

	mov	rbx, rcx
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 1053 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 1054 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 1055 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 1056 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

	lea	rbp, QWORD PTR [r14+r15]

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], 0

; 1060 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1061 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 1062 : 
; 1063 :         if (_New_capacity < _New_size) {

	cmp	rbp, rdi
	jbe	$LN2@basic_stri

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rbp
	or	rax, rdi
	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	rax, rdi

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN18@basic_stri

; 2980 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN43@basic_stri:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN44@basic_stri
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN18@basic_stri:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	ecx, 22
	mov	rdi, rax
	cmp	rax, rcx
	cmovb	rdi, rcx

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rdi+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN36@basic_stri

; 228  :         return nullptr;

	xor	ebx, ebx
	jmp	SHORT $LN35@basic_stri
$LN36@basic_stri:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN38@basic_stri

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN106@basic_stri
	jmp	SHORT $LN43@basic_stri
$LN44@basic_stri:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN35@basic_stri
$LN38@basic_stri:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN35@basic_stri:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1067 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

	mov	QWORD PTR [rsi], rbx
$LN2@basic_stri:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r14
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1070 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR [rsi+16], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	rdx, OFFSET FLAT:??_C@_0BB@PFCEIHCG@File?5not?5found?3?5@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1071 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbx
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1073 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

	lea	rcx, QWORD PTR [r14+rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r15
	mov	rdx, r12
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1074 :         _Traits::assign(_Ptr[_New_size], _Elem());

	mov	BYTE PTR [rbx+rbp], 0

; 1077 :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN106@basic_stri:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN104@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 856  :         auto& _My_data = _Mypair._Myval2;
; 857  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 858  : 
; 859  :         // initialize basic_string data members
; 860  :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 866  :     }

	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 530  :         return static_cast<int_type>(EOF);

	mov	eax, -1

; 531  :     }

	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z
_TEXT	SEGMENT
_Meta$ = 8
?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z PROC	; std::_Narrow_char_traits<char,int>::not_eof, COMDAT

; 526  :         return _Meta != eof() ? _Meta : !eof();

	xor	eax, eax
	cmp	ecx, -1
	cmove	ecx, eax
	mov	eax, ecx

; 527  :     }

	ret	0
?not_eof@?$_Narrow_char_traits@DH@std@@SAHH@Z ENDP	; std::_Narrow_char_traits<char,int>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 522  :         return _Left == _Right;

	cmp	ecx, edx
	sete	al

; 523  :     }

	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z PROC	; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 518  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, cl

; 519  :     }

	ret	0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ENDP	; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z
_TEXT	SEGMENT
_Meta$ = 8
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z PROC	; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 514  :         return static_cast<_Elem>(_Meta);

	movzx	eax, cl

; 515  :     }

	ret	0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ENDP	; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
_TEXT	SEGMENT
$T1 = 32
this$GSCopy$ = 40
_Pb$7 = 48
_Pn$8 = 56
$T5 = 64
_Nr$9 = 64
__$ArrayPad$ = 80
this$ = 128
_Filename$ = 136
_Mode$dead$ = 144
_Prot$dead$ = 152
$initVBases$dead$ = 160
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 31   :     explicit basic_ifstream(

$LN51:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	xor	ebp, ebp
	mov	DWORD PTR $T1[rsp], ebp

; 32   :         const char* _Filename, ios_base::openmode _Mode = ios_base::in, int _Prot = ios_base::_Default_open_prot)
; 33   :         : _Mybase(_STD addressof(_Filebuffer)) {

	lea	rax, OFFSET FLAT:??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
	mov	QWORD PTR [rcx], rax
	add	rcx, 176				; 000000b0H
	call	QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	mov	DWORD PTR $T1[rsp], 1
	lea	rdi, QWORD PTR [rsi+16]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, rdi
	mov	rcx, rsi
	call	QWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	npad	1
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rcx+rsi], rax
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR [rcx+rsi-4], edx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 167  :     basic_filebuf() : _Mysb() {

	mov	rcx, rdi
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rdi], rax

; 683  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rdi+124], bpl

; 684  :         _Wrotesome = false;

	mov	BYTE PTR [rdi+113], bpl

; 685  : 
; 686  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rdi
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 700  :         _Myfile = _File;

	mov	QWORD PTR [rdi+128], rbp

; 701  :         _State  = _Stinit;

	mov	rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rdi+116], rax

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rdi+104], rbp

; 286  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

	mov	edx, 1
	mov	r8d, 64					; 00000040H
	mov	rcx, rbx
	call	QWORD PTR __imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z
	mov	rbx, rax

; 287  :         if (!_File) {

	test	rax, rax
	je	$LN46@basic_ifst

; 683  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rdi+124], 1

; 684  :         _Wrotesome = false;

	mov	BYTE PTR [rdi+113], bpl

; 685  : 
; 686  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rdi
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 687  : 
; 688  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 689  :             _Elem** _Pb = nullptr;

	mov	QWORD PTR _Pb$7[rsp], rbp

; 690  :             _Elem** _Pn = nullptr;

	mov	QWORD PTR _Pn$8[rsp], rbp

; 691  :             int* _Nr    = nullptr;

	mov	QWORD PTR _Nr$9[rsp], rbp

; 692  : 
; 693  :             ::_get_stream_buffer_pointers(

	lea	r9, QWORD PTR _Nr$9[rsp]
	lea	r8, QWORD PTR _Pn$8[rsp]
	lea	rdx, QWORD PTR _Pb$7[rsp]
	mov	rcx, rbx
	call	QWORD PTR __imp__get_stream_buffer_pointers
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 277  :         _IGfirst = _Gf;

	mov	rax, QWORD PTR _Pb$7[rsp]
	mov	QWORD PTR [rdi+24], rax

; 278  :         _IPfirst = _Pf;

	mov	QWORD PTR [rdi+32], rax

; 279  :         _IGnext  = _Gn;

	mov	rax, QWORD PTR _Pn$8[rsp]
	mov	QWORD PTR [rdi+56], rax

; 280  :         _IPnext  = _Pn;

	mov	QWORD PTR [rdi+64], rax

; 281  :         _IGcount = _Gc;

	mov	rax, QWORD PTR _Nr$9[rsp]
	mov	QWORD PTR [rdi+80], rax

; 282  :         _IPcount = _Pc;

	mov	QWORD PTR [rdi+88], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 700  :         _Myfile = _File;

	mov	QWORD PTR [rdi+128], rbx

; 701  :         _State  = _Stinit;

	mov	rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rdi+116], rax

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rdi+104], rbp

; 292  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rdi
	call	QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
	npad	1
	mov	rcx, rax
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	rbx, rax

; 743  :         if (_Newcvt.always_noconv()) {

	mov	rcx, rax
	call	QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN36@basic_ifst

; 744  :             _Pcvt = nullptr; // nothing to do

	mov	QWORD PTR [rdi+104], rbp

; 745  :         } else { // set up for nontrivial codecvt facet

	jmp	SHORT $LN37@basic_ifst
$LN36@basic_ifst:

; 746  :             _Pcvt = _STD addressof(_Newcvt);

	mov	QWORD PTR [rdi+104], rbx

; 747  :             _Mysb::_Init(); // reset any buffering

	mov	rcx, rdi
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
	npad	1
$LN37@basic_ifst:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

	mov	rcx, QWORD PTR $T5[rsp+8]
	test	rcx, rcx
	je	SHORT $LN43@basic_ifst

; 355  :             delete _Ptr->_Decref();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	test	rax, rax
	je	SHORT $LN43@basic_ifst
	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rcx]
	mov	edx, 1
	mov	rcx, rax
	call	r8
$LN43@basic_ifst:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\fstream

; 35   :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot)) {

	test	rdi, rdi
	jne	SHORT $LN48@basic_ifst
$LN46@basic_ifst:

; 36   :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, 2
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
$LN48@basic_ifst:

; 37   :         }
; 38   :     }

	mov	rax, rsi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 96					; 00000060H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
_Pb$7 = 48
_Pn$8 = 56
$T5 = 64
_Nr$9 = 64
__$ArrayPad$ = 80
this$ = 128
_Filename$ = 136
_Mode$dead$ = 144
_Prot$dead$ = 152
$initVBases$dead$ = 160
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$GSCopy$[rbp]
	add	rcx, 176				; 000000b0H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
_Pb$7 = 48
_Pn$8 = 56
$T5 = 64
_Nr$9 = 64
__$ArrayPad$ = 80
this$ = 128
_Filename$ = 136
_Mode$dead$ = 144
_Prot$dead$ = 152
$initVBases$dead$ = 160
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	rex_jmp	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
_Pb$7 = 48
_Pn$8 = 56
$T5 = 64
_Nr$9 = 64
__$ArrayPad$ = 80
this$ = 128
_Filename$ = 136
_Mode$dead$ = 144
_Prot$dead$ = 152
$initVBases$dead$ = 160
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 16
	jmp	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
_Pb$7 = 48
_Pn$8 = 56
$T5 = 64
_Nr$9 = 64
__$ArrayPad$ = 80
this$ = 128
_Filename$ = 136
_Mode$dead$ = 144
_Prot$dead$ = 152
$initVBases$dead$ = 160
?dtor$5@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$5
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1locale@std@@QEAA@XZ			; std::locale::~locale
?dtor$5@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	r11, QWORD PTR [rcx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 766  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

	lea	r10, QWORD PTR [rcx+112]
	mov	rdx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	lea	r9, QWORD PTR [rcx+80]
	mov	rax, QWORD PTR [r11]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 766  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

	cmp	rax, r10
	je	SHORT $LN27@Set_back

; 767  :             _Set_eback = _Mysb::eback();

	mov	QWORD PTR [rcx+136], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 196  :         return *_IGnext + *_IGcount;

	mov	rax, QWORD PTR [r9]
	movsxd	rcx, DWORD PTR [rax]
	mov	rax, QWORD PTR [rdx+56]
	add	rcx, QWORD PTR [rax]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 768  :             _Set_egptr = _Mysb::egptr();

	mov	QWORD PTR [rdx+144], rcx
$LN27@Set_back:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [r11], r10

; 208  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rdx+56]

; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, r10d
	add	edx, 113				; 00000071H
	mov	QWORD PTR [rax], r10
	mov	rax, QWORD PTR [r9]
	mov	DWORD PTR [rax], edx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 771  :     }

	ret	0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	r9, QWORD PTR [rcx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rcx+112]
	cmp	QWORD PTR [r9], rax
	jne	SHORT $LN11@Reset_back

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rcx+136]
	mov	r8, QWORD PTR [rcx+144]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [r9], rdx

; 208  :         *_IGnext  = _Next;
; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	r8d, edx
	mov	rax, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax], rdx
	mov	rax, QWORD PTR [rcx+80]
	mov	DWORD PTR [rax], r8d
$LN11@Reset_back:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 763  :     }

	ret	0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Newcvt$ = 56
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT

; 742  :     void _Initcvt(const _Cvt& _Newcvt) noexcept { // initialize codecvt pointer

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rdi, rdx

; 743  :         if (_Newcvt.always_noconv()) {

	mov	rcx, rdx
	call	QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN2@Initcvt

; 744  :             _Pcvt = nullptr; // nothing to do

	mov	QWORD PTR [rbx+104], 0

; 748  :         }
; 749  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Initcvt:

; 745  :         } else { // set up for nontrivial codecvt facet
; 746  :             _Pcvt = _STD addressof(_Newcvt);
; 747  :             _Mysb::_Init(); // reset any buffering

	mov	rcx, rbx
	mov	QWORD PTR [rbx+104], rdi

; 748  :         }
; 749  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 745  :         } else { // set up for nontrivial codecvt facet
; 746  :             _Pcvt = _STD addressof(_Newcvt);
; 747  :             _Mysb::_Init(); // reset any buffering

	rex_jmp	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
_TEXT	SEGMENT
_Dest$ = 48
_Str$ = 56
__$ArrayPad$ = 88
this$ = 112
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT

; 705  :     bool _Endwrite() { // put shift to initial conversion state, as needed

$LN28:
	push	rbx
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 706  :         if (!_Pcvt || !_Wrotesome) {

	cmp	QWORD PTR [rcx+104], 0
	mov	rbx, rcx
	je	$LN5@Endwrite
	cmp	BYTE PTR [rcx+113], 0
	je	$LN5@Endwrite

; 708  :         }
; 709  : 
; 710  :         // may have to put
; 711  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

	mov	rax, QWORD PTR [rcx]
	mov	edx, -1
	mov	QWORD PTR [rsp+120], rdi
	call	QWORD PTR [rax+24]
	cmp	eax, -1
	je	$LN16@Endwrite

; 712  :             return false;
; 713  :         }
; 714  : 
; 715  :         constexpr size_t _Codecvt_temp_buf = 32;
; 716  :         char _Str[_Codecvt_temp_buf];
; 717  :         char* _Dest;
; 718  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

	mov	rcx, QWORD PTR [rbx+104]
	lea	rax, QWORD PTR _Dest$[rsp]
	lea	rdx, QWORD PTR [rbx+116]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR _Str$[rsp+32]
	lea	r8, QWORD PTR _Str$[rsp]
	call	QWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z
	test	eax, eax
	je	SHORT $LN7@Endwrite
	sub	eax, 1
	je	SHORT $LN8@Endwrite
	cmp	eax, 2
	jne	SHORT $LN16@Endwrite

; 731  :             }
; 732  : 
; 733  :         case codecvt_base::noconv:
; 734  :             _Wrotesome = false; // homed successfully

	mov	BYTE PTR [rbx+113], 0

; 735  :             return true; // nothing else to do

	mov	al, 1
$LN25@Endwrite:
	mov	rdi, QWORD PTR [rsp+120]

; 736  : 
; 737  :         default:
; 738  :             return false; // conversion failed
; 739  :         }
; 740  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
$LN7@Endwrite:

; 719  :         case codecvt_base::ok:
; 720  :             _Wrotesome = false; // homed successfully

	mov	BYTE PTR [rbx+113], 0
$LN8@Endwrite:

; 721  :             _FALLTHROUGH;
; 722  : 
; 723  :         case codecvt_base::partial:
; 724  :             { // put any generated bytes
; 725  :                 const auto _Count = static_cast<size_t>(_Dest - _Str);

	mov	rdi, QWORD PTR _Dest$[rsp]
	lea	rax, QWORD PTR _Str$[rsp]
	sub	rdi, rax

; 726  :                 if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

	je	SHORT $LN9@Endwrite
	mov	r9, QWORD PTR [rbx+128]
	lea	rcx, QWORD PTR _Str$[rsp]
	mov	r8, rdi
	mov	edx, 1
	call	QWORD PTR __imp_fwrite
	cmp	rdi, rax
	jne	SHORT $LN16@Endwrite
$LN9@Endwrite:

; 728  :                 }
; 729  : 
; 730  :                 return !_Wrotesome;

	cmp	BYTE PTR [rbx+113], 0
	sete	al
	jmp	SHORT $LN25@Endwrite
$LN16@Endwrite:

; 727  :                     return false; // write failed

	xor	al, al
	jmp	SHORT $LN25@Endwrite
$LN5@Endwrite:

; 707  :             return true;

	mov	al, 1

; 736  : 
; 737  :         default:
; 738  :             return false; // conversion failed
; 739  :         }
; 740  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
_Pb$1 = 32
_Pn$2 = 40
_Nr$3 = 48
__$ArrayPad$ = 56
this$ = 80
_File$ = 88
_Which$ = 96
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT

; 678  :     void _Init(FILE* _File, _Initfl _Which) noexcept { // initialize to C stream _File after {new, open, close}

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 679  :         using _State_type = typename _Traits::state_type;
; 680  : 
; 681  :         __PURE_APPDOMAIN_GLOBAL static _State_type _Stinit; // initial state
; 682  : 
; 683  :         _Closef    = _Which == _Openfl;

	cmp	r8d, 1

; 684  :         _Wrotesome = false;

	mov	BYTE PTR [rcx+113], 0
	mov	rdi, rdx
	mov	rbx, rcx
	sete	al
	mov	BYTE PTR [rcx+124], al

; 685  : 
; 686  :         _Mysb::_Init(); // initialize stream buffer base object

	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 687  : 
; 688  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

	xor	esi, esi
	test	rdi, rdi
	je	SHORT $LN6@Init

; 689  :             _Elem** _Pb = nullptr;
; 690  :             _Elem** _Pn = nullptr;
; 691  :             int* _Nr    = nullptr;
; 692  : 
; 693  :             ::_get_stream_buffer_pointers(

	lea	r9, QWORD PTR _Nr$3[rsp]
	mov	QWORD PTR _Pb$1[rsp], rsi
	lea	r8, QWORD PTR _Pn$2[rsp]
	mov	QWORD PTR _Pn$2[rsp], rsi
	lea	rdx, QWORD PTR _Pb$1[rsp]
	mov	QWORD PTR _Nr$3[rsp], rsi
	mov	rcx, rdi
	call	QWORD PTR __imp__get_stream_buffer_pointers
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 277  :         _IGfirst = _Gf;

	mov	rax, QWORD PTR _Pb$1[rsp]
	mov	QWORD PTR [rbx+24], rax

; 278  :         _IPfirst = _Pf;

	mov	QWORD PTR [rbx+32], rax

; 279  :         _IGnext  = _Gn;

	mov	rax, QWORD PTR _Pn$2[rsp]
	mov	QWORD PTR [rbx+56], rax

; 280  :         _IPnext  = _Pn;

	mov	QWORD PTR [rbx+64], rax

; 281  :         _IGcount = _Gc;

	mov	rax, QWORD PTR _Nr$3[rsp]
	mov	QWORD PTR [rbx+80], rax

; 282  :         _IPcount = _Pc;

	mov	QWORD PTR [rbx+88], rax
$LN6@Init:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 701  :         _State  = _Stinit;

	mov	rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rbx+116], rax
	mov	QWORD PTR [rbx+128], rdi

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rsi

; 703  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT

; 353  :     basic_filebuf* close() {

$LN34:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 354  :         basic_filebuf* _Ans;
; 355  :         if (_Myfile) { // put any homing sequence and close file

	cmp	QWORD PTR [rcx+128], 0
	mov	rdi, rcx
	je	SHORT $LN2@close
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 180  :         return *_IGfirst;

	mov	r8, QWORD PTR [rcx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 760  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rcx+112]

; 354  :         basic_filebuf* _Ans;
; 355  :         if (_Myfile) { // put any homing sequence and close file

	mov	QWORD PTR [rsp+56], rbx

; 760  :         if (_Mysb::eback() == &_Mychar) {

	cmp	QWORD PTR [r8], rax
	jne	SHORT $LN17@close

; 761  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rcx+144]
	mov	rcx, QWORD PTR [rcx+136]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 207  :         *_IGfirst = _First;

	mov	QWORD PTR [r8], rcx

; 208  :         *_IGnext  = _Next;
; 209  :         *_IGcount = static_cast<int>(_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR [rdi+80]
	mov	DWORD PTR [rax], edx
$LN17@close:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 359  :             if (!_Endwrite()) {

	mov	rcx, rdi
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 360  :                 _Ans = nullptr;
; 361  :             }
; 362  : 
; 363  :             if (_CSTD fclose(_Myfile) != 0) {

	mov	rcx, QWORD PTR [rdi+128]
	xor	ebx, ebx
	test	al, al
	cmovne	rbx, rdi
	call	QWORD PTR __imp_fclose

; 364  :                 _Ans = nullptr;
; 365  :             }
; 366  :         } else {

	xor	esi, esi
	test	eax, eax
	cmove	rsi, rbx
	mov	rbx, QWORD PTR [rsp+56]
	jmp	SHORT $LN3@close
$LN2@close:

; 367  :             _Ans = nullptr;

	xor	esi, esi
$LN3@close:

; 686  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rdi
	mov	BYTE PTR [rdi+124], 0
	mov	BYTE PTR [rdi+113], 0
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 687  : 
; 688  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 689  :             _Elem** _Pb = nullptr;
; 690  :             _Elem** _Pn = nullptr;
; 691  :             int* _Nr    = nullptr;
; 692  : 
; 693  :             ::_get_stream_buffer_pointers(
; 694  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 695  :             int* _Nw = _Nr;
; 696  : 
; 697  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 698  :         }
; 699  : 
; 700  :         _Myfile = _File;
; 701  :         _State  = _Stinit;

	mov	rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit

; 368  :         }
; 369  : 
; 370  :         _Init(nullptr, _Closefl);
; 371  :         return _Ans;

	mov	rax, rsi

; 372  :     }

	mov	rsi, QWORD PTR [rsp+64]

; 701  :         _State  = _Stinit;

	mov	QWORD PTR [rdi+116], rcx
	mov	QWORD PTR [rdi+128], 0

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rdi+104], 0

; 372  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::is_open, COMDAT

; 277  :         return static_cast<bool>(_Myfile);

	cmp	QWORD PTR [rcx+128], 0
	setne	al

; 278  :     }

	ret	0
?is_open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::is_open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 64
_Ptr$ = 72
_Count$ = 80
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 982  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN18:
	sub	rsp, 56					; 00000038H
	mov	rax, rdx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN12@deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN11@deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN12@deallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 983  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 984  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 986  :     }

	add	rsp, 56					; 00000038H

; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN11@deallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN15@deallocate:
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 65   :         // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
; 66   :         // basic_filebuf would set _Fpos.
; 67   :         return _Myoff + _Fpos;

	mov	rax, QWORD PTR [rcx+8]
	add	rax, QWORD PTR [rcx]

; 68   :     }

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT

; 57   :         return _Mystate;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx], rax
	mov	rax, rdx

; 58   :     }

	ret	0
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
this$ = 8
_State$ = 16
_Fileposition$ = 24
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 54   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

	mov	QWORD PTR [rcx], r8
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	mov	QWORD PTR [rcx+16], rdx
	ret	0
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 52   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], -1
	mov	QWORD PTR [rcx+8], 0
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3251 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right) {

$LN65:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdx+16]

; 3251 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right) {

	mov	rbx, rdx

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdx+24]

; 3251 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right) {

	xor	esi, esi

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	cmp	rcx, rdx
	jae	SHORT $LN6@operator

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN58@operator

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN58@operator:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r8b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], sil

; 2299 :             return;

	jmp	SHORT $LN5@operator
$LN6@operator:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	movzx	r9d, r8b
	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN5@operator:
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rdi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rdi+16], rsi

; 3252 :     _Left.push_back(_Right);
; 3253 :     return _STD move(_Left);

	mov	rax, rdi

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rdi+24], rsi

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	YMMWORD PTR [rdi], ymm0

; 3252 :     _Left.push_back(_Right);
; 3253 :     return _STD move(_Left);

	mov	BYTE PTR [rbx], sil
	mov	QWORD PTR [rbx+16], rsi
	mov	QWORD PTR [rbx+24], 15
	vzeroupper

; 3254 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>, COMDAT

; 871  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN99:
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 56					; 00000038H

; 872  :         auto& _My_data = _Mypair._Myval2;
; 873  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 874  : 
; 875  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 876  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 877  :         } else {
; 878  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 879  :         }
; 880  : 
; 881  :         if (_Count > max_size()) {

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	mov	rdi, r8
	mov	r14, rdx
	mov	rsi, rcx
	cmp	r8, rbp
	ja	$LN96@Construct

; 883  :         }
; 884  : 
; 885  :         auto& _Al       = _Getal();
; 886  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 887  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 888  : 
; 889  :         if (_Count <= _Small_string_capacity) {

	cmp	r8, 15
	ja	SHORT $LN3@Construct

; 890  :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r8

; 891  :             _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rcx+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 898  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR [rdi+rsi], 0

; 929  :     }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@Construct:

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, rdi
	mov	QWORD PTR [rsp+48], rbx
	or	rax, 15
	cmp	rax, rbp

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN13@Construct

; 2980 :             return _Max;

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN38@Construct:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN39@Construct
	xor	ebx, ebx
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rbx
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN13@Construct:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	ecx, 22
	mov	rbp, rax
	cmp	rax, rcx
	cmovb	rbp, rcx

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbp+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN31@Construct

; 228  :         return nullptr;

	xor	ebx, ebx
	jmp	SHORT $LN30@Construct
$LN31@Construct:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN33@Construct

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN97@Construct
	jmp	SHORT $LN38@Construct
$LN39@Construct:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN30@Construct
$LN33@Construct:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN30@Construct:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 913  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rsi], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 915  :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rsi+16], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rcx, rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 916  :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 922  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0
	mov	rbx, QWORD PTR [rsp+48]

; 929  :     }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN96@Construct:

; 882  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN97@Construct:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN94@Construct:
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
_TEXT	SEGMENT
$T20 = 32
$T26 = 32
$T27 = 32
input$ = 80
i$ = 88
??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z PROC ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >, COMDAT

; 297  : 		static inline size_t skipWhitespaceSIMD16(const Container& input, size_t i) {

$LN113:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 64					; 00000040H

; 298  : 			const size_t size = input.size();
; 299  : 
; 300  : 			static const __m128i ws_space = _mm_set1_epi8(' ');

	mov	rax, QWORD PTR gs:88
	mov	rbx, rdx
	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rcx
	mov	r14d, OFFSET FLAT:_Init_thread_epoch
	add	r14, QWORD PTR [rax]
	mov	eax, DWORD PTR [r14]
	cmp	DWORD PTR ?$TSS0@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, eax ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS0
	jle	SHORT $LN2@skipWhites
	lea	rcx, OFFSET FLAT:?$TSS0@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS0
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, -1 ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS0
	jne	SHORT $LN2@skipWhites
	vmovdqu	xmm0, XMMWORD PTR __xmm@20202020202020202020202020202020
	lea	rcx, OFFSET FLAT:?$TSS0@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS0
	vmovdqu	XMMWORD PTR ?ws_space@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_space
	call	_Init_thread_footer
$LN2@skipWhites:

; 301  : 			static const __m128i ws_tab = _mm_set1_epi8('\t');

	mov	eax, DWORD PTR [r14]
	cmp	DWORD PTR ?$TSS1@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, eax ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS1
	jle	SHORT $LN3@skipWhites
	lea	rcx, OFFSET FLAT:?$TSS1@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS1
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS1@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, -1 ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS1
	jne	SHORT $LN3@skipWhites
	vmovdqu	xmm0, XMMWORD PTR __xmm@09090909090909090909090909090909
	lea	rcx, OFFSET FLAT:?$TSS1@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS1
	vmovdqu	XMMWORD PTR ?ws_tab@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_tab
	call	_Init_thread_footer
$LN3@skipWhites:

; 302  : 			static const __m128i ws_cr = _mm_set1_epi8('\r');

	mov	eax, DWORD PTR [r14]
	cmp	DWORD PTR ?$TSS2@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, eax ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS2
	jle	SHORT $LN4@skipWhites
	lea	rcx, OFFSET FLAT:?$TSS2@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS2
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS2@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, -1 ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS2
	jne	SHORT $LN4@skipWhites
	vmovdqu	xmm0, XMMWORD PTR __xmm@0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d
	lea	rcx, OFFSET FLAT:?$TSS2@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS2
	vmovdqu	XMMWORD PTR ?ws_cr@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_cr
	call	_Init_thread_footer
$LN4@skipWhites:

; 303  : 			static const __m128i ws_lf = _mm_set1_epi8('\n');

	mov	eax, DWORD PTR [r14]
	cmp	DWORD PTR ?$TSS3@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, eax ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS3
	jle	SHORT $LN59@skipWhites
	lea	rcx, OFFSET FLAT:?$TSS3@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS3
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS3@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, -1 ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS3
	jne	SHORT $LN59@skipWhites
	vmovdqu	xmm0, XMMWORD PTR __xmm@0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a
	lea	rcx, OFFSET FLAT:?$TSS3@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::$TSS3
	vmovdqu	XMMWORD PTR ?ws_lf@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_lf
	call	_Init_thread_footer
$LN59@skipWhites:

; 304  : 
; 305  : 			__m128i chunk;
; 306  : 			uint16_t mask;
; 307  : 
; 308  : 			while (i + 16 <= size) {

	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rsi
	ja	SHORT $LN68@skipWhites
	npad	6
$LL6@skipWhites:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rdx, QWORD PTR [rdi]
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 309  : 				chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&input[i]));

	vmovdqu	xmm4, XMMWORD PTR [rdx+rbx]

; 310  : 
; 311  : 				mask = ~_mm_movemask_epi8(_mm_or_si128(

	vpcmpeqb xmm1, xmm4, XMMWORD PTR ?ws_lf@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_lf
	vpcmpeqb xmm0, xmm4, XMMWORD PTR ?ws_cr@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_cr
	vpcmpeqb xmm2, xmm4, XMMWORD PTR ?ws_tab@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_tab
	vpor	xmm3, xmm1, xmm0
	vpcmpeqb xmm1, xmm4, XMMWORD PTR ?ws_space@?1???$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >'::`2'::ws_space
	vpor	xmm0, xmm2, xmm1
	vpor	xmm2, xmm3, xmm0
	vpmovmskb eax, xmm2
	not	ax

; 312  : 					_mm_or_si128(_mm_cmpeq_epi8(chunk, ws_space), _mm_cmpeq_epi8(chunk, ws_tab)),
; 313  : 					_mm_or_si128(_mm_cmpeq_epi8(chunk, ws_cr), _mm_cmpeq_epi8(chunk, ws_lf))));
; 314  : 
; 315  : 				if (mask != 0) {

	test	ax, ax
	je	SHORT $LN11@skipWhites

; 316  : 					size_t j = i + CTZ16(mask);

	tzcnt	ax, ax
	movzx	eax, ax
	add	rax, rbx

; 317  : 					if (input[j] == '/')

	cmp	BYTE PTR [rax+rdx], 47			; 0000002fH
	jne	$LN1@skipWhites

; 318  : 					{
; 319  : 						i = skipCommentSIMD16(input, j) + 1;

	mov	rdx, rax
	mov	rcx, rdi
	call	??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipCommentSIMD16<MappedFile<0> >
	lea	rbx, QWORD PTR [rax+1]

; 320  : 						continue;

	jmp	SHORT $LN65@skipWhites
$LN11@skipWhites:

; 321  : 					}
; 322  : 					return j;
; 323  : 				}
; 324  : 
; 325  : 				i += 16;

	add	rbx, 16
$LN65@skipWhites:

; 304  : 
; 305  : 			__m128i chunk;
; 306  : 			uint16_t mask;
; 307  : 
; 308  : 			while (i + 16 <= size) {

	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rsi
	jbe	SHORT $LL6@skipWhites
$LN68@skipWhites:

; 326  : 			}
; 327  : 
; 328  : 			char c;
; 329  : 			for (; i < input.size(); ++i)

	mov	rcx, QWORD PTR [rdi+8]
	cmp	rbx, rcx
	jae	SHORT $LN69@skipWhites
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rdx, QWORD PTR [rdi]
	mov	r9, 4294977024				; 0000000100002600H
	npad	7
$LL10@skipWhites:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 331  : 				c = input[i];

	movsx	r8, BYTE PTR [rdx+rbx]

; 332  : 				if (whitespaceCharacters[0] == c
; 333  : 					|| whitespaceCharacters[1] == c
; 334  : 					|| whitespaceCharacters[2] == c
; 335  : 					|| whitespaceCharacters[3] == c) {

	cmp	r8b, 32					; 00000020H
	ja	SHORT $LN82@skipWhites
	bt	r9, r8
	jb	SHORT $LN8@skipWhites
$LN82@skipWhites:

; 336  : 					continue;
; 337  : 				}
; 338  : 				else if (c == commentStart) {

	cmp	r8b, 47					; 0000002fH
	jne	SHORT $LN69@skipWhites

; 220  : 			++i;

	lea	rax, QWORD PTR [rbx+1]
	mov	rbx, rax

; 221  : 			if (i >= input.size()) throw std::runtime_error("Invalid comment syntax");

	cmp	rax, rcx
	jae	$LN64@skipWhites

; 222  : 			char c = input[i];

	movzx	eax, BYTE PTR [rdx+rax]

; 223  : 			++i;

	inc	rbx

; 224  : 			if (c == lineComment) {

	cmp	al, r8b
	jne	SHORT $LN44@skipWhites

; 225  : 				for (; i < input.size() && input[i] != '\n'; ++i); // skip to end of line

	cmp	rbx, rcx
	jae	SHORT $LN8@skipWhites
$LL39@skipWhites:
	cmp	BYTE PTR [rdx+rbx], 10
	je	SHORT $LN8@skipWhites
	inc	rbx
	cmp	rbx, rcx
	jb	SHORT $LL39@skipWhites
$LN8@skipWhites:

; 326  : 			}
; 327  : 
; 328  : 			char c;
; 329  : 			for (; i < input.size(); ++i)

	inc	rbx
	cmp	rbx, rcx
	jb	SHORT $LL10@skipWhites
$LN69@skipWhites:

; 339  : 					i = skipCommentScalar(input, i);
; 340  : 					continue;
; 341  : 				}
; 342  : 				return i;
; 343  : 			}
; 344  : 			return i;
; 345  : 		};

	mov	rax, rbx
$LN1@skipWhites:
	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN44@skipWhites:

; 228  : 			else if (c == blockCommentStart) {

	cmp	al, 42					; 0000002aH
	jne	SHORT $LN46@skipWhites
	npad	5
$LL42@skipWhites:

; 229  : 				for (; i < input.size(); ++i)

	cmp	rbx, rcx
	jae	SHORT $LN41@skipWhites

; 230  : 				{
; 231  : 					if (input[i] == blockCommentEnd && ++i < input.size() && input[i] == commentStart) {

	cmp	BYTE PTR [rdx+rbx], 42			; 0000002aH
	jne	SHORT $LN40@skipWhites
	inc	rbx
	cmp	rbx, rcx
	jae	SHORT $LN40@skipWhites
	cmp	BYTE PTR [rdx+rbx], 47			; 0000002fH
	je	SHORT $LN8@skipWhites
$LN40@skipWhites:

; 229  : 				for (; i < input.size(); ++i)

	inc	rbx
	jmp	SHORT $LL42@skipWhites
$LN46@skipWhites:

; 236  : 			}
; 237  : 			throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T27[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T27[rsp]
	call	_CxxThrowException
	int	3
$LN64@skipWhites:

; 221  : 			if (i >= input.size()) throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T20[rsp]
	call	_CxxThrowException
	int	3
$LN41@skipWhites:

; 232  : 						return i;
; 233  : 					}
; 234  : 				}
; 235  : 				throw std::runtime_error("Endless block comment");

	lea	rdx, OFFSET FLAT:??_C@_0BG@PEGDFFCL@Endless?5block?5comment@
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T26[rsp]
	call	_CxxThrowException
	int	3
$LN110@skipWhites:
??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ENDP ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
_TEXT	SEGMENT
$T28 = 48
$T30 = 48
$T32 = 48
$T35 = 48
$T39 = 48
$T54 = 48
$T69 = 48
$T70 = 48
object$ = 72
$T34 = 80
__$ReturnUdt$GSCopy$ = 80
$T26 = 96
$T15 = 96
$T27 = 128
$T67 = 128
name$73 = 160
$T68 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z PROC ; Json::Parser::parseObject<MappedFile<0> >, COMDAT

; 500  : 		{

$LN258:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 208				; 000000d0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-169], rax
	mov	rsi, r8
	mov	rdi, rdx
	mov	r15, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-169], rcx
	mov	QWORD PTR object$[rbp-169], 0

; 501  : 			std::unique_ptr<Object> object = std::make_unique<Object>();

	lea	rcx, QWORD PTR object$[rbp-169]
	call	??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ ; std::make_unique<Json::Object,0>
	npad	1

; 503  : 			for (; i < input.size();)

	mov	rdx, QWORD PTR [rsi]
	cmp	rdx, QWORD PTR [rdi+8]
	jae	$LN3@parseObjec

; 504  : 			{			
; 505  : 				i = skipWhitespace(input, ++i);

	inc	rdx
	mov	QWORD PTR [rsi], rdx

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >
	mov	rcx, rax

; 504  : 			{			
; 505  : 				i = skipWhitespace(input, ++i);

	mov	QWORD PTR [rsi], rax

; 506  : 				c = input[i];

	mov	rax, QWORD PTR [rdi]
	movzx	edx, BYTE PTR [rcx+rax]

; 507  : 				if (c == stringStart) {

	mov	rbx, QWORD PTR object$[rbp-169]
	cmp	dl, 34					; 00000022H
	jne	$LN5@parseObjec
	mov	r12, 1099511628211			; 00000100000001b3H
	npad	13
$LL4@parseObjec:

; 508  : 					std::string name = parseString(input, i);

	mov	r8, rsi
	mov	rdx, rdi
	lea	rcx, QWORD PTR name$73[rbp-169]
	call	??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseString<MappedFile<0> >
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR name$73[rbp-169]

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR name$73[rbp-145], 15
	cmova	rdx, QWORD PTR name$73[rbp-169]
	xor	eax, eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2292 :     return _Fnv1a_append_bytes(

	mov	r9, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	r8, QWORD PTR name$73[rbp-153]
	test	r8, r8
	je	SHORT $LN58@parseObjec
	npad	13
$LL248@parseObjec:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rdx+rax]
	xor	r9, rcx

; 2261 :         _Val *= _FNV_prime;

	imul	r9, r12

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rax
	cmp	rax, r8
	jb	SHORT $LL248@parseObjec
$LN58@parseObjec:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1221 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	lea	r8, QWORD PTR name$73[rbp-169]
	lea	rdx, QWORD PTR $T15[rbp-169]
	lea	rcx, QWORD PTR [rbx+8]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rcx, QWORD PTR [rax+8]

; 1222 :             if (_Target) {

	test	rcx, rcx
	jne	SHORT $LN62@parseObjec

; 1223 :                 return _Target;
; 1224 :             }
; 1225 : 
; 1226 :             return _List._Mypair._Myval2._Myhead;

	mov	rcx, QWORD PTR [rbx+16]
$LN62@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 509  : 					if (object->m_values.find(name) != object->m_values.end())

	cmp	rcx, QWORD PTR [rbx+16]
	jne	$LN237@parseObjec

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rdx, QWORD PTR [rsi]
	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >
	mov	rdx, rax

; 511  : 					i = skipWhitespace(input, i);

	mov	QWORD PTR [rsi], rax

; 512  : 					if (i == input.size())

	cmp	rax, QWORD PTR [rdi+8]
	je	$LN238@parseObjec

; 514  : 					else if (input[i] != nameSeparator)

	mov	rax, QWORD PTR [rdi]
	cmp	BYTE PTR [rdx+rax], 58			; 0000003aH
	jne	$LN239@parseObjec

; 516  : 
; 517  : 					i = skipWhitespace(input, ++i);

	inc	rdx
	mov	QWORD PTR [rsi], rdx

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >

; 516  : 
; 517  : 					i = skipWhitespace(input, ++i);

	mov	QWORD PTR [rsi], rax

; 518  : 					object->m_values.emplace(

	mov	r8, rsi
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T34[rbp-169]
	call	??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseValue<MappedFile<0> >
	npad	1
	mov	r9, rax
	lea	r8, QWORD PTR name$73[rbp-169]
	lea	rdx, QWORD PTR $T35[rbp-169]
	lea	rcx, QWORD PTR [rbx+8]
	call	??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR $T34[rbp-169]
	test	rcx, rcx
	je	SHORT $LN131@parseObjec

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN131@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rdx, QWORD PTR [rsi]
	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >
	mov	rcx, rax

; 519  : 						std::move(name), std::move(parseValue(input, i)));
; 520  : 					i = skipWhitespace(input, i);

	mov	QWORD PTR [rsi], rax

; 521  : 					if (i == input.size())

	cmp	rax, QWORD PTR [rdi+8]
	je	$LN240@parseObjec

; 523  : 					else if (input[i] != valueSeparator)

	mov	rax, QWORD PTR [rdi]
	movzx	edx, BYTE PTR [rcx+rax]
	cmp	dl, 44					; 0000002cH
	jne	$LN241@parseObjec
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR name$73[rbp-145]
	cmp	rdx, 15
	jbe	SHORT $LN158@parseObjec

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR name$73[rbp-169]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN166@parseObjec

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	$LN210@parseObjec
$LN166@parseObjec:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN158@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 503  : 			for (; i < input.size();)

	mov	rdx, QWORD PTR [rsi]
	cmp	rdx, QWORD PTR [rdi+8]
	jae	$LN3@parseObjec

; 504  : 			{			
; 505  : 				i = skipWhitespace(input, ++i);

	inc	rdx
	mov	QWORD PTR [rsi], rdx

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >
	mov	rcx, rax

; 504  : 			{			
; 505  : 				i = skipWhitespace(input, ++i);

	mov	QWORD PTR [rsi], rax

; 506  : 				c = input[i];

	mov	rax, QWORD PTR [rdi]
	movzx	edx, BYTE PTR [rcx+rax]

; 507  : 				if (c == stringStart) {

	cmp	dl, 34					; 00000022H
	je	$LL4@parseObjec
$LN5@parseObjec:

; 531  : 					}
; 532  : 				}
; 533  : 				else if (c == endObject)

	cmp	dl, 125					; 0000007dH
	jne	$LN16@parseObjec

; 534  : 				{
; 535  : 					++i;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rsi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r15], rbx
$LN203@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 543  : 		};

	mov	rax, r15
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-169]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 208				; 000000d0H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN241@parseObjec:

; 524  : 					{
; 525  : 						if (input[i] == endObject)

	cmp	dl, 125					; 0000007dH
	jne	$LN14@parseObjec

; 526  : 						{
; 527  : 							++i;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rsi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r15], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR name$73[rbp-145]
	cmp	rdx, 15
	jbe	SHORT $LN203@parseObjec

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR name$73[rbp-169]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN211@parseObjec

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN211@parseObjec
$LN210@parseObjec:
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN211@parseObjec:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 528  : 							return object;

	jmp	$LN203@parseObjec
$LN16@parseObjec:

; 536  : 					return object;
; 537  : 				}
; 538  : 				else {
; 539  : 					throw std::runtime_error("Invalid object syntax: " + std::to_string(c));

	movsx	edx, dl
	lea	rcx, QWORD PTR $T67[rbp-169]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
	mov	r8, rax
	lea	rcx, QWORD PTR $T68[rbp-169]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T69[rbp-169]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T69[rbp-169]
	call	_CxxThrowException
	npad	1
$LN3@parseObjec:

; 540  : 				}				
; 541  : 			}
; 542  : 			throw std::runtime_error("Endless object");

	lea	rdx, OFFSET FLAT:??_C@_0P@JPNLNIKK@Endless?5object@
	lea	rcx, QWORD PTR $T70[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T70[rbp-169]
	call	_CxxThrowException
	npad	1
$LN14@parseObjec:

; 529  : 						}
; 530  : 						else throw std::runtime_error("No value separator after object value");

	lea	rdx, OFFSET FLAT:??_C@_0CG@LKKKBDCI@No?5value?5separator?5after?5object@
	lea	rcx, QWORD PTR $T54[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T54[rbp-169]
	call	_CxxThrowException
	int	3
$LN240@parseObjec:

; 522  : 						throw std::runtime_error("Endless object");

	lea	rdx, OFFSET FLAT:??_C@_0P@JPNLNIKK@Endless?5object@
	lea	rcx, QWORD PTR $T39[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T39[rbp-169]
	call	_CxxThrowException
	int	3
$LN239@parseObjec:

; 515  : 						throw std::runtime_error("No name separator after object key");

	lea	rdx, OFFSET FLAT:??_C@_0CD@DNDGJFLJ@No?5name?5separator?5after?5object?5@
	lea	rcx, QWORD PTR $T32[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T32[rbp-169]
	call	_CxxThrowException
	int	3
$LN238@parseObjec:

; 513  : 						throw std::runtime_error("Endless object");

	lea	rdx, OFFSET FLAT:??_C@_0P@JPNLNIKK@Endless?5object@
	lea	rcx, QWORD PTR $T30[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T30[rbp-169]
	call	_CxxThrowException
	int	3
$LN237@parseObjec:

; 510  : 						throw std::runtime_error(std::string("Duplicate key: ") + name);

	lea	rdx, OFFSET FLAT:??_C@_0BA@IDEJNKDC@Duplicate?5key?3?5@
	lea	rcx, QWORD PTR $T26[rbp-169]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, QWORD PTR name$73[rbp-169]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T27[rbp-169]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T28[rbp-169]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T28[rbp-169]
	call	_CxxThrowException
	int	3
$LN255@parseObjec:
??$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ENDP ; Json::Parser::parseObject<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 48
$T30 = 48
$T32 = 48
$T35 = 48
$T39 = 48
$T54 = 48
$T69 = 48
$T70 = 48
object$ = 72
$T34 = 80
__$ReturnUdt$GSCopy$ = 80
$T26 = 96
$T15 = 96
$T27 = 128
$T67 = 128
name$73 = 160
$T68 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$0@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$0
	lea	rcx, QWORD PTR object$[rdx]
	jmp	??1?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::~unique_ptr<Json::Object,std::default_delete<Json::Object> >
?dtor$0@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 48
$T30 = 48
$T32 = 48
$T35 = 48
$T39 = 48
$T54 = 48
$T69 = 48
$T70 = 48
object$ = 72
$T34 = 80
__$ReturnUdt$GSCopy$ = 80
$T26 = 96
$T15 = 96
$T27 = 128
$T67 = 128
name$73 = 160
$T68 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$1@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$1
	lea	rcx, QWORD PTR name$73[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 48
$T30 = 48
$T32 = 48
$T35 = 48
$T39 = 48
$T54 = 48
$T69 = 48
$T70 = 48
object$ = 72
$T34 = 80
__$ReturnUdt$GSCopy$ = 80
$T26 = 96
$T15 = 96
$T27 = 128
$T67 = 128
name$73 = 160
$T68 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$2@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T26[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 48
$T30 = 48
$T32 = 48
$T35 = 48
$T39 = 48
$T54 = 48
$T69 = 48
$T70 = 48
object$ = 72
$T34 = 80
__$ReturnUdt$GSCopy$ = 80
$T26 = 96
$T15 = 96
$T27 = 128
$T67 = 128
name$73 = 160
$T68 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$3@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$3
	lea	rcx, QWORD PTR $T27[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 48
$T30 = 48
$T32 = 48
$T35 = 48
$T39 = 48
$T54 = 48
$T69 = 48
$T70 = 48
object$ = 72
$T34 = 80
__$ReturnUdt$GSCopy$ = 80
$T26 = 96
$T15 = 96
$T27 = 128
$T67 = 128
name$73 = 160
$T68 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$4@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$4
	lea	rcx, QWORD PTR $T34[rdx]
	jmp	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
?dtor$4@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 48
$T30 = 48
$T32 = 48
$T35 = 48
$T39 = 48
$T54 = 48
$T69 = 48
$T70 = 48
object$ = 72
$T34 = 80
__$ReturnUdt$GSCopy$ = 80
$T26 = 96
$T15 = 96
$T27 = 128
$T67 = 128
name$73 = 160
$T68 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$6@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$6
	lea	rcx, QWORD PTR $T67[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 48
$T30 = 48
$T32 = 48
$T35 = 48
$T39 = 48
$T54 = 48
$T69 = 48
$T70 = 48
object$ = 72
$T34 = 80
__$ReturnUdt$GSCopy$ = 80
$T26 = 96
$T15 = 96
$T27 = 128
$T67 = 128
name$73 = 160
$T68 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$7@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$7
	lea	rcx, QWORD PTR $T68[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0???$parseObject@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<MappedFile<0> >'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
_TEXT	SEGMENT
$T21 = 32
$T2 = 32
__$ReturnUdt$GSCopy$ = 32
$T45 = 48
$T58 = 48
$T59 = 48
array$ = 72
__$ReturnUdt$ = 128
input$ = 136
i$ = 144
??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z PROC ; Json::Parser::parseArray<MappedFile<0> >, COMDAT

; 471  : 		{

$LN170:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rdi, r8
	mov	rbx, rdx
	mov	r14, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	ebp, ebp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r15, rax
	mov	QWORD PTR $T2[rsp], rax
	vpxor	xmm0, xmm0, xmm0
	vmovups	YMMWORD PTR [rax], ymm0
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h

; 17   : 		Array() : Value() {};

	lea	rax, OFFSET FLAT:??_7Array@Json@@6B@
	mov	QWORD PTR [r15], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r15+8], rbp
	mov	QWORD PTR [r15+16], rbp
	mov	QWORD PTR [r15+24], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR array$[rsp], r15
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 473  : 			for (; i < input.size();)

	mov	rax, QWORD PTR [rdi]
	cmp	rax, QWORD PTR [rbx+8]
	jae	$LN3@parseArray
$LL4@parseArray:

; 474  : 			{
; 475  : 				i = skipWhitespace(input, ++i);

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rdi], rdx

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rcx, rbx
	vzeroupper
	call	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >
	mov	rcx, rax

; 474  : 			{
; 475  : 				i = skipWhitespace(input, ++i);

	mov	QWORD PTR [rdi], rax

; 476  : 				if (input[i] == endArray)

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rcx+rax], 93			; 0000005dH
	je	$LN159@parseArray

; 480  : 				}
; 481  : 				array->m_values.emplace_back(std::move(parseValue(input, i)));

	mov	r8, rdi
	mov	rdx, rbx
	lea	rcx, QWORD PTR $T21[rsp]
	call	??$parseValue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ; Json::Parser::parseValue<MappedFile<0> >
	mov	r8, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r15+16]
	cmp	rdx, QWORD PTR [r15+24]
	je	SHORT $LN44@parseArray
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rax]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 869  :         ++_Mylast;

	add	QWORD PTR [r15+16], 8

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN43@parseArray
$LN44@parseArray:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	rcx, QWORD PTR [r15+8]
	call	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
	npad	1
$LN43@parseArray:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR $T21[rsp]
	test	rcx, rcx
	je	SHORT $LN86@parseArray

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN86@parseArray:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	call	??$skipWhitespaceSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<MappedFile<0> >

; 482  : 				i = skipWhitespace(input, i);

	mov	QWORD PTR [rdi], rax

; 483  : 				if (i == input.size())

	mov	rdx, QWORD PTR [rbx+8]
	cmp	rax, rdx
	je	SHORT $LN160@parseArray

; 485  : 				else if (input[i] != valueSeparator)

	mov	rcx, QWORD PTR [rbx]
	movzx	r8d, BYTE PTR [rax+rcx]
	cmp	r8b, 44					; 0000002cH
	jne	SHORT $LN161@parseArray

; 473  : 			for (; i < input.size();)

	cmp	rax, rdx
	jae	SHORT $LN3@parseArray
	jmp	$LL4@parseArray
$LN161@parseArray:

; 486  : 				{
; 487  : 					if (input[i] == endArray)

	cmp	r8b, 93					; 0000005dH
	jne	SHORT $LN9@parseArray

; 488  : 					{
; 489  : 						++i;

	inc	rax
$LN167@parseArray:

; 496  : 		}

	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [r14], r15
	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+152]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN159@parseArray:

; 477  : 				{
; 478  : 					++i;

	lea	rax, QWORD PTR [rcx+1]

; 479  : 					return array;

	jmp	SHORT $LN167@parseArray
$LN160@parseArray:

; 484  : 					throw std::runtime_error("Endless array");

	lea	rdx, OFFSET FLAT:??_C@_0O@ELDHGBOG@Endless?5array@
	lea	rcx, QWORD PTR $T45[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T45[rsp]
	call	_CxxThrowException
	int	3
$LN3@parseArray:

; 493  : 				}
; 494  : 			}
; 495  : 			throw std::runtime_error("Endless array");

	lea	rdx, OFFSET FLAT:??_C@_0O@ELDHGBOG@Endless?5array@
	lea	rcx, QWORD PTR $T59[rsp]
	vzeroupper
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T59[rsp]
	call	_CxxThrowException
	int	3
$LN9@parseArray:

; 490  : 						return array;
; 491  : 					}
; 492  : 					else throw std::runtime_error("No value separator after array value");

	lea	rdx, OFFSET FLAT:??_C@_0CF@PAAGCNKK@No?5value?5separator?5after?5array?5@
	lea	rcx, QWORD PTR $T58[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T58[rsp]
	call	_CxxThrowException
	int	3
$LN166@parseArray:
??$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ENDP ; Json::Parser::parseArray<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T21 = 32
$T2 = 32
__$ReturnUdt$GSCopy$ = 32
$T45 = 48
$T58 = 48
$T59 = 48
array$ = 72
__$ReturnUdt$ = 128
input$ = 136
i$ = 144
?dtor$0@?0???$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseArray<MappedFile<0> >'::`1'::dtor$0
	lea	rcx, QWORD PTR array$[rdx]
	jmp	??1?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::~unique_ptr<Json::Array,std::default_delete<Json::Array> >
?dtor$0@?0???$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseArray<MappedFile<0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T21 = 32
$T2 = 32
__$ReturnUdt$GSCopy$ = 32
$T45 = 48
$T58 = 48
$T59 = 48
array$ = 72
__$ReturnUdt$ = 128
input$ = 136
i$ = 144
?dtor$2@?0???$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseArray<MappedFile<0> >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
?dtor$2@?0???$parseArray@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseArray<MappedFile<0> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
_TEXT	SEGMENT
$T1 = 32
$T4 = 40
$T17 = 40
__$ReturnUdt$GSCopy$ = 64
__$ReturnUdt$ = 112
input$ = 120
i$ = 128
??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z PROC ; Json::Parser::parseString<MappedFile<0> >, COMDAT

; 403  : 		{

$LN110:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	DWORD PTR $T1[rsp], 1

; 404  : 			++i;

	inc	QWORD PTR [r8]
	mov	rax, QWORD PTR [r8]

; 405  : 			size_t size = 0;

	xor	edx, edx

; 406  : 			// Find string end to calculate approximate size
; 407  : 			size_t end = i;
; 408  : 			for (; end < input.size(); ++end, ++size) {

	mov	r8, QWORD PTR [rsi+8]
	cmp	rax, r8
	jae	$LN107@parseStrin
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	r9, QWORD PTR [rsi]
$LL4@parseStrin:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 409  : 				if (input[end] == stringEnd) break;

	movzx	ecx, BYTE PTR [r9+rax]
	cmp	cl, 34					; 00000022H
	je	SHORT $LN94@parseStrin

; 410  : 				if (input[end] == escapedCharStart) ++end; // Skip escaped char

	cmp	cl, 92					; 0000005cH
	jne	SHORT $LN2@parseStrin
	inc	rax
$LN2@parseStrin:

; 406  : 			// Find string end to calculate approximate size
; 407  : 			size_t end = i;
; 408  : 			for (; end < input.size(); ++end, ++size) {

	inc	rax
	inc	rdx
	cmp	rax, r8
	jb	SHORT $LL4@parseStrin
$LN94@parseStrin:

; 411  : 			}
; 412  : 			if (end >= input.size()) throw std::runtime_error("Invalid string syntax");

	cmp	rax, r8
	jae	$LN107@parseStrin
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rbx], xmm0

; 860  :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 414  : 			std::string string;

	mov	DWORD PTR $T1[rsp], 1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2438 :         if (_Mypair._Myval2._Myres >= _Newcap) { // requested capacity is not larger than current capacity, ignore

	cmp	rdx, 15
	jbe	SHORT $LN44@parseStrin

; 2439 :             return; // nothing to do
; 2440 :         }
; 2441 : 
; 2442 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2443 :         _Reallocate_grow_by(_Newcap - _Old_size,

	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >

; 2444 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
; 2445 :                 _STATIC_LAMBDA { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });
; 2446 : 
; 2447 :         // `_Reallocate_grow_by` calls `_ASAN_STRING_CREATE` assuming that the string
; 2448 :         // has size (initialized memory) equal to its new capacity (allocated memory).
; 2449 :         // This is not true for the `reserve` method, so we modify the ASan annotation.
; 2450 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _Old_size);
; 2451 :         _Mypair._Myval2._Mysize = _Old_size;

	mov	QWORD PTR [rbx+16], 0
$LN44@parseStrin:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 418  : 			for (; i < input.size(); ++i)

	mov	rcx, QWORD PTR [rdi]
	cmp	rcx, QWORD PTR [rsi+8]
	jae	$LN6@parseStrin
$LL7@parseStrin:

; 419  : 			{
; 420  : 				c = input[i];

	mov	rax, QWORD PTR [rsi]
	movzx	r9d, BYTE PTR [rcx+rax]

; 421  : 				if (c == stringEnd)

	cmp	r9b, 34					; 00000022H
	je	SHORT $LN95@parseStrin

; 425  : 				}
; 426  : 				else if (c == escapedCharStart)

	cmp	r9b, 92					; 0000005cH
	jne	SHORT $LN13@parseStrin

; 427  : 					handleEscapedChar(input, ++i, string);

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi], rax
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	call	??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Parser::handleEscapedChar<MappedFile<0> >
	jmp	SHORT $LN5@parseStrin
$LN13@parseStrin:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rbx+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rcx, rdx
	jae	SHORT $LN83@parseStrin

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN86@parseStrin

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN86@parseStrin:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 2299 :             return;

	jmp	SHORT $LN5@parseStrin
$LN83@parseStrin:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN5@parseStrin:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 418  : 			for (; i < input.size(); ++i)

	inc	QWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi]
	cmp	rcx, QWORD PTR [rsi+8]
	jae	SHORT $LN6@parseStrin
	jmp	SHORT $LL7@parseStrin
$LN95@parseStrin:

; 422  : 				{
; 423  : 					++i;

	inc	rcx
	mov	QWORD PTR [rdi], rcx

; 424  : 					return string;

	mov	rax, rbx

; 431  : 		}

	add	rsp, 80					; 00000050H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN107@parseStrin:

; 411  : 			}
; 412  : 			if (end >= input.size()) throw std::runtime_error("Invalid string syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BG@GELOLNAM@Invalid?5string?5syntax@
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T4[rsp]
	call	_CxxThrowException
	npad	1
$LN6@parseStrin:

; 428  : 				else string.push_back(c);
; 429  : 			}
; 430  : 			throw std::runtime_error("Invalid string syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BG@GELOLNAM@Invalid?5string?5syntax@
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T17[rsp]
	call	_CxxThrowException
	int	3
$LN105@parseStrin:
??$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ENDP ; Json::Parser::parseString<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T4 = 40
$T17 = 40
__$ReturnUdt$GSCopy$ = 64
__$ReturnUdt$ = 112
input$ = 120
i$ = 128
?dtor$0@?0???$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseString<MappedFile<0> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN17@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN17@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$parseString@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseString<MappedFile<0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$make_unique@VString@Json@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
<_Args_0>$ = 72
??$make_unique@VString@Json@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::make_unique<Json::String,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT

; 3629 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN65:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 40					; 00000028H
	xor	esi, esi
	mov	rbx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	vpxor	xmm0, xmm0, xmm0
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	lea	rcx, OFFSET FLAT:??_7String@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T2[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	mov	QWORD PTR [rax], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rax+8], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rax+24], rsi

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rax+32], rsi

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	YMMWORD PTR [rax+8], ymm0

; 1287 : 
; 1288 :                 _Right_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rsi

; 1289 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 1290 :                 _Right_data._Activate_SSO_buffer();
; 1291 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], sil
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	rax, rdi
	vzeroupper

; 3631 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@VString@Json@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@std@@YA?AV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@0@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::make_unique<Json::String,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseBoolTrue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T8 = 40
$T6 = 48
__$ReturnUdt$ = 96
input$ = 104
i$ = 112
??$parseBoolTrue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z PROC ; Json::Parser::parseBoolTrue<MappedFile<0> >, COMDAT

; 435  : 		{

$LN73:
	push	rbx
	sub	rsp, 80					; 00000050H

; 436  : 			++i;

	inc	QWORD PTR [r8]

; 437  : 			for (size_t j = 1; j < trueLiteral.size() && i < input.size(); ++j, ++i) {

	mov	r9d, 1
	cmp	r9, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	mov	r10, rdx
	mov	rax, QWORD PTR [r8]
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	jae	SHORT $LN3@parseBoolT
	lea	r11, OFFSET FLAT:?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::trueLiteral
	npad	3
$LL4@parseBoolT:
	cmp	rax, QWORD PTR [r10+8]
	jae	SHORT $LN3@parseBoolT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, r11
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rdx, QWORD PTR [r10]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmova	rcx, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 438  : 				if (input[i] != trueLiteral[j]) {

	movzx	ecx, BYTE PTR [rcx+r9]
	cmp	BYTE PTR [rdx+rax], cl
	jne	SHORT $LN62@parseBoolT

; 437  : 			for (size_t j = 1; j < trueLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rax
	inc	r9
	mov	QWORD PTR [r8], rax
	cmp	r9, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL4@parseBoolT
$LN3@parseBoolT:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Bool@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T8[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	mov	QWORD PTR [rax], rcx
	mov	BYTE PTR [rax+8], 1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rbx], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 442  : 			return std::make_unique<Bool>(true);

	mov	rax, rbx

; 443  : 		}

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN62@parseBoolT:

; 439  : 					throw std::runtime_error("Invalid bool true literal");

	lea	rdx, OFFSET FLAT:??_C@_0BK@GDBLDPAM@Invalid?5bool?5true?5literal@
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T6[rsp]
	call	_CxxThrowException
	int	3
$LN70@parseBoolT:
??$parseBoolTrue@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ENDP ; Json::Parser::parseBoolTrue<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseBoolFalse@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T8 = 40
$T6 = 48
__$ReturnUdt$ = 96
input$ = 104
i$ = 112
??$parseBoolFalse@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z PROC ; Json::Parser::parseBoolFalse<MappedFile<0> >, COMDAT

; 447  : 		{

$LN73:
	push	rbx
	sub	rsp, 80					; 00000050H

; 448  : 			++i;

	inc	QWORD PTR [r8]

; 449  : 			for (size_t j = 1; j < falseLiteral.size() && i < input.size(); ++j, ++i) {

	mov	r9d, 1
	cmp	r9, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	mov	r10, rdx
	mov	rax, QWORD PTR [r8]
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	jae	SHORT $LN3@parseBoolF
	lea	r11, OFFSET FLAT:?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::falseLiteral
	npad	3
$LL4@parseBoolF:
	cmp	rax, QWORD PTR [r10+8]
	jae	SHORT $LN3@parseBoolF
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, r11
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rdx, QWORD PTR [r10]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmova	rcx, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 450  : 				if (input[i] != falseLiteral[j]) {

	movzx	ecx, BYTE PTR [rcx+r9]
	cmp	BYTE PTR [rdx+rax], cl
	jne	SHORT $LN62@parseBoolF

; 449  : 			for (size_t j = 1; j < falseLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rax
	inc	r9
	mov	QWORD PTR [r8], rax
	cmp	r9, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL4@parseBoolF
$LN3@parseBoolF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Bool@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T8[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	mov	QWORD PTR [rax], rcx
	mov	BYTE PTR [rax+8], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rbx], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 454  : 			return std::make_unique<Bool>(false);

	mov	rax, rbx

; 455  : 		}

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN62@parseBoolF:

; 451  : 					throw std::runtime_error("Invalid bool false literal");

	lea	rdx, OFFSET FLAT:??_C@_0BL@MHJMKGJM@Invalid?5bool?5false?5literal@
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T6[rsp]
	call	_CxxThrowException
	int	3
$LN70@parseBoolF:
??$parseBoolFalse@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ENDP ; Json::Parser::parseBoolFalse<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseNull@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T7 = 40
$T6 = 48
__$ReturnUdt$ = 96
input$ = 104
i$ = 112
??$parseNull@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z PROC ; Json::Parser::parseNull<MappedFile<0> >, COMDAT

; 459  : 		{

$LN73:
	push	rbx
	sub	rsp, 80					; 00000050H

; 460  : 			++i;

	inc	QWORD PTR [r8]

; 461  : 			for (size_t j = 1; j < nullLiteral.size() && i < input.size(); ++j, ++i) {

	mov	r9d, 1
	cmp	r9, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	mov	r10, rdx
	mov	rax, QWORD PTR [r8]
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	jae	SHORT $LN3@parseNull
	lea	r11, OFFSET FLAT:?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::nullLiteral
	npad	3
$LL4@parseNull:
	cmp	rax, QWORD PTR [r10+8]
	jae	SHORT $LN3@parseNull
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, r11
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rdx, QWORD PTR [r10]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmova	rcx, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 462  : 				if (input[i] != nullLiteral[j]) {

	movzx	ecx, BYTE PTR [rcx+r9]
	cmp	BYTE PTR [rdx+rax], cl
	jne	SHORT $LN62@parseNull

; 461  : 			for (size_t j = 1; j < nullLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rax
	inc	r9
	mov	QWORD PTR [r8], rax
	cmp	r9, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL4@parseNull
$LN3@parseNull:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 8
	call	??2@YAPEAX_K@Z				; operator new
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h

; 9    : 		Null() : Value() {};

	lea	rcx, OFFSET FLAT:??_7Null@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T7[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h

; 9    : 		Null() : Value() {};

	mov	QWORD PTR [rax], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rbx], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 466  : 			return std::make_unique<Null>();

	mov	rax, rbx

; 467  : 		}

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN62@parseNull:

; 463  : 					throw std::runtime_error("Invalid null literal");

	lea	rdx, OFFSET FLAT:??_C@_0BF@GONMNCPG@Invalid?5null?5literal@
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T6[rsp]
	call	_CxxThrowException
	int	3
$LN70@parseNull:
??$parseNull@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ENDP ; Json::Parser::parseNull<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z
_TEXT	SEGMENT
_Eptr$61 = 56
$T43 = 56
_Eptr$62 = 56
$T16 = 56
__$ReturnUdt$GSCopy$ = 56
string$ = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 176
input$ = 184
i$ = 192
??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z PROC ; Json::Parser::parseNumber<MappedFile<0> >, COMDAT

; 383  : 		{

$LN247:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H
	vmovaps	XMMWORD PTR [rsp+112], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-128], rax
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-128], rcx
	xor	r15d, r15d
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR string$[rbp-128], xmm0

; 860  :         _My_data._Mysize = 0;

	mov	r8d, r15d
	mov	QWORD PTR string$[rbp-112], r15

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	edx, 15
	mov	QWORD PTR string$[rbp-104], rdx

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR string$[rbp-128], r8b
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 386  : 			for (; i < input.size(); ++i)

	mov	rcx, QWORD PTR [rbx]
	cmp	rcx, QWORD PTR [rdi+8]
	jae	$LN3@parseNumbe
	mov	r14, 562949953421321			; 0002000000000009H
	npad	2
$LL4@parseNumbe:

; 387  : 			{
; 388  : 				c = input[i];

	mov	rax, QWORD PTR [rdi]
	movzx	r9d, BYTE PTR [rcx+rax]

; 389  : 				if (whitespaceCharacters[0] == c
; 390  : 					|| whitespaceCharacters[1] == c
; 391  : 					|| whitespaceCharacters[2] == c
; 392  : 					|| whitespaceCharacters[3] == c
; 393  : 					|| c == valueSeparator || c == endObject
; 394  : 					|| c == endArray || c == commentStart)

	cmp	r9b, 32					; 00000020H
	je	SHORT $LN231@parseNumbe
	lea	eax, DWORD PTR [r9-9]
	test	al, 250					; 000000faH
	jne	SHORT $LN236@parseNumbe
	cmp	r9b, 14
	jne	SHORT $LN231@parseNumbe
$LN236@parseNumbe:
	lea	eax, DWORD PTR [r9-44]
	cmp	al, 49					; 00000031H
	ja	SHORT $LN238@parseNumbe
	bt	r14, rax
	jb	SHORT $LN231@parseNumbe
$LN238@parseNumbe:
	cmp	r9b, 125				; 0000007dH
	je	SHORT $LN231@parseNumbe
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	r8, rdx

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN221@parseNumbe

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [r8+1]
	mov	QWORD PTR string$[rbp-112], rax

; 435  :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR string$[rbp-128]

; 453  :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 436  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR string$[rbp-128]

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+r8], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+r8+1], 0

; 2299 :             return;

	jmp	SHORT $LN2@parseNumbe
$LN221@parseNumbe:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR string$[rbp-128]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN2@parseNumbe:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 386  : 			for (; i < input.size(); ++i)

	inc	QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx]
	cmp	rcx, QWORD PTR [rdi+8]
	jae	$LN3@parseNumbe
	mov	rdx, QWORD PTR string$[rbp-104]
	mov	r8, QWORD PTR string$[rbp-112]
	jmp	SHORT $LL4@parseNumbe
$LN231@parseNumbe:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 221  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
	mov	rdi, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR string$[rbp-128]

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR string$[rbp-104], 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rbx, QWORD PTR string$[rbp-128]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 224  :     _Errno_ref        = 0;

	mov	DWORD PTR [rax], r15d

; 225  :     const double _Ans = _CSTD strtod(_Ptr, &_Eptr);

	lea	rdx, QWORD PTR _Eptr$62[rbp-128]
	mov	rcx, rbx
	call	QWORD PTR __imp_strtod
	vmovaps	xmm6, xmm0

; 226  : 
; 227  :     if (_Ptr == _Eptr) {

	cmp	rbx, QWORD PTR _Eptr$62[rbp-128]
	jne	SHORT $LN106@parseNumbe

; 228  :         _Xinvalid_argument("invalid stod argument");

	lea	rcx, OFFSET FLAT:??_C@_0BG@LNNHAOEF@invalid?5stod?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN106@parseNumbe:

; 229  :     }
; 230  : 
; 231  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [rdi], 34			; 00000022H
	jne	SHORT $LN107@parseNumbe

; 232  :         _Xout_of_range("stod argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BL@PPHDABKE@stod?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN107@parseNumbe:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T16[rbp-128], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Number@Json@@6B@
	mov	QWORD PTR [rax], rcx
	vmovsd	QWORD PTR [rax+8], xmm6
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR string$[rbp-104]
	cmp	rdx, 15

; 3083 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN91@parseNumbe

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR string$[rbp-128]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN99@parseNumbe

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	$LN98@parseNumbe
$LN99@parseNumbe:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 398  : 			return std::make_unique<Number>(std::stod(string));

	call	??3@YAXPEAX_K@Z				; operator delete
$LN91@parseNumbe:
	mov	rax, rsi

; 399  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-128]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+184]
	vmovaps	xmm6, XMMWORD PTR [rsp+112]
	add	rsp, 128				; 00000080H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@parseNumbe:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 221  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
	npad	1
	mov	rdi, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR string$[rbp-128]

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR string$[rbp-104], 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rbx, QWORD PTR string$[rbp-128]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 224  :     _Errno_ref        = 0;

	mov	DWORD PTR [rax], r15d

; 225  :     const double _Ans = _CSTD strtod(_Ptr, &_Eptr);

	lea	rdx, QWORD PTR _Eptr$61[rbp-128]
	mov	rcx, rbx
	call	QWORD PTR __imp_strtod
	vmovaps	xmm6, xmm0

; 226  : 
; 227  :     if (_Ptr == _Eptr) {

	cmp	rbx, QWORD PTR _Eptr$61[rbp-128]
	jne	SHORT $LN19@parseNumbe

; 228  :         _Xinvalid_argument("invalid stod argument");

	lea	rcx, OFFSET FLAT:??_C@_0BG@LNNHAOEF@invalid?5stod?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN19@parseNumbe:

; 229  :     }
; 230  : 
; 231  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [rdi], 34			; 00000022H
	jne	SHORT $LN20@parseNumbe

; 232  :         _Xout_of_range("stod argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BL@PPHDABKE@stod?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN20@parseNumbe:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T43[rbp-128], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Number@Json@@6B@
	mov	QWORD PTR [rax], rcx
	vmovsd	QWORD PTR [rax+8], xmm6
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR string$[rbp-104]
	cmp	rdx, 15

; 3083 :         if (_My_data._Large_mode_engaged()) {

	jbe	$LN91@parseNumbe

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR string$[rbp-128]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	$LN99@parseNumbe

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	$LN99@parseNumbe
$LN98@parseNumbe:
	mov	QWORD PTR [rsp+32], r15
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN244@parseNumbe:
??$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z ENDP ; Json::Parser::parseNumber<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Eptr$61 = 56
$T43 = 56
_Eptr$62 = 56
$T16 = 56
__$ReturnUdt$GSCopy$ = 56
string$ = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 176
input$ = 184
i$ = 192
?dtor$0@?0???$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA PROC ; `Json::Parser::parseNumber<MappedFile<0> >'::`1'::dtor$0
	lea	rcx, QWORD PTR string$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$parseNumber@V?$MappedFile@$0A@@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEAV?$MappedFile@$0A@@@AEA_K@Z@4HA ENDP ; `Json::Parser::parseNumber<MappedFile<0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VString@Json@@U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0VString@Json@@U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@1@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::String,std::default_delete<Json::String>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3394 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0VString@Json@@U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@1@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::String,std::default_delete<Json::String>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_one_at_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_one_at_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 840  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 841  :         auto& _My_data   = _Mypair._Myval2;
; 842  :         pointer& _Mylast = _My_data._Mylast;
; 843  : 
; 844  :         if (_Mylast != _My_data._Myend) {

	mov	r9, QWORD PTR [rcx+8]
	cmp	r9, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rdx]

; 861  :         } else {
; 862  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 863  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 864  :             _ASAN_VECTOR_RELEASE_GUARD;
; 865  :         }
; 866  : 
; 867  :         _Orphan_range(_Mylast, _Mylast);
; 868  :         _Ty& _Result = *_Mylast;

	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [r9], rax
	mov	rax, QWORD PTR [rcx+8]

; 869  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 849  :     }

	ret	0
$LN2@Emplace_on:

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, r9
	jmp	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
??$_Emplace_one_at_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_one_at_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
_TEXT	SEGMENT
$T26 = 32
$T40 = 32
$T41 = 32
input$ = 80
i$ = 88
??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z PROC ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 297  : 		static inline size_t skipWhitespaceSIMD16(const Container& input, size_t i) {

$LN195:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 298  : 			const size_t size = input.size();
; 299  : 
; 300  : 			static const __m128i ws_space = _mm_set1_epi8(' ');

	mov	rax, QWORD PTR gs:88
	mov	rbx, rdx
	mov	rbp, QWORD PTR [rcx+16]
	mov	rdi, rcx
	mov	esi, OFFSET FLAT:_Init_thread_epoch
	add	rsi, QWORD PTR [rax]
	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR ?$TSS0@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, eax ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
	jle	SHORT $LN2@skipWhites
	lea	rcx, OFFSET FLAT:?$TSS0@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, -1 ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
	jne	SHORT $LN2@skipWhites
	vmovdqu	xmm0, XMMWORD PTR __xmm@20202020202020202020202020202020
	lea	rcx, OFFSET FLAT:?$TSS0@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
	vmovdqu	XMMWORD PTR ?ws_space@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_space
	call	_Init_thread_footer
$LN2@skipWhites:

; 301  : 			static const __m128i ws_tab = _mm_set1_epi8('\t');

	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR ?$TSS1@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, eax ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
	jle	SHORT $LN3@skipWhites
	lea	rcx, OFFSET FLAT:?$TSS1@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS1@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, -1 ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
	jne	SHORT $LN3@skipWhites
	vmovdqu	xmm0, XMMWORD PTR __xmm@09090909090909090909090909090909
	lea	rcx, OFFSET FLAT:?$TSS1@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
	vmovdqu	XMMWORD PTR ?ws_tab@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_tab
	call	_Init_thread_footer
$LN3@skipWhites:

; 302  : 			static const __m128i ws_cr = _mm_set1_epi8('\r');

	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR ?$TSS2@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, eax ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS2
	jle	SHORT $LN4@skipWhites
	lea	rcx, OFFSET FLAT:?$TSS2@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS2
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS2@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, -1 ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS2
	jne	SHORT $LN4@skipWhites
	vmovdqu	xmm0, XMMWORD PTR __xmm@0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d
	lea	rcx, OFFSET FLAT:?$TSS2@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS2
	vmovdqu	XMMWORD PTR ?ws_cr@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_cr
	call	_Init_thread_footer
$LN4@skipWhites:

; 303  : 			static const __m128i ws_lf = _mm_set1_epi8('\n');

	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR ?$TSS3@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, eax ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS3
	jle	SHORT $LN115@skipWhites
	lea	rcx, OFFSET FLAT:?$TSS3@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS3
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS3@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, -1 ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS3
	jne	SHORT $LN115@skipWhites
	vmovdqu	xmm0, XMMWORD PTR __xmm@0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a
	lea	rcx, OFFSET FLAT:?$TSS3@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS3
	vmovdqu	XMMWORD PTR ?ws_lf@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_lf
	call	_Init_thread_footer
$LN115@skipWhites:

; 304  : 
; 305  : 			__m128i chunk;
; 306  : 			uint16_t mask;
; 307  : 
; 308  : 			while (i + 16 <= size) {

	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rbp
	ja	$LN150@skipWhites
	npad	8
$LL6@skipWhites:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN149@skipWhites

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN149@skipWhites:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 309  : 				chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&input[i]));

	vmovdqu	xmm4, XMMWORD PTR [rax+rbx]

; 310  : 
; 311  : 				mask = ~_mm_movemask_epi8(_mm_or_si128(

	vpcmpeqb xmm1, xmm4, XMMWORD PTR ?ws_lf@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_lf
	vpcmpeqb xmm0, xmm4, XMMWORD PTR ?ws_cr@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_cr
	vpcmpeqb xmm2, xmm4, XMMWORD PTR ?ws_tab@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_tab
	vpor	xmm3, xmm1, xmm0
	vpcmpeqb xmm1, xmm4, XMMWORD PTR ?ws_space@?1???$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_space
	vpor	xmm0, xmm2, xmm1
	vpor	xmm2, xmm3, xmm0
	vpmovmskb eax, xmm2
	not	ax

; 312  : 					_mm_or_si128(_mm_cmpeq_epi8(chunk, ws_space), _mm_cmpeq_epi8(chunk, ws_tab)),
; 313  : 					_mm_or_si128(_mm_cmpeq_epi8(chunk, ws_cr), _mm_cmpeq_epi8(chunk, ws_lf))));
; 314  : 
; 315  : 				if (mask != 0) {

	test	ax, ax
	je	SHORT $LN11@skipWhites

; 316  : 					size_t j = i + CTZ16(mask);

	tzcnt	ax, ax
	movzx	eax, ax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rdi
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 316  : 					size_t j = i + CTZ16(mask);

	add	rax, rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN148@skipWhites

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi]
$LN148@skipWhites:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 317  : 					if (input[j] == '/')

	cmp	BYTE PTR [rcx+rax], 47			; 0000002fH
	jne	$LN1@skipWhites

; 318  : 					{
; 319  : 						i = skipCommentSIMD16(input, j) + 1;

	mov	rdx, rax
	mov	rcx, rdi
	call	??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	lea	rbx, QWORD PTR [rax+1]

; 320  : 						continue;

	jmp	SHORT $LN121@skipWhites
$LN11@skipWhites:

; 321  : 					}
; 322  : 					return j;
; 323  : 				}
; 324  : 
; 325  : 				i += 16;

	add	rbx, 16
$LN121@skipWhites:

; 304  : 
; 305  : 			__m128i chunk;
; 306  : 			uint16_t mask;
; 307  : 
; 308  : 			while (i + 16 <= size) {

	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rbp
	jbe	$LL6@skipWhites
$LN150@skipWhites:

; 326  : 			}
; 327  : 
; 328  : 			char c;
; 329  : 			for (; i < input.size(); ++i)

	mov	r8, QWORD PTR [rdi+16]
	cmp	rbx, r8
	jae	$LN130@skipWhites
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	r9, QWORD PTR [rdi+24]
	mov	r10, 4294977024				; 0000000100002600H
$LN192@skipWhites:

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r8
	mov	rdx, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN151@skipWhites

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN151@skipWhites:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 331  : 				c = input[i];

	movsx	rdx, BYTE PTR [rdx+rbx]

; 332  : 				if (whitespaceCharacters[0] == c
; 333  : 					|| whitespaceCharacters[1] == c
; 334  : 					|| whitespaceCharacters[2] == c
; 335  : 					|| whitespaceCharacters[3] == c) {

	cmp	dl, 32					; 00000020H
	ja	SHORT $LN154@skipWhites
	bt	r10, rdx
	jb	SHORT $LN8@skipWhites
$LN154@skipWhites:

; 336  : 					continue;
; 337  : 				}
; 338  : 				else if (c == commentStart) {

	cmp	dl, 47					; 0000002fH
	jne	SHORT $LN130@skipWhites

; 220  : 			++i;

	lea	rax, QWORD PTR [rbx+1]
	mov	rbx, rax

; 221  : 			if (i >= input.size()) throw std::runtime_error("Invalid comment syntax");

	cmp	rax, rcx
	jae	$LN120@skipWhites
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN152@skipWhites

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN152@skipWhites:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 222  : 			char c = input[i];

	movzx	edx, BYTE PTR [rax+rbx]

; 223  : 			++i;

	inc	rbx

; 224  : 			if (c == lineComment) {

	cmp	dl, 47					; 0000002fH
	jne	SHORT $LN68@skipWhites

; 225  : 				for (; i < input.size() && input[i] != '\n'; ++i); // skip to end of line

	cmp	rbx, rcx
	jae	SHORT $LN8@skipWhites
	npad	4
$LL63@skipWhites:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN87@skipWhites

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN87@skipWhites:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 225  : 				for (; i < input.size() && input[i] != '\n'; ++i); // skip to end of line

	cmp	BYTE PTR [rax+rbx], 10
	je	SHORT $LN8@skipWhites
	inc	rbx
	cmp	rbx, rcx
	jb	SHORT $LL63@skipWhites
$LN8@skipWhites:

; 326  : 			}
; 327  : 
; 328  : 			char c;
; 329  : 			for (; i < input.size(); ++i)

	inc	rbx
	cmp	rbx, r8
	jb	SHORT $LN192@skipWhites
$LN130@skipWhites:

; 339  : 					i = skipCommentScalar(input, i);
; 340  : 					continue;
; 341  : 				}
; 342  : 				return i;
; 343  : 			}
; 344  : 			return i;
; 345  : 		};

	mov	rax, rbx
$LN1@skipWhites:
	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN68@skipWhites:

; 228  : 			else if (c == blockCommentStart) {

	cmp	dl, 42					; 0000002aH
	jne	SHORT $LN70@skipWhites
	npad	1
$LL66@skipWhites:

; 229  : 				for (; i < input.size(); ++i)

	cmp	rbx, rcx
	jae	SHORT $LN65@skipWhites
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN153@skipWhites

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN153@skipWhites:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 231  : 					if (input[i] == blockCommentEnd && ++i < input.size() && input[i] == commentStart) {

	cmp	BYTE PTR [rax+rbx], 42			; 0000002aH
	jne	SHORT $LN64@skipWhites
	inc	rbx
	cmp	rbx, rcx
	jae	SHORT $LN64@skipWhites
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN107@skipWhites

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN107@skipWhites:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 231  : 					if (input[i] == blockCommentEnd && ++i < input.size() && input[i] == commentStart) {

	cmp	BYTE PTR [rax+rbx], 47			; 0000002fH
	je	SHORT $LN8@skipWhites
$LN64@skipWhites:

; 229  : 				for (; i < input.size(); ++i)

	inc	rbx
	jmp	SHORT $LL66@skipWhites
$LN70@skipWhites:

; 236  : 			}
; 237  : 			throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T41[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T41[rsp]
	call	_CxxThrowException
	int	3
$LN120@skipWhites:

; 221  : 			if (i >= input.size()) throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T26[rsp]
	call	_CxxThrowException
	int	3
$LN65@skipWhites:

; 232  : 						return i;
; 233  : 					}
; 234  : 				}
; 235  : 				throw std::runtime_error("Endless block comment");

	lea	rdx, OFFSET FLAT:??_C@_0BG@PEGDFFCL@Endless?5block?5comment@
	lea	rcx, QWORD PTR $T40[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T40[rsp]
	call	_CxxThrowException
	int	3
$LN191@skipWhites:
??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ENDP ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
_TEXT	SEGMENT
$T30 = 48
$T32 = 48
$T36 = 48
$T39 = 48
$T43 = 48
$T62 = 48
$T77 = 48
$T78 = 48
object$ = 72
$T38 = 80
__$ReturnUdt$GSCopy$ = 80
$T28 = 96
$T17 = 96
$T29 = 128
$T75 = 128
name$81 = 160
$T76 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z PROC ; Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 500  : 		{

$LN298:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 208				; 000000d0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-169], rax
	mov	r14, r8
	mov	rdi, rdx
	mov	r15, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-169], rcx
	mov	QWORD PTR object$[rbp-169], 0

; 501  : 			std::unique_ptr<Object> object = std::make_unique<Object>();

	lea	rcx, QWORD PTR object$[rbp-169]
	call	??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ ; std::make_unique<Json::Object,0>
	npad	1

; 503  : 			for (; i < input.size();)

	mov	rax, QWORD PTR [r14]
	cmp	rax, QWORD PTR [rdi+16]
	jae	$LN3@parseObjec
	mov	r12, 1099511628211			; 00000100000001b3H
	mov	rbx, QWORD PTR object$[rbp-169]
	npad	1
$LL4@parseObjec:

; 504  : 			{			
; 505  : 				i = skipWhitespace(input, ++i);

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [r14], rdx

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rcx, rax

; 504  : 			{			
; 505  : 				i = skipWhitespace(input, ++i);

	mov	QWORD PTR [r14], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdi+24], 15
	jbe	SHORT $LN293@parseObjec

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN293@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 506  : 				c = input[i];

	movsx	edx, BYTE PTR [rcx+rax]

; 507  : 				if (c == stringStart) {

	cmp	dl, 34					; 00000022H
	jne	$LN5@parseObjec

; 508  : 					std::string name = parseString(input, i);

	mov	r8, r14
	mov	rdx, rdi
	lea	rcx, QWORD PTR name$81[rbp-169]
	call	??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z ; Json::Parser::parseString<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR name$81[rbp-169]

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR name$81[rbp-145], 15
	cmova	rdx, QWORD PTR name$81[rbp-169]
	xor	ecx, ecx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2292 :     return _Fnv1a_append_bytes(

	mov	r9, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	r8, QWORD PTR name$81[rbp-153]
	test	r8, r8
	je	SHORT $LN66@parseObjec
$LL283@parseObjec:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+rcx]
	xor	r9, rax

; 2261 :         _Val *= _FNV_prime;

	imul	r9, r12

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rcx
	cmp	rcx, r8
	jb	SHORT $LL283@parseObjec
$LN66@parseObjec:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1221 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	lea	r8, QWORD PTR name$81[rbp-169]
	lea	rdx, QWORD PTR $T17[rbp-169]
	lea	rcx, QWORD PTR [rbx+8]
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rcx, QWORD PTR [rax+8]

; 1222 :             if (_Target) {

	test	rcx, rcx
	jne	SHORT $LN70@parseObjec

; 1223 :                 return _Target;
; 1224 :             }
; 1225 : 
; 1226 :             return _List._Mypair._Myval2._Myhead;

	mov	rcx, QWORD PTR [rbx+16]
$LN70@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 509  : 					if (object->m_values.find(name) != object->m_values.end())

	cmp	rcx, QWORD PTR [rbx+16]
	jne	$LN269@parseObjec

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rdx, QWORD PTR [r14]
	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 511  : 					i = skipWhitespace(input, i);

	mov	QWORD PTR [r14], rax

; 512  : 					if (i == input.size())

	cmp	rax, QWORD PTR [rdi+16]
	je	$LN270@parseObjec
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdi+24], 15
	jbe	SHORT $LN294@parseObjec

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi]
$LN294@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 514  : 					else if (input[i] != nameSeparator)

	cmp	BYTE PTR [rax+rcx], 58			; 0000003aH
	jne	$LN271@parseObjec

; 516  : 
; 517  : 					i = skipWhitespace(input, ++i);

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [r14], rdx

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 516  : 
; 517  : 					i = skipWhitespace(input, ++i);

	mov	QWORD PTR [r14], rax

; 518  : 					object->m_values.emplace(

	mov	r8, r14
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T38[rbp-169]
	call	??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
	npad	1
	mov	r9, rax
	lea	r8, QWORD PTR name$81[rbp-169]
	lea	rdx, QWORD PTR $T39[rbp-169]
	lea	rcx, QWORD PTR [rbx+8]
	call	??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR $T38[rbp-169]
	test	rcx, rcx
	je	SHORT $LN147@parseObjec

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN147@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rdx, QWORD PTR [r14]
	mov	rcx, rdi
	call	??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 519  : 						std::move(name), std::move(parseValue(input, i)));
; 520  : 					i = skipWhitespace(input, i);

	mov	QWORD PTR [r14], rax

; 521  : 					if (i == input.size())

	cmp	rax, QWORD PTR [rdi+16]
	je	$LN272@parseObjec
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rdi

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rdi+24]

; 445  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN292@parseObjec

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi]
$LN292@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 523  : 					else if (input[i] != valueSeparator)

	cmp	BYTE PTR [rcx+rax], 44			; 0000002cH
	jne	SHORT $LN273@parseObjec
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR name$81[rbp-145]
	cmp	rdx, 15
	jbe	SHORT $LN190@parseObjec

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR name$81[rbp-169]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN198@parseObjec

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN242@parseObjec
$LN198@parseObjec:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN190@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 503  : 			for (; i < input.size();)

	mov	rax, QWORD PTR [r14]
	cmp	rax, QWORD PTR [rdi+16]
	jae	$LN3@parseObjec
	jmp	$LL4@parseObjec
$LN273@parseObjec:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN166@parseObjec

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN166@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 525  : 						if (input[i] == endObject)

	cmp	BYTE PTR [rax+rdi], 125			; 0000007dH
	jne	$LN14@parseObjec

; 526  : 						{
; 527  : 							++i;

	inc	rax
	mov	QWORD PTR [r14], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r15], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR name$81[rbp-145]
	cmp	rdx, 15
	jbe	SHORT $LN235@parseObjec

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR name$81[rbp-169]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN243@parseObjec

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN243@parseObjec
$LN242@parseObjec:
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN243@parseObjec:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN235@parseObjec:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 543  : 		};

	mov	rax, r15
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-169]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 208				; 000000d0H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN5@parseObjec:

; 531  : 					}
; 532  : 				}
; 533  : 				else if (c == endObject)

	cmp	dl, 125					; 0000007dH
	jne	SHORT $LN16@parseObjec

; 534  : 				{
; 535  : 					++i;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [r14], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r15], rbx
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 536  : 					return object;

	jmp	SHORT $LN235@parseObjec
$LN269@parseObjec:

; 510  : 						throw std::runtime_error(std::string("Duplicate key: ") + name);

	lea	rdx, OFFSET FLAT:??_C@_0BA@IDEJNKDC@Duplicate?5key?3?5@
	lea	rcx, QWORD PTR $T28[rbp-169]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, QWORD PTR name$81[rbp-169]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T29[rbp-169]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T30[rbp-169]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T30[rbp-169]
	call	_CxxThrowException
	npad	1
$LN3@parseObjec:

; 540  : 				}				
; 541  : 			}
; 542  : 			throw std::runtime_error("Endless object");

	lea	rdx, OFFSET FLAT:??_C@_0P@JPNLNIKK@Endless?5object@
	lea	rcx, QWORD PTR $T78[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T78[rbp-169]
	call	_CxxThrowException
	int	3
$LN16@parseObjec:

; 537  : 				}
; 538  : 				else {
; 539  : 					throw std::runtime_error("Invalid object syntax: " + std::to_string(c));

	lea	rcx, QWORD PTR $T75[rbp-169]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	npad	1
	mov	r8, rax
	lea	rcx, QWORD PTR $T76[rbp-169]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T77[rbp-169]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T77[rbp-169]
	call	_CxxThrowException
	npad	1
$LN14@parseObjec:

; 528  : 							return object;
; 529  : 						}
; 530  : 						else throw std::runtime_error("No value separator after object value");

	lea	rdx, OFFSET FLAT:??_C@_0CG@LKKKBDCI@No?5value?5separator?5after?5object@
	lea	rcx, QWORD PTR $T62[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T62[rbp-169]
	call	_CxxThrowException
	int	3
$LN272@parseObjec:

; 522  : 						throw std::runtime_error("Endless object");

	lea	rdx, OFFSET FLAT:??_C@_0P@JPNLNIKK@Endless?5object@
	lea	rcx, QWORD PTR $T43[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T43[rbp-169]
	call	_CxxThrowException
	int	3
$LN271@parseObjec:

; 515  : 						throw std::runtime_error("No name separator after object key");

	lea	rdx, OFFSET FLAT:??_C@_0CD@DNDGJFLJ@No?5name?5separator?5after?5object?5@
	lea	rcx, QWORD PTR $T36[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T36[rbp-169]
	call	_CxxThrowException
	int	3
$LN270@parseObjec:

; 513  : 						throw std::runtime_error("Endless object");

	lea	rdx, OFFSET FLAT:??_C@_0P@JPNLNIKK@Endless?5object@
	lea	rcx, QWORD PTR $T32[rbp-169]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T32[rbp-169]
	call	_CxxThrowException
	int	3
$LN295@parseObjec:
??$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ENDP ; Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T30 = 48
$T32 = 48
$T36 = 48
$T39 = 48
$T43 = 48
$T62 = 48
$T77 = 48
$T78 = 48
object$ = 72
$T38 = 80
__$ReturnUdt$GSCopy$ = 80
$T28 = 96
$T17 = 96
$T29 = 128
$T75 = 128
name$81 = 160
$T76 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$0@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
	lea	rcx, QWORD PTR object$[rdx]
	jmp	??1?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::~unique_ptr<Json::Object,std::default_delete<Json::Object> >
?dtor$0@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T30 = 48
$T32 = 48
$T36 = 48
$T39 = 48
$T43 = 48
$T62 = 48
$T77 = 48
$T78 = 48
object$ = 72
$T38 = 80
__$ReturnUdt$GSCopy$ = 80
$T28 = 96
$T17 = 96
$T29 = 128
$T75 = 128
name$81 = 160
$T76 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$1@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$1
	lea	rcx, QWORD PTR name$81[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T30 = 48
$T32 = 48
$T36 = 48
$T39 = 48
$T43 = 48
$T62 = 48
$T77 = 48
$T78 = 48
object$ = 72
$T38 = 80
__$ReturnUdt$GSCopy$ = 80
$T28 = 96
$T17 = 96
$T29 = 128
$T75 = 128
name$81 = 160
$T76 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$2@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T28[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T30 = 48
$T32 = 48
$T36 = 48
$T39 = 48
$T43 = 48
$T62 = 48
$T77 = 48
$T78 = 48
object$ = 72
$T38 = 80
__$ReturnUdt$GSCopy$ = 80
$T28 = 96
$T17 = 96
$T29 = 128
$T75 = 128
name$81 = 160
$T76 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$3@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$3
	lea	rcx, QWORD PTR $T29[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T30 = 48
$T32 = 48
$T36 = 48
$T39 = 48
$T43 = 48
$T62 = 48
$T77 = 48
$T78 = 48
object$ = 72
$T38 = 80
__$ReturnUdt$GSCopy$ = 80
$T28 = 96
$T17 = 96
$T29 = 128
$T75 = 128
name$81 = 160
$T76 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$4@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$4
	lea	rcx, QWORD PTR $T38[rdx]
	jmp	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
?dtor$4@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T30 = 48
$T32 = 48
$T36 = 48
$T39 = 48
$T43 = 48
$T62 = 48
$T77 = 48
$T78 = 48
object$ = 72
$T38 = 80
__$ReturnUdt$GSCopy$ = 80
$T28 = 96
$T17 = 96
$T29 = 128
$T75 = 128
name$81 = 160
$T76 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$6@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$6
	lea	rcx, QWORD PTR $T75[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T30 = 48
$T32 = 48
$T36 = 48
$T39 = 48
$T43 = 48
$T62 = 48
$T77 = 48
$T78 = 48
object$ = 72
$T38 = 80
__$ReturnUdt$GSCopy$ = 80
$T28 = 96
$T17 = 96
$T29 = 128
$T75 = 128
name$81 = 160
$T76 = 160
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
input$ = 280
i$ = 288
?dtor$7@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$7
	lea	rcx, QWORD PTR $T76[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0???$parseObject@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseObject<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
_TEXT	SEGMENT
$T23 = 32
$T2 = 32
__$ReturnUdt$GSCopy$ = 32
$T47 = 48
$T64 = 48
$T65 = 48
array$ = 72
__$ReturnUdt$ = 128
input$ = 136
i$ = 144
??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z PROC ; Json::Parser::parseArray<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 471  : 		{

$LN196:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rdi, r8
	mov	rbx, rdx
	mov	r14, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	ebp, ebp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r15, rax
	mov	QWORD PTR $T2[rsp], rax
	vpxor	xmm0, xmm0, xmm0
	vmovups	YMMWORD PTR [rax], ymm0
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h

; 17   : 		Array() : Value() {};

	lea	rax, OFFSET FLAT:??_7Array@Json@@6B@
	mov	QWORD PTR [r15], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r15+8], rbp
	mov	QWORD PTR [r15+16], rbp
	mov	QWORD PTR [r15+24], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR array$[rsp], r15
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 473  : 			for (; i < input.size();)

	mov	rax, QWORD PTR [rdi]
	cmp	rax, QWORD PTR [rbx+16]
	jae	$LN3@parseArray
$LL4@parseArray:

; 474  : 			{
; 475  : 				i = skipWhitespace(input, ++i);

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR [rdi], rdx

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rcx, rbx
	vzeroupper
	call	??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rcx, rax

; 474  : 			{
; 475  : 				i = skipWhitespace(input, ++i);

	mov	QWORD PTR [rdi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rbx+24], 15

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN191@parseArray

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN191@parseArray:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 476  : 				if (input[i] == endArray)

	cmp	BYTE PTR [rcx+rax], 93			; 0000005dH
	je	$LN183@parseArray

; 480  : 				}
; 481  : 				array->m_values.emplace_back(std::move(parseValue(input, i)));

	mov	r8, rdi
	mov	rdx, rbx
	lea	rcx, QWORD PTR $T23[rsp]
	call	??$parseValue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ; Json::Parser::parseValue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
	mov	r8, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [r15+16]
	cmp	rdx, QWORD PTR [r15+24]
	je	SHORT $LN52@parseArray
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rax]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 869  :         ++_Mylast;

	add	QWORD PTR [r15+16], 8

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN51@parseArray
$LN52@parseArray:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	rcx, QWORD PTR [r15+8]
	call	??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
	npad	1
$LN51@parseArray:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR $T23[rsp]
	test	rcx, rcx
	je	SHORT $LN94@parseArray

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN94@parseArray:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 373  : 			return skipWhitespaceSIMD16(input, i);

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
	call	??$skipWhitespaceSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Parser::skipWhitespaceSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 482  : 				i = skipWhitespace(input, i);

	mov	QWORD PTR [rdi], rax

; 483  : 				if (i == input.size())

	mov	rdx, QWORD PTR [rbx+16]
	cmp	rax, rdx
	je	SHORT $LN184@parseArray
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 453  :         return _Myres > _Small_string_capacity;

	mov	r8, QWORD PTR [rbx+24]
	cmp	r8, 15

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN190@parseArray

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN190@parseArray:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 485  : 				else if (input[i] != valueSeparator)

	cmp	BYTE PTR [rcx+rax], 44			; 0000002cH
	jne	SHORT $LN185@parseArray

; 473  : 			for (; i < input.size();)

	cmp	rax, rdx
	jae	SHORT $LN3@parseArray
	jmp	$LL4@parseArray
$LN185@parseArray:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	cmp	r8, 15

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN146@parseArray

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN146@parseArray:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 487  : 					if (input[i] == endArray)

	cmp	BYTE PTR [rbx+rax], 93			; 0000005dH
	jne	SHORT $LN9@parseArray

; 488  : 					{
; 489  : 						++i;

	lea	rcx, QWORD PTR [rax+1]
	mov	QWORD PTR [rdi], rcx
$LN193@parseArray:

; 496  : 		}

	mov	QWORD PTR [r14], r15
	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+152]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN183@parseArray:

; 477  : 				{
; 478  : 					++i;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi], rax

; 479  : 					return array;

	jmp	SHORT $LN193@parseArray
$LN184@parseArray:

; 484  : 					throw std::runtime_error("Endless array");

	lea	rdx, OFFSET FLAT:??_C@_0O@ELDHGBOG@Endless?5array@
	lea	rcx, QWORD PTR $T47[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T47[rsp]
	call	_CxxThrowException
	int	3
$LN3@parseArray:

; 493  : 				}
; 494  : 			}
; 495  : 			throw std::runtime_error("Endless array");

	lea	rdx, OFFSET FLAT:??_C@_0O@ELDHGBOG@Endless?5array@
	lea	rcx, QWORD PTR $T65[rsp]
	vzeroupper
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T65[rsp]
	call	_CxxThrowException
	int	3
$LN9@parseArray:

; 490  : 						return array;
; 491  : 					}
; 492  : 					else throw std::runtime_error("No value separator after array value");

	lea	rdx, OFFSET FLAT:??_C@_0CF@PAAGCNKK@No?5value?5separator?5after?5array?5@
	lea	rcx, QWORD PTR $T64[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T64[rsp]
	call	_CxxThrowException
	int	3
$LN192@parseArray:
??$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ENDP ; Json::Parser::parseArray<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T23 = 32
$T2 = 32
__$ReturnUdt$GSCopy$ = 32
$T47 = 48
$T64 = 48
$T65 = 48
array$ = 72
__$ReturnUdt$ = 128
input$ = 136
i$ = 144
?dtor$0@?0???$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseArray<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
	lea	rcx, QWORD PTR array$[rdx]
	jmp	??1?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::~unique_ptr<Json::Array,std::default_delete<Json::Array> >
?dtor$0@?0???$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseArray<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T23 = 32
$T2 = 32
__$ReturnUdt$GSCopy$ = 32
$T47 = 48
$T64 = 48
$T65 = 48
array$ = 72
__$ReturnUdt$ = 128
input$ = 136
i$ = 144
?dtor$2@?0???$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseArray<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T23[rdx]
	jmp	??1?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@XZ ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::~unique_ptr<Json::Value,std::default_delete<Json::Value> >
?dtor$2@?0???$parseArray@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseArray<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z
_TEXT	SEGMENT
$T1 = 32
$T8 = 40
$T23 = 40
__$ReturnUdt$GSCopy$ = 64
__$ReturnUdt$ = 112
input$ = 120
i$ = 128
??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z PROC ; Json::Parser::parseString<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 403  : 		{

$LN140:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rsi, r8
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	DWORD PTR $T1[rsp], 1

; 404  : 			++i;

	inc	QWORD PTR [r8]
	mov	rax, QWORD PTR [r8]

; 405  : 			size_t size = 0;

	xor	edx, edx

; 406  : 			// Find string end to calculate approximate size
; 407  : 			size_t end = i;
; 408  : 			for (; end < input.size(); ++end, ++size) {

	mov	r9, QWORD PTR [rbx+16]
	cmp	rax, r9
	jae	$LN137@parseStrin
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	r8, QWORD PTR [rbx+24]
$LL4@parseStrin:

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 445  :         if (_Large_mode_engaged()) {

	cmp	r8, 15
	jbe	SHORT $LN133@parseStrin

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN133@parseStrin:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 409  : 				if (input[end] == stringEnd) break;

	cmp	BYTE PTR [rcx+rax], 34			; 00000022H
	je	SHORT $LN118@parseStrin
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 445  :         if (_Large_mode_engaged()) {

	cmp	r8, 15
	jbe	SHORT $LN132@parseStrin

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN132@parseStrin:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 410  : 				if (input[end] == escapedCharStart) ++end; // Skip escaped char

	cmp	BYTE PTR [rcx+rax], 92			; 0000005cH
	jne	SHORT $LN2@parseStrin
	inc	rax
$LN2@parseStrin:

; 406  : 			// Find string end to calculate approximate size
; 407  : 			size_t end = i;
; 408  : 			for (; end < input.size(); ++end, ++size) {

	inc	rax
	inc	rdx
	cmp	rax, r9
	jb	SHORT $LL4@parseStrin
$LN118@parseStrin:

; 411  : 			}
; 412  : 			if (end >= input.size()) throw std::runtime_error("Invalid string syntax");

	cmp	rax, r9
	jae	$LN137@parseStrin
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rdi], xmm0

; 860  :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rdi+24], 15

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], 0
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 414  : 			std::string string;

	mov	DWORD PTR $T1[rsp], 1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2438 :         if (_Mypair._Myval2._Myres >= _Newcap) { // requested capacity is not larger than current capacity, ignore

	cmp	rdx, 15
	jbe	SHORT $LN60@parseStrin

; 2439 :             return; // nothing to do
; 2440 :         }
; 2441 : 
; 2442 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2443 :         _Reallocate_grow_by(_Newcap - _Old_size,

	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >

; 2444 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
; 2445 :                 _STATIC_LAMBDA { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });
; 2446 : 
; 2447 :         // `_Reallocate_grow_by` calls `_ASAN_STRING_CREATE` assuming that the string
; 2448 :         // has size (initialized memory) equal to its new capacity (allocated memory).
; 2449 :         // This is not true for the `reserve` method, so we modify the ASan annotation.
; 2450 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _Old_size);
; 2451 :         _Mypair._Myval2._Mysize = _Old_size;

	mov	QWORD PTR [rdi+16], 0
$LN60@parseStrin:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 418  : 			for (; i < input.size(); ++i)

	mov	rcx, QWORD PTR [rsi]
	cmp	rcx, QWORD PTR [rbx+16]
	jae	$LN6@parseStrin
	npad	8
$LL7@parseStrin:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	r9, rbx

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+24], 15
	jbe	SHORT $LN67@parseStrin

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rbx]
$LN67@parseStrin:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 420  : 				c = input[i];

	movzx	r9d, BYTE PTR [r9+rcx]

; 421  : 				if (c == stringEnd)

	cmp	r9b, 34					; 00000022H
	je	SHORT $LN119@parseStrin

; 425  : 				}
; 426  : 				else if (c == escapedCharStart)

	cmp	r9b, 92					; 0000005cH
	jne	SHORT $LN13@parseStrin

; 427  : 					handleEscapedChar(input, ++i, string);

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rsi], rax
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, rbx
	call	??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z ; Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
	jmp	SHORT $LN5@parseStrin
$LN13@parseStrin:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN107@parseStrin

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN110@parseStrin

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN110@parseStrin:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 2299 :             return;

	jmp	SHORT $LN5@parseStrin
$LN107@parseStrin:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN5@parseStrin:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 418  : 			for (; i < input.size(); ++i)

	inc	QWORD PTR [rsi]
	mov	rcx, QWORD PTR [rsi]
	cmp	rcx, QWORD PTR [rbx+16]
	jae	SHORT $LN6@parseStrin
	jmp	SHORT $LL7@parseStrin
$LN119@parseStrin:

; 422  : 				{
; 423  : 					++i;

	inc	rcx
	mov	QWORD PTR [rsi], rcx

; 424  : 					return string;

	mov	rax, rdi

; 431  : 		}

	add	rsp, 80					; 00000050H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN137@parseStrin:

; 411  : 			}
; 412  : 			if (end >= input.size()) throw std::runtime_error("Invalid string syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BG@GELOLNAM@Invalid?5string?5syntax@
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T8[rsp]
	call	_CxxThrowException
	npad	1
$LN6@parseStrin:

; 428  : 				else string.push_back(c);
; 429  : 			}
; 430  : 			throw std::runtime_error("Invalid string syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BG@GELOLNAM@Invalid?5string?5syntax@
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T23[rsp]
	call	_CxxThrowException
	int	3
$LN135@parseStrin:
??$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z ENDP ; Json::Parser::parseString<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T8 = 40
$T23 = 40
__$ReturnUdt$GSCopy$ = 64
__$ReturnUdt$ = 112
input$ = 120
i$ = 128
?dtor$0@?0???$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z@4HA PROC ; `Json::Parser::parseString<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN17@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN17@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$parseString@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV23@AEA_K@Z@4HA ENDP ; `Json::Parser::parseString<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseBoolTrue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T10 = 40
$T8 = 48
__$ReturnUdt$ = 96
input$ = 104
i$ = 112
??$parseBoolTrue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z PROC ; Json::Parser::parseBoolTrue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 435  : 		{

$LN82:
	push	rbx
	sub	rsp, 80					; 00000050H

; 436  : 			++i;

	inc	QWORD PTR [r8]

; 437  : 			for (size_t j = 1; j < trueLiteral.size() && i < input.size(); ++j, ++i) {

	mov	r9d, 1
	cmp	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, r9
	mov	r10, r8
	mov	rax, QWORD PTR [r8]
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	jbe	SHORT $LN3@parseBoolT
	lea	r11, OFFSET FLAT:?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::trueLiteral
	npad	3
$LL4@parseBoolT:
	cmp	rax, QWORD PTR [rdx+16]
	jae	SHORT $LN3@parseBoolT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN14@parseBoolT

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN14@parseBoolT:

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, r11
	cmova	rcx, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 438  : 				if (input[i] != trueLiteral[j]) {

	movzx	ecx, BYTE PTR [rcx+r9]
	cmp	BYTE PTR [rax+r8], cl
	jne	SHORT $LN70@parseBoolT

; 437  : 			for (size_t j = 1; j < trueLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rax
	inc	r9
	mov	QWORD PTR [r10], rax
	cmp	r9, QWORD PTR ?trueLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL4@parseBoolT
$LN3@parseBoolT:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Bool@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T10[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	mov	QWORD PTR [rax], rcx
	mov	BYTE PTR [rax+8], 1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rbx], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 442  : 			return std::make_unique<Bool>(true);

	mov	rax, rbx

; 443  : 		}

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN70@parseBoolT:

; 439  : 					throw std::runtime_error("Invalid bool true literal");

	lea	rdx, OFFSET FLAT:??_C@_0BK@GDBLDPAM@Invalid?5bool?5true?5literal@
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T8[rsp]
	call	_CxxThrowException
	int	3
$LN79@parseBoolT:
??$parseBoolTrue@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ENDP ; Json::Parser::parseBoolTrue<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseBoolFalse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T10 = 40
$T8 = 48
__$ReturnUdt$ = 96
input$ = 104
i$ = 112
??$parseBoolFalse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z PROC ; Json::Parser::parseBoolFalse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 447  : 		{

$LN82:
	push	rbx
	sub	rsp, 80					; 00000050H

; 448  : 			++i;

	inc	QWORD PTR [r8]

; 449  : 			for (size_t j = 1; j < falseLiteral.size() && i < input.size(); ++j, ++i) {

	mov	r9d, 1
	cmp	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, r9
	mov	r10, r8
	mov	rax, QWORD PTR [r8]
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	jbe	SHORT $LN3@parseBoolF
	lea	r11, OFFSET FLAT:?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::falseLiteral
	npad	3
$LL4@parseBoolF:
	cmp	rax, QWORD PTR [rdx+16]
	jae	SHORT $LN3@parseBoolF
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN14@parseBoolF

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN14@parseBoolF:

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, r11
	cmova	rcx, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 450  : 				if (input[i] != falseLiteral[j]) {

	movzx	ecx, BYTE PTR [rcx+r9]
	cmp	BYTE PTR [rax+r8], cl
	jne	SHORT $LN70@parseBoolF

; 449  : 			for (size_t j = 1; j < falseLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rax
	inc	r9
	mov	QWORD PTR [r10], rax
	cmp	r9, QWORD PTR ?falseLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL4@parseBoolF
$LN3@parseBoolF:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Bool@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T10[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	mov	QWORD PTR [rax], rcx
	mov	BYTE PTR [rax+8], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rbx], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 454  : 			return std::make_unique<Bool>(false);

	mov	rax, rbx

; 455  : 		}

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN70@parseBoolF:

; 451  : 					throw std::runtime_error("Invalid bool false literal");

	lea	rdx, OFFSET FLAT:??_C@_0BL@MHJMKGJM@Invalid?5bool?5false?5literal@
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T8[rsp]
	call	_CxxThrowException
	int	3
$LN79@parseBoolF:
??$parseBoolFalse@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ENDP ; Json::Parser::parseBoolFalse<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseNull@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
$T9 = 40
$T8 = 48
__$ReturnUdt$ = 96
input$ = 104
i$ = 112
??$parseNull@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z PROC ; Json::Parser::parseNull<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 459  : 		{

$LN82:
	push	rbx
	sub	rsp, 80					; 00000050H

; 460  : 			++i;

	inc	QWORD PTR [r8]

; 461  : 			for (size_t j = 1; j < nullLiteral.size() && i < input.size(); ++j, ++i) {

	mov	r9d, 1
	cmp	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16, r9
	mov	r10, r8
	mov	rax, QWORD PTR [r8]
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	jbe	SHORT $LN3@parseNull
	lea	r11, OFFSET FLAT:?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Parser::nullLiteral
	npad	3
$LL4@parseNull:
	cmp	rax, QWORD PTR [rdx+16]
	jae	SHORT $LN3@parseNull
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rdx+24], 15

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN14@parseNull

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN14@parseNull:

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+24, 15

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, r11
	cmova	rcx, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 462  : 				if (input[i] != nullLiteral[j]) {

	movzx	ecx, BYTE PTR [rcx+r9]
	cmp	BYTE PTR [rax+r8], cl
	jne	SHORT $LN70@parseNull

; 461  : 			for (size_t j = 1; j < nullLiteral.size() && i < input.size(); ++j, ++i) {

	inc	rax
	inc	r9
	mov	QWORD PTR [r10], rax
	cmp	r9, QWORD PTR ?nullLiteral@Parser@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B+16
	jb	SHORT $LL4@parseNull
$LN3@parseNull:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 8
	call	??2@YAPEAX_K@Z				; operator new
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h

; 9    : 		Null() : Value() {};

	lea	rcx, OFFSET FLAT:??_7Null@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T9[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h

; 9    : 		Null() : Value() {};

	mov	QWORD PTR [rax], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rbx], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 466  : 			return std::make_unique<Null>();

	mov	rax, rbx

; 467  : 		}

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN70@parseNull:

; 463  : 					throw std::runtime_error("Invalid null literal");

	lea	rdx, OFFSET FLAT:??_C@_0BF@GONMNCPG@Invalid?5null?5literal@
	lea	rcx, QWORD PTR $T8[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T8[rsp]
	call	_CxxThrowException
	int	3
$LN79@parseNull:
??$parseNull@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ENDP ; Json::Parser::parseNull<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z
_TEXT	SEGMENT
_Eptr$63 = 56
$T45 = 56
_Eptr$64 = 56
$T18 = 56
__$ReturnUdt$GSCopy$ = 56
string$ = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 176
input$ = 184
i$ = 192
??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z PROC ; Json::Parser::parseNumber<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 383  : 		{

$LN255:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H
	vmovaps	XMMWORD PTR [rsp+112], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-128], rax
	mov	rdi, r8
	mov	rbx, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-128], rcx
	xor	r15d, r15d
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR string$[rbp-128], xmm0

; 860  :         _My_data._Mysize = 0;

	mov	ecx, r15d
	mov	QWORD PTR string$[rbp-112], rcx

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	edx, 15
	mov	QWORD PTR string$[rbp-104], rdx

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR string$[rbp-128], cl
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 386  : 			for (; i < input.size(); ++i)

	mov	rax, QWORD PTR [r8]
	cmp	rax, QWORD PTR [rbx+16]
	jae	$LN3@parseNumbe
	mov	r14, 562949953421321			; 0002000000000009H
	npad	3
$LL4@parseNumbe:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	r9, rbx

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR [rbx+24], 15

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN17@parseNumbe

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rbx]
$LN17@parseNumbe:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 388  : 				c = input[i];

	movzx	r9d, BYTE PTR [rax+r9]

; 389  : 				if (whitespaceCharacters[0] == c
; 390  : 					|| whitespaceCharacters[1] == c
; 391  : 					|| whitespaceCharacters[2] == c
; 392  : 					|| whitespaceCharacters[3] == c
; 393  : 					|| c == valueSeparator || c == endObject
; 394  : 					|| c == endArray || c == commentStart)

	cmp	r9b, 32					; 00000020H
	je	SHORT $LN239@parseNumbe
	lea	eax, DWORD PTR [r9-9]
	test	al, 250					; 000000faH
	jne	SHORT $LN244@parseNumbe
	cmp	r9b, 14
	jne	SHORT $LN239@parseNumbe
$LN244@parseNumbe:
	lea	eax, DWORD PTR [r9-44]
	cmp	al, 49					; 00000031H
	ja	SHORT $LN246@parseNumbe
	bt	r14, rax
	jb	SHORT $LN239@parseNumbe
$LN246@parseNumbe:
	cmp	r9b, 125				; 0000007dH
	je	SHORT $LN239@parseNumbe
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rcx, rdx

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN229@parseNumbe

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR string$[rbp-112], rax

; 435  :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR string$[rbp-128]

; 453  :         return _Myres > _Small_string_capacity;

	cmp	rdx, 15

; 436  :         if (_Large_mode_engaged()) {

	cmova	rax, QWORD PTR string$[rbp-128]

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 2299 :             return;

	jmp	SHORT $LN2@parseNumbe
$LN229@parseNumbe:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR string$[rbp-128]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN2@parseNumbe:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 386  : 			for (; i < input.size(); ++i)

	inc	QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi]
	cmp	rax, QWORD PTR [rbx+16]
	jae	$LN3@parseNumbe
	mov	rdx, QWORD PTR string$[rbp-104]
	mov	rcx, QWORD PTR string$[rbp-112]
	jmp	$LL4@parseNumbe
$LN239@parseNumbe:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 221  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
	mov	rdi, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR string$[rbp-128]

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR string$[rbp-104], 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rbx, QWORD PTR string$[rbp-128]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 224  :     _Errno_ref        = 0;

	mov	DWORD PTR [rax], r15d

; 225  :     const double _Ans = _CSTD strtod(_Ptr, &_Eptr);

	lea	rdx, QWORD PTR _Eptr$64[rbp-128]
	mov	rcx, rbx
	call	QWORD PTR __imp_strtod
	vmovaps	xmm6, xmm0

; 226  : 
; 227  :     if (_Ptr == _Eptr) {

	cmp	rbx, QWORD PTR _Eptr$64[rbp-128]
	jne	SHORT $LN114@parseNumbe

; 228  :         _Xinvalid_argument("invalid stod argument");

	lea	rcx, OFFSET FLAT:??_C@_0BG@LNNHAOEF@invalid?5stod?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN114@parseNumbe:

; 229  :     }
; 230  : 
; 231  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [rdi], 34			; 00000022H
	jne	SHORT $LN115@parseNumbe

; 232  :         _Xout_of_range("stod argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BL@PPHDABKE@stod?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN115@parseNumbe:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T18[rbp-128], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Number@Json@@6B@
	mov	QWORD PTR [rax], rcx
	vmovsd	QWORD PTR [rax+8], xmm6
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR string$[rbp-104]
	cmp	rdx, 15

; 3083 :         if (_My_data._Large_mode_engaged()) {

	jbe	SHORT $LN99@parseNumbe

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR string$[rbp-128]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN107@parseNumbe

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	$LN106@parseNumbe
$LN107@parseNumbe:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 398  : 			return std::make_unique<Number>(std::stod(string));

	call	??3@YAXPEAX_K@Z				; operator delete
$LN99@parseNumbe:
	mov	rax, rsi

; 399  : 		}

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-128]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+184]
	vmovaps	xmm6, XMMWORD PTR [rsp+112]
	add	rsp, 128				; 00000080H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN3@parseNumbe:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 221  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
	npad	1
	mov	rdi, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR string$[rbp-128]

; 453  :         return _Myres > _Small_string_capacity;

	cmp	QWORD PTR string$[rbp-104], 15

; 445  :         if (_Large_mode_engaged()) {

	cmova	rbx, QWORD PTR string$[rbp-128]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 224  :     _Errno_ref        = 0;

	mov	DWORD PTR [rax], r15d

; 225  :     const double _Ans = _CSTD strtod(_Ptr, &_Eptr);

	lea	rdx, QWORD PTR _Eptr$63[rbp-128]
	mov	rcx, rbx
	call	QWORD PTR __imp_strtod
	vmovaps	xmm6, xmm0

; 226  : 
; 227  :     if (_Ptr == _Eptr) {

	cmp	rbx, QWORD PTR _Eptr$63[rbp-128]
	jne	SHORT $LN27@parseNumbe

; 228  :         _Xinvalid_argument("invalid stod argument");

	lea	rcx, OFFSET FLAT:??_C@_0BG@LNNHAOEF@invalid?5stod?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN27@parseNumbe:

; 229  :     }
; 230  : 
; 231  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [rdi], 34			; 00000022H
	jne	SHORT $LN28@parseNumbe

; 232  :         _Xout_of_range("stod argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BL@PPHDABKE@stod?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN28@parseNumbe:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T45[rbp-128], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Number@Json@@6B@
	mov	QWORD PTR [rax], rcx
	vmovsd	QWORD PTR [rax+8], xmm6
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR string$[rbp-104]
	cmp	rdx, 15

; 3083 :         if (_My_data._Large_mode_engaged()) {

	jbe	$LN99@parseNumbe

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR string$[rbp-128]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	$LN107@parseNumbe

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	$LN107@parseNumbe
$LN106@parseNumbe:
	mov	QWORD PTR [rsp+32], r15
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN252@parseNumbe:
??$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z ENDP ; Json::Parser::parseNumber<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Eptr$63 = 56
$T45 = 56
_Eptr$64 = 56
$T18 = 56
__$ReturnUdt$GSCopy$ = 56
string$ = 64
__$ArrayPad$ = 96
__$ReturnUdt$ = 176
input$ = 184
i$ = 192
?dtor$0@?0???$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA PROC ; `Json::Parser::parseNumber<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
	lea	rcx, QWORD PTR string$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$parseNumber@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA?AV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@AEA_K@Z@4HA ENDP ; `Json::Parser::parseNumber<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>, COMDAT

; 1110 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1111 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1112 :         for (; _First != _Last; ++_First) {
; 1113 :             _STD _Destroy_in_place(*_First);
; 1114 :         }
; 1115 :     }
; 1116 : }

	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Head$ = 56
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN57:
	push	rdi
	sub	rsp, 32					; 00000020H

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rdi, QWORD PTR [rdx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rdi, rdi
	je	SHORT $LN50@Free_non_h
	mov	QWORD PTR [rsp+48], rbx
	npad	2
$LL4@Free_non_h:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdi]

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rdi+16]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rdi, rbx
	test	rbx, rbx
	jne	SHORT $LL4@Free_non_h
	mov	rbx, QWORD PTR [rsp+48]
$LN50@Free_non_h:

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }
; 331  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > ><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 262  :     }

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$0A@@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > ><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$dead$ = 24
<_Val2_1>$ = 32
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z PROC ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1><std::_Zero_then_variadic_args_t,float>, COMDAT

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, DWORD PTR [r9]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??$?0U_Zero_then_variadic_args_t@std@@M@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAU21@$$QEAM@Z ENDP ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1><std::_Zero_then_variadic_args_t,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1098 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN35:

; 1102 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN32@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1098 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN22@Destroy_ra

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN22@Destroy_ra:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1103 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1104 :         }
; 1105 :     }
; 1106 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN32@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEAV10@@Z PROC ; std::move<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > &>, COMDAT

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1514 : }

	ret	0
??$move@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@$$T@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@$$T@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@$$T@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@$$QEAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@$$QEAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@22@Z PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1><std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *>, COMDAT

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@$$QEAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@22@Z ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1><std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::_Facet_base *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::_Facet_base *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$dead$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>, COMDAT

; 3024 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN132:
	push	rbx
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 56					; 00000038H

; 3025 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3026 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3027 :         auto& _My_data            = _Mypair._Myval2;
; 3028 :         const size_type _Old_size = _My_data._Mysize;

	mov	r14, QWORD PTR [rcx+16]

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbx
	movzx	ebp, r9b
	sub	rax, r14
	mov	rsi, rcx
	cmp	rax, 1
	jb	$LN129@Reallocate

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	QWORD PTR [rsp+104], rdi
	mov	QWORD PTR [rsp+112], r12
	lea	r12, QWORD PTR [r14+1]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rdx, r12
	mov	QWORD PTR [rsp+48], r15

; 3034 :         const size_type _Old_capacity = _My_data._Myres;

	mov	r15, QWORD PTR [rcx+24]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rdx, 15
	cmp	rdx, rbx

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN127@Reallocate

; 2980 :             return _Max;
; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, r15
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	r15, rax
	ja	SHORT $LN127@Reallocate

; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r15+rcx]
	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbx+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN28@Reallocate

; 228  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN27@Reallocate
$LN28@Reallocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN30@Reallocate

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN130@Reallocate
	jmp	SHORT $LN35@Reallocate
$LN127@Reallocate:

; 136  :         return ::operator new(_Bytes);

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN35@Reallocate:
	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN72@Reallocate

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN27@Reallocate
$LN30@Reallocate:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN27@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], r12

; 3042 :         _My_data._Myres       = _New_capacity;
; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3044 :         if (_Old_capacity > _Small_string_capacity) {

	mov	r8, r14
	mov	QWORD PTR [rsi+24], rbx
	mov	rcx, rdi
	cmp	r15, 15
	jbe	SHORT $LN3@Reallocate

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r15+1]

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	BYTE PTR [r14+rdi], bpl

; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [r14+rdi+1], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN73@Reallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rbx, rax
	sub	rbx, 8
	cmp	rbx, 31
	ja	SHORT $LN72@Reallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rax
$LN73@Reallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3049 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN72@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN3@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2307 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	BYTE PTR [r14+rdi], bpl

; 2308 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [r14+rdi+1], 0
$LN4@Reallocate:

; 3050 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 3052 :         }
; 3053 : 
; 3054 :         _ASAN_STRING_CREATE(*this);
; 3055 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	r12, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+104]
	mov	r15, QWORD PTR [rsp+48]

; 3056 :     }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN129@Reallocate:

; 3030 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN130@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN126@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z
_TEXT	SEGMENT
this$ = 112
_Size_increase$ = 120
_Fn$dead$ = 128
<_Args_0>$ = 136
<_Args_1>$ = 144
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>, COMDAT

; 3024 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN166:
	push	rbx
	push	rsi
	push	r12
	push	r13
	push	r14
	sub	rsp, 64					; 00000040H

; 3025 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3026 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3027 :         auto& _My_data            = _Mypair._Myval2;
; 3028 :         const size_type _Old_size = _My_data._Mysize;

	mov	r14, QWORD PTR [rcx+16]

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	r12, QWORD PTR <_Args_1>$[rsp]
	mov	rax, rbx
	sub	rax, r14
	mov	r13, r9
	mov	rsi, rcx
	cmp	rax, rdx
	jb	$LN163@Reallocate

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	QWORD PTR [rsp+128], rbp
	lea	rbp, QWORD PTR [rdx+r14]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rdx, rbp
	mov	QWORD PTR [rsp+56], rdi
	or	rdx, 15
	mov	QWORD PTR [rsp+48], r15

; 3034 :         const size_type _Old_capacity = _My_data._Myres;

	mov	r15, QWORD PTR [rcx+24]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	cmp	rdx, rbx

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN161@Reallocate

; 2980 :             return _Max;
; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, r15
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	r15, rax
	ja	SHORT $LN161@Reallocate

; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r15+rcx]
	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbx+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN28@Reallocate

; 228  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN27@Reallocate
$LN28@Reallocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN30@Reallocate

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN164@Reallocate
	jmp	SHORT $LN35@Reallocate
$LN161@Reallocate:

; 136  :         return ::operator new(_Bytes);

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN35@Reallocate:
	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN79@Reallocate

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN27@Reallocate
$LN30@Reallocate:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN27@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], rbp

; 3042 :         _My_data._Myres       = _New_capacity;

	lea	rbp, QWORD PTR [r14+rdi]
	mov	QWORD PTR [rsi+24], rbx

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3044 :         if (_Old_capacity > _Small_string_capacity) {

	mov	r8, r14
	mov	rcx, rdi
	cmp	r15, 15
	jbe	SHORT $LN3@Reallocate

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy
	mov	r8, r12
	mov	rdx, r13
	mov	rcx, rbp
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r15+1]

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [r12+rbp], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN80@Reallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rbx, rax
	sub	rbx, 8
	cmp	rbx, 31
	ja	SHORT $LN79@Reallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rax
$LN80@Reallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3049 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN79@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN3@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	call	memcpy
	mov	r8, r12
	mov	rdx, r13
	mov	rcx, rbp
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1528 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [r12+rbp], 0
$LN4@Reallocate:

; 3050 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 3051 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 3052 :         }
; 3053 : 
; 3054 :         _ASAN_STRING_CREATE(*this);
; 3055 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+128]
	mov	r15, QWORD PTR [rsp+48]

; 3056 :     }

	add	rsp, 64					; 00000040H
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbx
	ret	0
$LN163@Reallocate:

; 3030 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN164@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN160@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
_TEXT	SEGMENT
_Left$ = 48
_Left_size$ = 56
_Right$ = 64
_Right_size$ = 72
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z PROC ; std::_Traits_equal<std::char_traits<char> >, COMDAT

; 602  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

$LN11:
	sub	rsp, 40					; 00000028H
	mov	rax, r8

; 603  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
; 604  :     if (_Left_size != _Right_size) {

	cmp	rdx, r9
	je	SHORT $LN2@Traits_equ

; 605  :         return false;

	xor	al, al

; 613  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@Traits_equ:

; 606  :     }
; 607  : 
; 608  :     if (_Left_size == 0u) {

	test	rdx, rdx
	jne	SHORT $LN3@Traits_equ

; 609  :         return true;

	mov	al, 1

; 613  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@Traits_equ:

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdx
	mov	rdx, rax
	call	memcmp

; 610  :     }
; 611  : 
; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	sete	al

; 613  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ENDP ; std::_Traits_equal<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@V?$basic_filebuf@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_filebuf@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_filebuf<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z PROC ; std::addressof<std::codecvt<char,char,_Mbstatet> const >, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ENDP ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 64
_Bytes$ = 72
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 261  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN14:
	sub	rsp, 56					; 00000038H

; 262  :     // deallocate storage allocated by _Allocate
; 263  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 264  :     if (_STD is_constant_evaluated()) {
; 265  :         ::operator delete(_Ptr);
; 266  :         return;
; 267  :     }
; 268  : #endif // _HAS_CXX20
; 269  : 
; 270  : #ifdef __cpp_aligned_new
; 271  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 272  :         size_t _Passed_align = _Align;
; 273  : #if defined(_M_IX86) || defined(_M_X64)
; 274  :         if (_Bytes >= _Big_allocation_threshold) {
; 275  :             // boost the alignment of big allocations to help autovectorization
; 276  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 277  :         }
; 278  : #endif // defined(_M_IX86) || defined(_M_X64)
; 279  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 280  :     } else
; 281  : #endif // defined(__cpp_aligned_new)
; 282  :     {
; 283  : #if defined(_M_IX86) || defined(_M_X64)
; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN8@Deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN9@Deallocate:

; 290  :     }
; 291  : }

	add	rsp, 56					; 00000038H

; 285  :             // boost the alignment of big allocations to help autovectorization
; 286  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 287  :         }
; 288  : #endif // defined(_M_IX86) || defined(_M_X64)
; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Deallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN11@Deallocate:
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::~unique_ptr<Json::String,std::default_delete<Json::String> >, COMDAT

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

	ret	0
??1?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::~unique_ptr<Json::String,std::default_delete<Json::String> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
;	COMDAT ??A?$MappedFile@$0A@@@QEBAAEBD_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$MappedFile@$0A@@@QEBAAEBD_K@Z PROC			; MappedFile<0>::operator[], COMDAT

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rax, QWORD PTR [rcx]
	add	rax, rdx
	ret	0
??A?$MappedFile@$0A@@@QEBAAEBD_K@Z ENDP			; MappedFile<0>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\array
;	COMDAT ??A?$array@E$0M@@std@@QEBAAEBE_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Pos$ = 16
??A?$array@E$0M@@std@@QEBAAEBE_K@Z PROC			; std::array<unsigned char,12>::operator[], COMDAT

; 539  : #if _MSVC_STL_HARDENING_ARRAY || _ITERATOR_DEBUG_LEVEL != 0
; 540  :         _STL_VERIFY(_Pos < _Size, "array subscript out of range");
; 541  : #endif
; 542  : 
; 543  :         return _Elems[_Pos];

	lea	rax, OFFSET FLAT:?numberStartCharacters@Parser@Json@@2V?$array@E$0M@@std@@B ; Json::Parser::numberStartCharacters
	add	rax, rdx

; 544  :     }

	ret	0
??A?$array@E$0M@@std@@QEBAAEBE_K@Z ENDP			; std::array<unsigned char,12>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 80
_Cells$ = 88
_Val$ = 96
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Assign_grow, COMDAT

; 282  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

$LN94:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 268  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rdi, QWORD PTR [rcx]

; 282  :     void _Assign_grow(const size_type _Cells, const value_type _Val) {

	mov	r14, rcx
	mov	rbx, r8

; 268  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	r8, QWORD PTR [rcx+8]
	mov	rcx, r8
	sub	rcx, rdi
	mov	rax, rcx
	sar	rax, 3

; 283  :         // set the elements stored here to _Cells copies of _Val, leaving the value unchanged if an exception is thrown
; 284  :         const auto _Oldsize = size();
; 285  :         _STL_INTERNAL_CHECK(_Oldsize <= _Cells);
; 286  :         auto& _Alvec = _Mypair._Get_first();
; 287  :         if (_Oldsize < _Cells) {

	cmp	rax, rdx
	jae	$LN2@Assign_gro
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	QWORD PTR [rsp+96], rsi
	cmp	rdx, rax
	ja	$LN77@Assign_gro

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	lea	rsi, QWORD PTR [rdx*8]

; 227  :     if (_Bytes == 0) {

	xor	ebp, ebp
	test	rsi, rsi
	jne	SHORT $LN16@Assign_gro

; 228  :         return nullptr;

	mov	edi, ebp
	jmp	SHORT $LN15@Assign_gro
$LN16@Assign_gro:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN18@Assign_gro

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN77@Assign_gro

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN45@Assign_gro

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN15@Assign_gro
$LN18@Assign_gro:

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN15@Assign_gro:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 279  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3

; 288  :             const auto _Newvec = _Alvec.allocate(_Cells); // throws
; 289  :             // nothrow hereafter
; 290  :             const auto _Oldcapacity = capacity();
; 291  :             if (_Oldcapacity != 0) {

	test	rax, rax
	je	SHORT $LN38@Assign_gro
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN46@Assign_gro

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN45@Assign_gro

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN46@Assign_gro:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN38@Assign_gro:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 297  :             const auto _Newend       = _Newvec + _Cells;

	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR [r14], rdi

; 298  :             _Mypair._Myval2._Mylast  = _Newend;

	mov	QWORD PTR [r14+8], rax

; 299  :             _Mypair._Myval2._Myend   = _Newend;

	mov	QWORD PTR [r14+16], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1620 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rdi, rax

; 2055 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN90@Assign_gro
	npad	3
$LL50@Assign_gro:

; 1634 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	QWORD PTR [rdi], rbx

; 1635 :         ++_Last;

	add	rdi, 8

; 2055 :         while (_Backout._Last != _ULast) {

	cmp	rdi, rax
	jne	SHORT $LL50@Assign_gro
$LN90@Assign_gro:
	mov	rsi, QWORD PTR [rsp+96]
$LN61@Assign_gro:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 304  :     }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
$LN45@Assign_gro:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbp
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN2@Assign_gro:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility

; 5292 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	add	rcx, 7
	xor	ebp, ebp
	shr	rcx, 3
	cmp	rdi, r8
	cmova	rcx, rbp

; 5293 :         const auto _ULast = _STD _Get_unwrapped(_Last);
; 5294 : #if _HAS_CXX20
; 5295 :         if (!_STD is_constant_evaluated())
; 5296 : #endif // _HAS_CXX20
; 5297 :         {
; 5298 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5299 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5300 :                 return;
; 5301 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5302 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5303 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5304 :                     return;
; 5305 :                 }
; 5306 :             }
; 5307 :         }
; 5308 : 
; 5309 :         for (; _UFirst != _ULast; ++_UFirst) {

	test	rcx, rcx
	je	SHORT $LN61@Assign_gro

; 5292 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	mov	rax, rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 304  :     }

	mov	rbx, QWORD PTR [rsp+104]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility

; 5292 :         auto _UFirst      = _STD _Get_unwrapped(_First);

	rep stosq
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 304  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
$LN77@Assign_gro:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN91@Assign_gro:
?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Assign_grow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::capacity, COMDAT

; 277  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 278  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 279  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 280  :     }

	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 64
_Ptr$ = 72
_Count$ = 80
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >::deallocate, COMDAT

; 982  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN18:
	sub	rsp, 56					; 00000038H
	mov	rax, rdx

; 983  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 984  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN12@deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN11@deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN12@deallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 986  :     }

	add	rsp, 56					; 00000038H

; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN11@deallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN15@deallocate:
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Getal, COMDAT

; 1863 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1864 :     }

	ret	0
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Unchecked_end, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1129 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	mov	rax, rdx

; 1130 :     }

	ret	0
?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$dead$ = 56
??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >, COMDAT

; 816  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN34:
	push	rbx
	sub	rsp, 32					; 00000020H

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax

; 816  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rcx

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 1852 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rax], rax

; 1853 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1854 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 817  :         _Alloc_sentinel_and_proxy();
; 818  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Max_bucket_size, COMDAT

; 1820 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, rcx

; 1821 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAAEAMXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map
;	COMDAT ??0?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$ = 16
??0?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z PROC ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0>::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0>, COMDAT

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??0?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@QEAA@AEBV?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ENDP ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0>::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal, COMDAT

; 2227 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2228 :     }

	ret	0
?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 64
_Ptr$ = 72
_Count$ = 80
?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z PROC ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::deallocate, COMDAT

; 982  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN18:
	sub	rsp, 56					; 00000038H
	mov	rax, rdx

; 983  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 984  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN12@deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN11@deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN12@deallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 986  :     }

	add	rsp, 56					; 00000038H

; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN11@deallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN15@deallocate:
?deallocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z ENDP ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 974  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??R?$default_delete@VValue@Json@@@std@@QEBAXPEAVValue@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VValue@Json@@@std@@QEBAXPEAVValue@Json@@@Z PROC ; std::default_delete<Json::Value>::operator(), COMDAT

; 3307 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3308 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3309 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3310 :     }

	ret	0
??R?$default_delete@VValue@Json@@@std@@QEBAXPEAVValue@Json@@@Z ENDP ; std::default_delete<Json::Value>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN12:
	sub	rsp, 40					; 00000028H

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rdx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rdx+72]

; 78   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
	mov	rbx, rcx

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [r8+rdx+72]

; 71   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN9@Sentry_bas

; 72   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
$LN9@Sentry_bas:

; 73   :             }
; 74   :         }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEBADXZ
_TEXT	SEGMENT
this$ = 48
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEBADXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek, COMDAT

; 468  :     _Elem _Peek() const { // peek at next input element

$LN17:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 469  :         int_type _Meta;
; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@Peek
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN4@Peek

; 471  :             _Strbuf = nullptr;
; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [rbx+9], al

; 478  :     }

	mov	BYTE PTR [rbx+8], 1
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@Peek:

; 474  :         }
; 475  : 
; 476  :         _Got = true;
; 477  :         return _Val;

	movzx	eax, BYTE PTR [rbx+9]
	mov	QWORD PTR [rbx], 0

; 478  :     }

	mov	BYTE PTR [rbx+8], 1
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEBADXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc, COMDAT

; 459  :     void _Inc() { // skip to next input element

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 460  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@Inc
	call	QWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN4@Inc

; 462  :             _Got    = true;
; 463  :         } else {
; 464  :             _Got = false;
; 465  :         }
; 466  :     }

	mov	BYTE PTR [rbx+8], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@Inc:

; 461  :             _Strbuf = nullptr;

	mov	QWORD PTR [rbx], 0

; 462  :             _Got    = true;
; 463  :         } else {
; 464  :             _Got = false;
; 465  :         }
; 466  :     }

	mov	BYTE PTR [rbx+8], 1
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\iterator
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NAEBV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NAEBV12@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::equal, COMDAT

; 436  :     _NODISCARD bool equal(const istreambuf_iterator& _Right) const {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 437  :         if (!_Got) {

	cmp	BYTE PTR [rcx+8], 0
	mov	rbx, rdx
	mov	rdi, rcx
	jne	SHORT $LN36@equal

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN12@equal
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN12@equal

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [rdi+9], al
	jmp	SHORT $LN11@equal
$LN12@equal:

; 471  :             _Strbuf = nullptr;

	mov	QWORD PTR [rdi], 0
$LN11@equal:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR [rdi+8], 1
$LN36@equal:

; 438  :             _Peek();
; 439  :         }
; 440  : 
; 441  :         if (!_Right._Got) {

	cmp	BYTE PTR [rbx+8], 0
	jne	SHORT $LN3@equal

; 470  :         if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN23@equal
	call	QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
	cmp	eax, -1
	je	SHORT $LN23@equal

; 472  :         } else {
; 473  :             _Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [rbx+9], al
	jmp	SHORT $LN22@equal
$LN23@equal:

; 471  :             _Strbuf = nullptr;

	mov	QWORD PTR [rbx], 0
$LN22@equal:

; 474  :         }
; 475  : 
; 476  :         _Got = true;

	mov	BYTE PTR [rbx+8], 1
$LN3@equal:

; 442  :             _Right._Peek();
; 443  :         }
; 444  : 
; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	cmp	QWORD PTR [rdi], 0
	mov	rax, QWORD PTR [rbx]
	jne	SHORT $LN35@equal
	test	rax, rax
	je	SHORT $LN7@equal
$LN6@equal:
	xor	al, al

; 446  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN35@equal:

; 442  :             _Right._Peek();
; 443  :         }
; 444  : 
; 445  :         return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);

	test	rax, rax
	je	SHORT $LN6@equal
$LN7@equal:

; 446  :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	al, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NAEBV12@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT

; 3307 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3308 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3309 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3310 :     }

	ret	0
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }

	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Off$dead$ = 16
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 468  :         // checks whether _Off is in the bounds of [0, size()]
; 469  :         if (_Mysize < _Off) {
; 470  :             _Xran();
; 471  :         }
; 472  :     }

	ret	0
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 457  :         // start the lifetime of the array elements
; 458  : #if _HAS_CXX20
; 459  :         if (_STD is_constant_evaluated()) {
; 460  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 461  :                 _Bx._Buf[_Idx] = value_type();
; 462  :             }
; 463  :         }
; 464  : #endif // _HAS_CXX20
; 465  :     }

	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 96   :     _CONSTEXPR20 ~_Tidy_deallocate_guard() {

$LN39:
	push	rbx
	sub	rsp, 48					; 00000030H

; 97   :         if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN7@Tidy_deall
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN18@Tidy_deall
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN26@Tidy_deall

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN25@Tidy_deall

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN26@Tidy_deall:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN18@Tidy_deall:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
$LN7@Tidy_deall:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 100  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN25@Tidy_deall:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN36@Tidy_deall:
??1?$_Tidy_deallocate_guard@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~_Tidy_deallocate_guard<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Right$dead$ = 16
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 3103 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 3104 :     }

	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rdx, 15
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN4@Calculate_

; 2991 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	r9, QWORD PTR [rcx+24]

; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rax
	mov	r8, r9
	shr	r8, 1
	sub	rcx, r8
	cmp	r9, rcx
	ja	SHORT $LN4@Calculate_

; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rcx, QWORD PTR [r8+r9]
	cmp	rdx, rcx
	cmovb	rdx, rcx

; 2991 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, rdx
$LN4@Calculate_:

; 2992 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$dead$ = 56
_Count$ = 64
?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept, COMDAT

; 1876 :     _CONSTEXPR20 basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {

$LN57:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 487  :         return (_STD min)(_Size, _Mysize - _Off);

	mov	rbx, QWORD PTR [rcx+16]

; 1876 :     _CONSTEXPR20 basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {

	mov	rax, r8

; 487  :         return (_STD min)(_Size, _Mysize - _Off);

	cmp	rbx, r8

; 1876 :     _CONSTEXPR20 basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {

	mov	rdi, rcx

; 487  :         return (_STD min)(_Size, _Mysize - _Off);

	cmovb	rax, rbx

; 436  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN11@Erase_noex

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN11@Erase_noex:

; 1877 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
; 1878 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 1879 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
; 1880 :         _Elem* const _Erase_at    = _My_ptr + _Off;
; 1881 :         const size_type _New_size = _Old_size - _Count;

	sub	rbx, rax

; 1882 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	lea	rdx, QWORD PTR [rax+rcx]
	lea	r8, QWORD PTR [rbx+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	memmove
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1884 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], rbx

; 1885 :         return *this;

	mov	rax, rdi

; 1886 :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$dead$ = 64
_Old_ptr$ = 72
_Capacity$ = 80
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 850  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN22:
	sub	rsp, 56					; 00000038H
	mov	rax, rdx

; 851  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r8+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@Deallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	ja	SHORT $LN14@Deallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@Deallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 853  :     }

	add	rsp, 56					; 00000038H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@Deallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN19@Deallocate:
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 136  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN40:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 137  :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 138  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 139  :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 140  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 141  : #if _HAS_CXX20
; 142  :         if (_STD is_constant_evaluated()) {
; 143  :             // dest: [_First1, _First1 + _Count)
; 144  :             // src: [_First2, _First2 + _Count)
; 145  :             // We need to handle overlapping ranges.
; 146  :             // If _First1 is in the src range, we need a backward loop.
; 147  :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 148  : 
; 149  :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 150  :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 151  :             bool _Loop_forward = true;
; 152  : 
; 153  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 154  :                 if (_First1 == _Src) {
; 155  :                     _Loop_forward = false;
; 156  :                     break;
; 157  :                 }
; 158  :             }
; 159  : 
; 160  :             if (_Loop_forward) {
; 161  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 162  :                     _First1[_Idx] = _First2[_Idx];
; 163  :                 }
; 164  :             } else {
; 165  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 166  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 167  :                 }
; 168  :             }
; 169  : 
; 170  :             return _First1;
; 171  :         }
; 172  : #endif // _HAS_CXX20
; 173  : 
; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	memmove

; 175  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 176  : 
; 177  :         return _First1;

	mov	rax, rbx

; 178  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
_TEXT	SEGMENT
_Pb$3 = 32
_Pn$4 = 40
$T1 = 48
_Nr$5 = 48
__$ArrayPad$ = 64
this$ = 96
_Filename$ = 104
_Mode$dead$ = 112
_Prot$dead$ = 120
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT

; 280  :     basic_filebuf* open(const char* _Filename, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {

$LN30:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, rdx
	mov	rbx, rcx

; 281  :         // _Prot is an extension
; 282  :         if (_Myfile) {

	cmp	QWORD PTR [rcx+128], 0
	jne	$LN26@open

; 283  :             return nullptr;
; 284  :         }
; 285  : 
; 286  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

	mov	edx, 1
	mov	r8d, 64					; 00000040H
	mov	rcx, rax
	call	QWORD PTR __imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z
	mov	rdi, rax

; 287  :         if (!_File) {

	test	rax, rax
	je	$LN26@open

; 683  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rbx+124], 1

; 684  :         _Wrotesome = false;

	mov	BYTE PTR [rbx+113], 0

; 685  : 
; 686  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 687  : 
; 688  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 689  :             _Elem** _Pb = nullptr;

	xor	esi, esi
	mov	QWORD PTR _Pb$3[rsp], rsi

; 690  :             _Elem** _Pn = nullptr;

	mov	QWORD PTR _Pn$4[rsp], rsi

; 691  :             int* _Nr    = nullptr;

	mov	QWORD PTR _Nr$5[rsp], rsi

; 692  : 
; 693  :             ::_get_stream_buffer_pointers(

	lea	r9, QWORD PTR _Nr$5[rsp]
	lea	r8, QWORD PTR _Pn$4[rsp]
	lea	rdx, QWORD PTR _Pb$3[rsp]
	mov	rcx, rdi
	call	QWORD PTR __imp__get_stream_buffer_pointers
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\streambuf

; 277  :         _IGfirst = _Gf;

	mov	rax, QWORD PTR _Pb$3[rsp]
	mov	QWORD PTR [rbx+24], rax

; 278  :         _IPfirst = _Pf;

	mov	QWORD PTR [rbx+32], rax

; 279  :         _IGnext  = _Gn;

	mov	rax, QWORD PTR _Pn$4[rsp]
	mov	QWORD PTR [rbx+56], rax

; 280  :         _IPnext  = _Pn;

	mov	QWORD PTR [rbx+64], rax

; 281  :         _IGcount = _Gc;

	mov	rax, QWORD PTR _Nr$5[rsp]
	mov	QWORD PTR [rbx+80], rax

; 282  :         _IPcount = _Pc;

	mov	QWORD PTR [rbx+88], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 700  :         _Myfile = _File;

	mov	QWORD PTR [rbx+128], rdi

; 701  :         _State  = _Stinit;

	mov	rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rbx+116], rax

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rsi

; 289  :         }
; 290  : 
; 291  :         _Init(_File, _Openfl);
; 292  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
	npad	1
	mov	rcx, rax
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	rdi, rax

; 743  :         if (_Newcvt.always_noconv()) {

	mov	rcx, rax
	call	QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN16@open

; 744  :             _Pcvt = nullptr; // nothing to do

	mov	QWORD PTR [rbx+104], rsi

; 745  :         } else { // set up for nontrivial codecvt facet

	jmp	SHORT $LN17@open
$LN16@open:

; 746  :             _Pcvt = _STD addressof(_Newcvt);

	mov	QWORD PTR [rbx+104], rdi

; 747  :             _Mysb::_Init(); // reset any buffering

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
	npad	1
$LN17@open:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xlocale

; 354  :         if (_Ptr) {

	mov	rcx, QWORD PTR $T1[rsp+8]
	test	rcx, rcx
	je	SHORT $LN23@open

; 355  :             delete _Ptr->_Decref();

	mov	r8, QWORD PTR [rcx]
	call	QWORD PTR [r8+16]
	test	rax, rax
	je	SHORT $LN23@open
	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rcx]
	mov	edx, 1
	mov	rcx, rax
	call	r8
$LN23@open:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp

; 293  :         return this; // open succeeded

	mov	rax, rbx
	jmp	SHORT $LN1@open
$LN26@open:

; 288  :             return nullptr; // open failed

	xor	eax, eax
$LN1@open:

; 294  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Pb$3 = 32
_Pn$4 = 40
$T1 = 48
_Nr$5 = 48
__$ArrayPad$ = 64
this$ = 96
_Filename$ = 104
_Mode$dead$ = 112
_Prot$dead$ = 120
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1locale@std@@QEAA@XZ			; std::locale::~locale
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_filebuf.hpp
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 64
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT

; 167  :     basic_filebuf() : _Mysb() {

$LN15:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@

; 683  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rbx+124], 0

; 685  : 
; 686  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rbx

; 167  :     basic_filebuf() : _Mysb() {

	mov	QWORD PTR [rbx], rax

; 684  :         _Wrotesome = false;

	mov	BYTE PTR [rbx+113], 0

; 685  : 
; 686  :         _Mysb::_Init(); // initialize stream buffer base object

	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 687  : 
; 688  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 689  :             _Elem** _Pb = nullptr;
; 690  :             _Elem** _Pn = nullptr;
; 691  :             int* _Nr    = nullptr;
; 692  : 
; 693  :             ::_get_stream_buffer_pointers(
; 694  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 695  :             int* _Nw = _Nr;
; 696  : 
; 697  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 698  :         }
; 699  : 
; 700  :         _Myfile = _File;
; 701  :         _State  = _Stinit;

	mov	rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	xor	eax, eax
	mov	QWORD PTR [rbx+128], rax

; 702  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rax

; 168  :         _Init(nullptr, _Newfl);
; 169  :     }

	mov	rax, rbx

; 701  :         _State  = _Stinit;

	mov	QWORD PTR [rbx+116], rcx

; 168  :         _Init(nullptr, _Newfl);
; 169  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 64
_Count$ = 72
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 988  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN23:
	sub	rsp, 56					; 00000038H

; 227  :     if (_Bytes == 0) {

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 228  :         return nullptr;

	xor	eax, eax

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN4@allocate:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN22@allocate

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN12@allocate
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN12@allocate:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN6@allocate:

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

	add	rsp, 56					; 00000038H

; 136  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN22@allocate:

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN20@allocate:
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAX_K@Z PROC ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAX_K@Z PROC ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 96
_Left$dead$ = 104
_Right$ = 112
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3233 :     _In_z_ const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

$LN150:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	rbx, r8
	mov	r14, rcx

; 1733 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [r8+16]

; 3233 :     _In_z_ const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

	xor	r15d, r15d

; 1738 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();

	mov	rcx, QWORD PTR [rbx+24]
	mov	rax, rcx
	sub	rax, r8
	cmp	rax, 23
	jb	$LN11@operator
	mov	QWORD PTR [rsp+96], rsi

; 1739 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1740 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
; 1741 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1742 : 
; 1743 :         if (_Check_overlap) {
; 1744 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1745 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [r8+23]
	mov	QWORD PTR [rsp+104], rdi

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rdi, rbx

; 1738 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();

	mov	QWORD PTR [rsp+112], r12

; 1739 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1740 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
; 1741 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1742 : 
; 1743 :         if (_Check_overlap) {
; 1744 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1745 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rbx+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rcx, 15
	jbe	SHORT $LN21@operator

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rbx]
$LN21@operator:

; 1751 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {

	lea	rax, OFFSET FLAT:??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@+23
	mov	ebp, 23
	lea	r12, OFFSET FLAT:??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@
	cmp	rax, rdi
	jbe	SHORT $LN14@operator
	lea	rax, QWORD PTR [rdi+r8]
	cmp	r12, rax
	ja	SHORT $LN14@operator

; 1754 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

	cmp	rdi, r12
	ja	SHORT $LN15@operator

; 1755 :                 _Ptr_shifted_after = 0;

	mov	rsi, r15

; 1756 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

	jmp	SHORT $LN16@operator
$LN15@operator:

; 1757 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

	mov	rsi, rdi
	sub	rsi, r12
	jmp	SHORT $LN16@operator
$LN14@operator:

; 1752 :                 // inserted content is before the shifted region, or does not alias
; 1753 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

	mov	rsi, rbp
$LN16@operator:

; 1758 :             }
; 1759 : 
; 1760 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	r8
	lea	rcx, QWORD PTR [rdi+23]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rdi
	call	memmove

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi
	mov	rdx, r12
	mov	rcx, rdi
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1762 :             _Traits::copy(

	sub	rbp, rsi
	lea	rdx, QWORD PTR [r12+23]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rdi+rsi]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbp
	call	memcpy
	mov	r12, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+96]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1764 :             return *this;

	jmp	SHORT $LN10@operator
$LN11@operator:

; 1765 :         }
; 1766 : 
; 1767 :         return _Reallocate_grow_by(

	mov	ebp, 23
	mov	rcx, rbx
	mov	edx, ebp
	mov	QWORD PTR [rsp+40], rbp
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>
	mov	rbx, rax
$LN10@operator:
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [r14], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [r14+16], r15

; 3234 :     return _STD move(_Right.insert(0, _Left));

	mov	rax, r14

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [r14+24], r15

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	YMMWORD PTR [r14], ymm0

; 3234 :     return _STD move(_Right.insert(0, _Left));

	mov	BYTE PTR [rbx], r15b
	mov	QWORD PTR [rbx+16], r15
	mov	QWORD PTR [rbx+24], 15
	vzeroupper

; 3235 : }

	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rbp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD$$QEAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3214 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

$LN110:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 64					; 00000040H

; 1483 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r8+16]

; 3214 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

	xor	r15d, r15d

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [r8+24], 15

; 3214 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

	mov	r9, r8
	mov	rbx, rdx
	mov	rdi, rcx

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r8]
$LN8@operator:

; 1513 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rcx, QWORD PTR [rdx+24]
	mov	rbp, QWORD PTR [rdx+16]
	mov	rax, rcx
	sub	rax, rbp
	cmp	rsi, rax
	ja	SHORT $LN15@operator
	mov	QWORD PTR [rsp+96], r14

; 1514 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rsi+rbp]
	mov	QWORD PTR [rdx+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	r14, rbx

; 436  :         if (_Large_mode_engaged()) {

	cmp	rcx, 15
	jbe	SHORT $LN18@operator

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [rdx]
$LN18@operator:

; 1517 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	rcx, QWORD PTR [r14+rbp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi
	mov	rdx, r9
	call	memmove
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	lea	rax, QWORD PTR [rsi+r14]
	mov	r14, QWORD PTR [rsp+96]
	mov	BYTE PTR [rax+rbp], r15b

; 1519 :             return *this;

	jmp	SHORT $LN14@operator
$LN15@operator:

; 1520 :         }
; 1521 : 
; 1522 :         return _Reallocate_grow_by(

	mov	rdx, rsi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
	mov	rbx, rax
$LN14@operator:
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rdi], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rdi+16], r15

; 3215 :     return _STD move(_Left.append(_Right));

	mov	rax, rdi

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rdi+24], r15

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	YMMWORD PTR [rdi], ymm0

; 3215 :     return _STD move(_Left.append(_Right));

	mov	BYTE PTR [rbx], r15b
	mov	QWORD PTR [rbx+16], r15
	mov	QWORD PTR [rbx+24], 15
	vzeroupper

; 3216 : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0M@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0M@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z PROC ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1><float>, COMDAT

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
	mov	rax, rcx
	ret	0
??$?0M@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEAA@U_Zero_then_variadic_args_t@1@$$QEAM@Z ENDP ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1><float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
_TEXT	SEGMENT
$T3 = 32
$T12 = 32
$T16 = 32
$T19 = 32
$T17 = 56
$T18 = 88
input$ = 144
i$ = 152
??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z PROC ; Json::Parser::skipCommentSIMD16<MappedFile<0> >, COMDAT

; 166  : 		static inline size_t skipCommentSIMD16(const Container& input, size_t i) {

$LN74:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rbx, rdx
	mov	rdi, rcx

; 167  : 
; 168  : 			//static const __m256i ws_slash = _mm256_set1_epi8('/');
; 169  : 			static const __m128i ws_star = _mm_set1_epi8('*');

	mov	esi, OFFSET FLAT:_Init_thread_epoch
	mov	rax, QWORD PTR gs:88
	add	rsi, QWORD PTR [rax]
	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR ?$TSS0@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, eax ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS0
	jle	SHORT $LN2@skipCommen
	lea	rcx, OFFSET FLAT:?$TSS0@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS0
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, -1 ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS0
	jne	SHORT $LN2@skipCommen
	vmovdqu	xmm0, XMMWORD PTR __xmm@2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a
	vmovdqu	XMMWORD PTR ?ws_star@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::ws_star
	lea	rcx, OFFSET FLAT:?$TSS0@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS0
	call	_Init_thread_footer
$LN2@skipCommen:

; 170  : 			static const __m128i ws_lf = _mm_set1_epi8('\n');

	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR ?$TSS1@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, eax ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS1
	jle	SHORT $LN3@skipCommen
	lea	rcx, OFFSET FLAT:?$TSS1@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS1
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS1@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA, -1 ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS1
	jne	SHORT $LN3@skipCommen
	vmovdqu	xmm0, XMMWORD PTR __xmm@0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a
	vmovdqu	XMMWORD PTR ?ws_lf@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::ws_lf
	lea	rcx, OFFSET FLAT:?$TSS1@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::$TSS1
	call	_Init_thread_footer
$LN3@skipCommen:

; 171  : 			__m128i chunk;
; 172  : 			uint16_t mask;
; 173  : 
; 174  : 			i += 2;

	add	rbx, 2

; 175  : 			if (i >= input.size())

	mov	rdx, QWORD PTR [rdi+8]
	cmp	rbx, rdx
	jae	$LN72@skipCommen
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	r8, QWORD PTR [rdi]
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 177  : 			char c = input[i - 1];

	movzx	eax, BYTE PTR [r8+rbx-1]

; 178  : 			if (c == '/')

	cmp	al, 47					; 0000002fH
	jne	SHORT $LN15@skipCommen

; 179  : 			{
; 180  : 				while (i + 16 <= input.size()) {

	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rdx
	ja	SHORT $LN5@skipCommen
	vmovdqu	xmm2, XMMWORD PTR ?ws_lf@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::ws_lf
	npad	2
$LL4@skipCommen:

; 181  : 					chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&input[i]));
; 182  : 					mask = _mm_movemask_epi8(_mm_cmpeq_epi8(chunk, ws_lf));

	vpcmpeqb xmm1, xmm2, XMMWORD PTR [rax+r8-16]
	vpmovmskb ecx, xmm1

; 183  : 					if (mask != 0)

	test	cx, cx
	jne	SHORT $LN46@skipCommen

; 185  : 					i += 16;

	add	rbx, 16
	add	rax, 16

; 179  : 			{
; 180  : 				while (i + 16 <= input.size()) {

	cmp	rax, rdx
	jbe	SHORT $LL4@skipCommen
$LN5@skipCommen:

; 186  : 				}
; 187  : 				for (; i < input.size() && input[i] != '\n'; ++i);

	cmp	rbx, rdx
	jae	SHORT $LN7@skipCommen
$LL8@skipCommen:
	cmp	BYTE PTR [r8+rbx], 10
	je	SHORT $LN7@skipCommen
	inc	rbx
	cmp	rbx, rdx
	jb	SHORT $LL8@skipCommen
$LN7@skipCommen:

; 215  : 		};

	mov	rax, rbx
$LN1@skipCommen:
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN46@skipCommen:

; 184  : 						return i + CTZ16(mask);

	tzcnt	ax, cx
	movzx	eax, ax
	add	rax, rbx
	jmp	SHORT $LN1@skipCommen
$LN15@skipCommen:

; 188  : 				return i;
; 189  : 			}
; 190  : 			else if (c == '*')

	cmp	al, 42					; 0000002aH
	jne	$LN18@skipCommen

; 191  : 			{
; 192  : 				while (i + 16 <= input.size()) {

	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rdx
	ja	SHORT $LL13@skipCommen
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	vmovdqu	xmm2, XMMWORD PTR ?ws_star@?1???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4T__m128i@@B ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`2'::ws_star
	npad	1
$LL9@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 194  : 					mask = _mm_movemask_epi8(_mm_cmpeq_epi8(chunk, ws_star));

	vpcmpeqb xmm1, xmm2, XMMWORD PTR [r8+rbx]
	vpmovmskb eax, xmm1

; 195  : 					if (mask != 0) {

	test	ax, ax
	je	SHORT $LN19@skipCommen

; 196  : 						size_t j = i + CTZ16(mask) + 1;

	tzcnt	ax, ax
	movzx	eax, ax
	inc	rax
	add	rax, rbx

; 197  : 						if (j >= input.size())

	cmp	rax, rdx
	jae	SHORT $LN47@skipCommen

; 199  : 						else if (input[j] == '/')

	cmp	BYTE PTR [r8+rax], 47			; 0000002fH
	je	SHORT $LN1@skipCommen

; 200  : 							return j;
; 201  : 						i = j + 1;

	lea	rbx, QWORD PTR [rax+1]

; 202  : 						continue;

	jmp	SHORT $LN52@skipCommen
$LN19@skipCommen:

; 203  : 					}
; 204  : 					i += 16;

	add	rbx, 16
$LN52@skipCommen:

; 191  : 			{
; 192  : 				while (i + 16 <= input.size()) {

	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rdx
	jbe	SHORT $LL9@skipCommen

; 205  : 				}
; 206  : 				for (; i < input.size(); ++i)

	cmp	rbx, rdx
	jae	SHORT $LN55@skipCommen
$LL13@skipCommen:

; 207  : 				{
; 208  : 					if (input[i] == '*' && ++i < input.size() && input[i] == '/') {

	cmp	BYTE PTR [r8+rbx], 42			; 0000002aH
	jne	SHORT $LN11@skipCommen
	inc	rbx
	cmp	rbx, rdx
	jae	SHORT $LN11@skipCommen
	cmp	BYTE PTR [r8+rbx], 47			; 0000002fH
	je	$LN7@skipCommen
$LN11@skipCommen:

; 205  : 				}
; 206  : 				for (; i < input.size(); ++i)

	inc	rbx
	cmp	rbx, rdx
	jae	SHORT $LN55@skipCommen
	jmp	SHORT $LL13@skipCommen
$LN47@skipCommen:

; 198  : 							throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T12[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T12[rsp]
	call	_CxxThrowException
	int	3
$LN55@skipCommen:

; 209  : 						return i;
; 210  : 					}
; 211  : 				}
; 212  : 				throw std::runtime_error("Endless block comment");

	lea	rdx, OFFSET FLAT:??_C@_0BG@PEGDFFCL@Endless?5block?5comment@
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T16[rsp]
	call	_CxxThrowException
	int	3
$LN18@skipCommen:

; 213  : 			}
; 214  : 			throw std::runtime_error(std::string("Invalid comment syntax") + input[i]);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??A?$MappedFile@$0A@@@QEBAAEBD_K@Z	; MappedFile<0>::operator[]
	movzx	ebx, BYTE PTR [rax]
	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	movzx	r8d, bl
	mov	rdx, rax
	lea	rcx, QWORD PTR $T18[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T19[rsp]
	call	_CxxThrowException
	npad	1
$LN72@skipCommen:

; 176  : 				throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
	int	3
$LN70@skipCommen:
??$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ENDP ; Json::Parser::skipCommentSIMD16<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T12 = 32
$T16 = 32
$T19 = 32
$T17 = 56
$T18 = 88
input$ = 144
i$ = 152
?dtor$0@?0???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA PROC ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`1'::dtor$0
	lea	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ENDP ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T12 = 32
$T16 = 32
$T19 = 32
$T17 = 56
$T18 = 88
input$ = 144
i$ = 152
?dtor$1@?0???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA PROC ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$skipCommentSIMD16@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z@4HA ENDP ; `Json::Parser::skipCommentSIMD16<MappedFile<0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$skipCommentScalar@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z
_TEXT	SEGMENT
$T1 = 32
$T6 = 32
$T7 = 32
input$ = 80
i$ = 88
??$skipCommentScalar@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z PROC ; Json::Parser::skipCommentScalar<MappedFile<0> >, COMDAT

; 219  : 		static inline size_t skipCommentScalar(const Container& input, size_t i) {

$LN38:
	sub	rsp, 72					; 00000048H

; 220  : 			++i;
; 221  : 			if (i >= input.size()) throw std::runtime_error("Invalid comment syntax");

	mov	rax, QWORD PTR [rcx+8]
	inc	rdx
	cmp	rdx, rax
	jae	SHORT $LN37@skipCommen
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\MappedFile.h

; 80   :     inline const char& operator[](size_t i) const { return m_data[i]; };

	mov	rcx, QWORD PTR [rcx]
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 222  : 			char c = input[i];

	movzx	r8d, BYTE PTR [rcx+rdx]

; 223  : 			++i;

	inc	rdx

; 224  : 			if (c == lineComment) {

	cmp	r8b, 47					; 0000002fH
	jne	SHORT $LN9@skipCommen

; 225  : 				for (; i < input.size() && input[i] != '\n'; ++i); // skip to end of line

	cmp	rdx, rax
	jae	SHORT $LN3@skipCommen
$LL4@skipCommen:
	cmp	BYTE PTR [rcx+rdx], 10
	je	SHORT $LN3@skipCommen
	inc	rdx
	cmp	rdx, rax
	jb	SHORT $LL4@skipCommen
$LN3@skipCommen:

; 238  : 		}

	mov	rax, rdx
	add	rsp, 72					; 00000048H
	ret	0
$LN9@skipCommen:

; 226  : 				return i;
; 227  : 			}
; 228  : 			else if (c == blockCommentStart) {

	cmp	r8b, 42					; 0000002aH
	jne	SHORT $LN11@skipCommen

; 229  : 				for (; i < input.size(); ++i)

	cmp	rdx, rax
	jae	SHORT $LN27@skipCommen
$LL7@skipCommen:

; 230  : 				{
; 231  : 					if (input[i] == blockCommentEnd && ++i < input.size() && input[i] == commentStart) {

	cmp	BYTE PTR [rcx+rdx], 42			; 0000002aH
	jne	SHORT $LN5@skipCommen
	inc	rdx
	cmp	rdx, rax
	jae	SHORT $LN5@skipCommen
	cmp	BYTE PTR [rcx+rdx], 47			; 0000002fH
	je	SHORT $LN3@skipCommen
$LN5@skipCommen:

; 229  : 				for (; i < input.size(); ++i)

	inc	rdx
	cmp	rdx, rax
	jae	SHORT $LN27@skipCommen
	jmp	SHORT $LL7@skipCommen
$LN11@skipCommen:

; 236  : 			}
; 237  : 			throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T7[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T7[rsp]
	call	_CxxThrowException
	int	3
$LN37@skipCommen:

; 220  : 			++i;
; 221  : 			if (i >= input.size()) throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN27@skipCommen:

; 232  : 						return i;
; 233  : 					}
; 234  : 				}
; 235  : 				throw std::runtime_error("Endless block comment");

	lea	rdx, OFFSET FLAT:??_C@_0BG@PEGDFFCL@Endless?5block?5comment@
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T6[rsp]
	call	_CxxThrowException
	int	3
$LN35@skipCommen:
??$skipCommentScalar@V?$MappedFile@$0A@@@@Parser@Json@@CA_KAEBV?$MappedFile@$0A@@@_K@Z ENDP ; Json::Parser::skipCommentScalar<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ
_TEXT	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
this$ = 48
__$ReturnUdt$ = 80
??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ PROC ; std::make_unique<Json::Object,0>, COMDAT

; 3629 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN97:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	ebp, ebp

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T2[rsp], rax
	vpxor	xmm0, xmm0, xmm0
	xor	eax, eax
	vmovups	YMMWORD PTR [rdi], ymm0
	vmovups	YMMWORD PTR [rdi+32], ymm0
	mov	QWORD PTR [rdi+64], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Object.h

; 18   : 		Object() : Value() {};

	lea	rax, OFFSET FLAT:??_7Object@Json@@6B@
	mov	QWORD PTR [rdi], rax
	lea	rbx, QWORD PTR [rdi+8]
	mov	QWORD PTR this$[rsp], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map

; 49   :     explicit _Umap_traits(const _Tr& _Traits) noexcept(is_nothrow_copy_constructible_v<_Tr>) : _Tr(_Traits) {}

	mov	DWORD PTR [rbx], ebp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	mov	QWORD PTR [rbx+8], rbp
	mov	QWORD PTR [rbx+16], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 136  :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	vzeroupper
	call	??2@YAPEAX_K@Z				; operator new
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 1852 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	QWORD PTR [rax], rax

; 1853 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1854 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx+8], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 371  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	lea	rcx, QWORD PTR [rbx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rbp
	mov	QWORD PTR [rcx+8], rbp
	mov	QWORD PTR [rcx+16], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 371  :         : _Traitsobj(_Parg), _List(_Al), _Vec(_Al), _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) {

	mov	QWORD PTR [rbx+48], 7
	mov	QWORD PTR [rbx+56], 8

; 372  :         // construct empty hash table
; 373  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [rbx], 1065353216		; 3f800000H

; 374  :         _Vec._Assign_grow(_Min_buckets * 2, _List._Unchecked_end());

	mov	r8, QWORD PTR [rbx+8]
	mov	edx, 16
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Assign_grow
	npad	1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	rax, rsi

; 3631 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ ENDP ; std::make_unique<Json::Object,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
this$ = 48
__$ReturnUdt$ = 80
?dtor$0@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA PROC ; `std::make_unique<Json::Object,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 72					; 00000048H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA ENDP ; `std::make_unique<Json::Object,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
this$ = 48
__$ReturnUdt$ = 80
?dtor$4@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA PROC ; `std::make_unique<Json::Object,0>'::`1'::dtor$4
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
?dtor$4@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA ENDP ; `std::make_unique<Json::Object,0>'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
this$ = 48
__$ReturnUdt$ = 80
?dtor$5@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA PROC ; `std::make_unique<Json::Object,0>'::`1'::dtor$5
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >
?dtor$5@?0???$make_unique@VObject@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@0@XZ@4HA ENDP ; `std::make_unique<Json::Object,0>'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$1$ = 32
<_Vals_1>$GSCopy$1$ = 40
_Newnode$91 = 48
this$ = 144
__$ReturnUdt$ = 152
<_Vals_0>$ = 160
<_Vals_1>$ = 168
??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 594  :     conditional_t<_Multi, iterator, pair<iterator, bool>> emplace(_Valtys&&... _Vals) {

$LN345:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR <_Vals_1>$GSCopy$1$[rsp], r9
	mov	r14, r8
	mov	r12, rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rsp], rdx
	mov	r13, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3390 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	rdi, QWORD PTR [r8+16]

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rdx, r8

; 453  :         return _Myres > _Small_string_capacity;

	mov	r15, QWORD PTR [r8+24]

; 445  :         if (_Large_mode_engaged()) {

	cmp	r15, 15
	jbe	SHORT $LN333@emplace

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [r8]
$LN333@emplace:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2292 :     return _Fnv1a_append_bytes(

	mov	rbp, -3750763034362895579		; cbf29ce484222325H
	xor	ecx, ecx

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	rdi, rdi
	je	SHORT $LN30@emplace
	mov	r8, 1099511628211			; 00000100000001b3H
	npad	13
$LL313@emplace:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+rcx]
	xor	rbp, rax

; 2261 :         _Val *= _FNV_prime;

	imul	rbp, r8

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	inc	rcx
	cmp	rcx, rdi
	jb	SHORT $LL313@emplace
$LN30@emplace:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1586 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR [r13+48]
	and	rax, rbp

; 1587 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rax, rax
	mov	rcx, QWORD PTR [r13+24]
	mov	rbx, QWORD PTR [rcx+rax*8+8]

; 1588 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	lea	rdx, QWORD PTR [r13+8]
	mov	rsi, QWORD PTR [rdx]

; 1589 :         if (_Where == _End) {

	cmp	rbx, rsi
	je	SHORT $LN2@emplace

; 1590 :             return {_End, _Nodeptr{}};
; 1591 :         }
; 1592 : 
; 1593 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rsi, QWORD PTR [rcx+rax*8]
	npad	10
$LL37@emplace:

; 1596 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+40], 15
	jbe	SHORT $LN55@emplace

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN55@emplace:

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 445  :         if (_Large_mode_engaged()) {

	cmp	r15, 15
	jbe	SHORT $LN62@emplace

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN62@emplace:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	rdi, QWORD PTR [rbx+32]
	jne	SHORT $LN329@emplace

; 605  :         return false;
; 606  :     }
; 607  : 
; 608  :     if (_Left_size == 0u) {

	test	rdi, rdi
	je	SHORT $LN303@emplace

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	call	memcmp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1596 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN303@emplace
$LN329@emplace:

; 1604 :             }
; 1605 : 
; 1606 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rsi
	je	SHORT $LN304@emplace

; 1608 :             }
; 1609 : 
; 1610 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
	jmp	SHORT $LL37@emplace
$LN303@emplace:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r12], rbx
	mov	BYTE PTR [r12+8], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 613  :                 return {_List._Make_iter(_Target._Duplicate), false};

	jmp	$LN340@emplace
$LN304@emplace:

; 1607 :                 return {_Where, _Nodeptr{}};

	mov	rsi, rbx
	lea	rdx, QWORD PTR [r13+8]
$LN2@emplace:

; 1666 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 329406144173384850			; 0492492492492492H
	cmp	QWORD PTR [r13+16], rax
	jne	SHORT $LN92@emplace

; 1667 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN92@emplace:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR _Newnode$91[rsp], rdx

; 1167 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	xor	ebx, ebx
	mov	QWORD PTR _Newnode$91[rsp+8], rbx

; 1168 :         _Ptr = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r15, rax
	mov	QWORD PTR _Newnode$91[rsp+8], rax
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rax+16], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rax+32], rbx

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rax+40], rbx

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [r14]
	vmovups	YMMWORD PTR [rax+16], ymm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	BYTE PTR [r14], bl
	mov	QWORD PTR [r14+16], rbx
	mov	QWORD PTR [r14+24], 15

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR <_Vals_1>$GSCopy$1$[rsp]
	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r15+48], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 916  :         return _Max_bucket_size();

	vmovss	xmm2, DWORD PTR [r13]

; 1674 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rdx, QWORD PTR [r13+56]

; 1668 :         }
; 1669 :     }
; 1670 : 
; 1671 :     bool _Check_rehash_required_1() const noexcept {
; 1672 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1673 :         const auto _Newsize      = _Oldsize + 1;

	mov	rcx, QWORD PTR [r13+16]
	add	rcx, 1

; 1674 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	vxorps	xmm1, xmm1, xmm1
	js	SHORT $LN337@emplace
	vcvtsi2ss xmm1, xmm1, rcx
	jmp	SHORT $LN338@emplace
$LN337@emplace:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	vcvtsi2ss xmm1, xmm1, rax
	vaddss	xmm1, xmm1, xmm1
$LN338@emplace:
	vxorps	xmm0, xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN335@emplace
	vcvtsi2ss xmm0, xmm0, rdx
	jmp	SHORT $LN336@emplace
$LN335@emplace:
	mov	rcx, rdx
	shr	rcx, 1
	mov	rax, rdx
	and	eax, 1
	or	rcx, rax
	vcvtsi2ss xmm0, xmm0, rcx
	vaddss	xmm0, xmm0, xmm0
$LN336@emplace:
	vdivss	xmm0, xmm1, xmm0
	vcomiss	xmm0, xmm2

; 614  :             }
; 615  : 
; 616  :             _Check_max_size();
; 617  :             // invalidates _Keyval:
; 618  :             _List_node_emplace_op2<_Alnode> _Newnode(_List._Getal(), _STD forward<_Valtys>(_Vals)...);
; 619  :             if (_Check_rehash_required_1()) {

	jbe	$LN3@emplace

; 1703 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	vdivss	xmm0, xmm1, xmm2
	vxorps	xmm1, xmm1, xmm1
	vroundss xmm1, xmm1, xmm0, 2
	xor	ecx, ecx
	vmovss	xmm0, DWORD PTR __real@5f000000
	vcomiss	xmm1, xmm0
	jb	SHORT $LN334@emplace
	vsubss	xmm1, xmm1, xmm0
	vcomiss	xmm1, xmm0
	jae	SHORT $LN334@emplace
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN334@emplace:
	vcvttss2si rax, xmm1
	add	rax, rcx

; 1708 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax

; 1709 :         if (_Old_buckets >= _Req_buckets) {

	cmp	rdx, rcx
	jae	SHORT $LN242@emplace

; 1710 :             // we already have enough buckets so there's no need to change the count
; 1711 :             return _Old_buckets;
; 1712 :         }
; 1713 : 
; 1714 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	rdx, 512				; 00000200H
	jae	SHORT $LN244@emplace
	lea	rax, QWORD PTR [rdx*8]
	mov	rdx, rax
	cmp	rax, rcx
	jae	SHORT $LN242@emplace
$LN244@emplace:

; 1715 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1716 :             return _Old_buckets * 8;
; 1717 :         }
; 1718 : 
; 1719 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1720 :         return _Req_buckets;

	mov	rdx, rcx
$LN242@emplace:

; 1680 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rcx, r13
	vzeroupper
	call	?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Forced_rehash

; 1586 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rax, QWORD PTR [r13+48]
	and	rax, rbp

; 1587 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rax, rax
	mov	rcx, QWORD PTR [r13+24]
	mov	rbx, QWORD PTR [rcx+rax*8+8]

; 1588 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rsi, QWORD PTR [r13+8]

; 1589 :         if (_Where == _End) {

	cmp	rbx, rsi
	je	SHORT $LN3@emplace

; 1590 :             return {_End, _Nodeptr{}};
; 1591 :         }
; 1592 : 
; 1593 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rsi, QWORD PTR [rcx+rax*8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	r12, QWORD PTR [r15+40]

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rdi, QWORD PTR [r15+32]
	npad	2
$LL259@emplace:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1596 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+40], 15
	jbe	SHORT $LN277@emplace

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN277@emplace:

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [r15+16]

; 445  :         if (_Large_mode_engaged()) {

	cmp	r12, 15
	jbe	SHORT $LN284@emplace

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r15+16]
$LN284@emplace:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	rdi, QWORD PTR [rbx+32]
	jne	SHORT $LN330@emplace

; 605  :         return false;
; 606  :     }
; 607  : 
; 608  :     if (_Left_size == 0u) {

	test	rdi, rdi
	je	SHORT $LN305@emplace

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	call	memcmp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1596 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN305@emplace
$LN330@emplace:

; 1604 :             }
; 1605 : 
; 1606 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rsi
	je	SHORT $LN306@emplace

; 1608 :             }
; 1609 : 
; 1610 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
	jmp	SHORT $LL259@emplace
$LN305@emplace:

; 1597 :                 if constexpr (!_Traits::_Standard) {
; 1598 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1599 :                         return {_Where->_Next, _Nodeptr{}};
; 1600 :                     }
; 1601 :                 }
; 1602 : 
; 1603 :                 return {_Where->_Next, _Where};

	mov	rsi, QWORD PTR [rbx]
	jmp	SHORT $LN341@emplace
$LN306@emplace:

; 1607 :                 return {_Where, _Nodeptr{}};

	mov	rsi, rbx
$LN341@emplace:

; 1634 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	r12, QWORD PTR __$ReturnUdt$GSCopy$1$[rsp]
$LN3@emplace:
	mov	rdx, QWORD PTR [rsi+8]

; 1635 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [r13+16]

; 1636 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [r15], rsi

; 1637 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [r15+8], rdx

; 1638 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [rdx], r15

; 1639 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [rsi+8], r15

; 1640 : 
; 1641 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1642 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;
; 1643 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rax, QWORD PTR [r13+48]
	and	rax, rbp

; 1644 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	add	rax, rax
	mov	rcx, QWORD PTR [r13+24]

; 1645 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1646 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r8, QWORD PTR [rcx+rax*8]
	cmp	r8, QWORD PTR [r13+8]
	jne	SHORT $LN192@emplace

; 1647 :             // bucket is empty, set both
; 1648 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], r15

; 1649 :             _Bucket_hi._Ptr = _Newnode;

	jmp	SHORT $LN342@emplace
$LN192@emplace:

; 1650 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r8, rsi
	jne	SHORT $LN194@emplace

; 1651 :             // new node is the lowest element in the bucket
; 1652 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rax*8], r15
	jmp	SHORT $LN196@emplace
$LN194@emplace:

; 1653 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rcx+rax*8+8], rdx
	jne	SHORT $LN196@emplace
$LN342@emplace:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx+rax*8+8], r15
$LN196@emplace:
	mov	QWORD PTR [r12], r15
	mov	BYTE PTR [r12+8], 1
$LN340@emplace:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 644  :     }

	mov	rax, r12
	vzeroupper
	add	rsp, 72					; 00000048H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN339@emplace:
??$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$1$ = 32
<_Vals_1>$GSCopy$1$ = 40
_Newnode$91 = 48
this$ = 144
__$ReturnUdt$ = 152
<_Vals_0>$ = 160
<_Vals_1>$ = 168
?dtor$1@?0???$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Newnode$91[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
?dtor$1@?0???$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
__$ReturnUdt$GSCopy$1$ = 32
<_Vals_1>$GSCopy$1$ = 40
_Newnode$91 = 48
this$ = 144
__$ReturnUdt$ = 152
<_Vals_0>$ = 160
<_Vals_1>$ = 168
?dtor$0@?0???$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Newnode$91[rdx]
	jmp	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
?dtor$0@?0???$emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VObject@Json@@U?$default_delete@VObject@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0VObject@Json@@U?$default_delete@VObject@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@1@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Object,std::default_delete<Json::Object>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3394 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0VObject@Json@@U?$default_delete@VObject@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@1@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Object,std::default_delete<Json::Object>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$make_unique@VArray@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@0@XZ
_TEXT	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
??$make_unique@VArray@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@0@XZ PROC ; std::make_unique<Json::Array,0>, COMDAT

; 3629 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN33:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 32					; 00000020H
	xor	edi, edi
	call	??2@YAPEAX_K@Z				; operator new
	vpxor	xmm0, xmm0, xmm0
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h

; 17   : 		Array() : Value() {};

	lea	rcx, OFFSET FLAT:??_7Array@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T2[rsp], rax
	vmovups	YMMWORD PTR [rax], ymm0
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Array.h

; 17   : 		Array() : Value() {};

	mov	QWORD PTR [rax], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+8], rdi
	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rbx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	rax, rbx
	vzeroupper

; 3631 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@VArray@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@0@XZ ENDP ; std::make_unique<Json::Array,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VArray@Json@@U?$default_delete@VArray@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0VArray@Json@@U?$default_delete@VArray@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@1@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Array,std::default_delete<Json::Array>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3394 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0VArray@Json@@U?$default_delete@VArray@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@1@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Array,std::default_delete<Json::Array>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
$T35 = 48
$T77 = 48
$T75 = 72
$T76 = 104
_Eptr$78 = 136
hex$79 = 144
__$ArrayPad$ = 176
input$ = 224
i$ = 232
string$ = 240
??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Parser::handleEscapedChar<MappedFile<0> >, COMDAT

; 62   : 		{

$LN301:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	r8, rcx

; 63   : 			if (i >= input.size()) throw std::runtime_error("Unterminated escape sequence");

	mov	r9, QWORD PTR [rdx]
	cmp	r9, QWORD PTR [rcx+8]
	jae	$LN298@handleEsca

; 64   : 			char escaped = input[i];

	mov	rax, QWORD PTR [rcx]
	movsx	ebx, BYTE PTR [r9+rax]

; 65   : 			switch (escaped) {

	mov	eax, ebx
	add	eax, -34				; ffffffdeH
	cmp	eax, 83					; 00000053H
	ja	$LN19@handleEsca
	cdqe
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN289@handleEsca[r10+rax]
	mov	ecx, DWORD PTR $LN290@handleEsca[r10+rax*4]
	add	rcx, r10
	jmp	rcx
$LN5@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN27@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN30@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN30@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 34			; 00000022H

; 2299 :             return;

	jmp	SHORT $LN2@handleEsca
$LN27@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 34					; 00000022H
$LN296@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 107  : 		}

	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN2@handleEsca:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+248]
	add	rsp, 192				; 000000c0H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN6@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN37@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN40@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN40@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 92			; 0000005cH

; 2299 :             return;

	jmp	SHORT $LN2@handleEsca
$LN37@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 92					; 0000005cH
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 67   : 			case '\\': string.push_back('\\'); break;

	jmp	SHORT $LN296@handleEsca
$LN7@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN47@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN50@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN50@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 47			; 0000002fH

; 2299 :             return;

	jmp	SHORT $LN2@handleEsca
$LN47@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 47					; 0000002fH
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 68   : 			case '/':  string.push_back('/'); break;

	jmp	$LN296@handleEsca
$LN8@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN57@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN60@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN60@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 8

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN57@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 8
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 69   : 			case 'b':  string.push_back('\b'); break;

	jmp	$LN296@handleEsca
$LN9@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN67@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN70@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN70@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 12

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN67@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 12
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 70   : 			case 'f':  string.push_back('\f'); break;

	jmp	$LN296@handleEsca
$LN10@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN77@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN80@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN80@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 10

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN77@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 10
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 71   : 			case 'n':  string.push_back('\n'); break;

	jmp	$LN296@handleEsca
$LN11@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN87@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN90@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN90@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 13

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN87@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 13
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 72   : 			case 'r':  string.push_back('\r'); break;

	jmp	$LN296@handleEsca
$LN12@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN97@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN100@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN100@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 9

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN97@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 9
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 73   : 			case 't':  string.push_back('\t'); break;

	jmp	$LN296@handleEsca
$LN13@handleEsca:

; 74   : 			case 'u': {
; 75   : 				// Unicode escape \uXXXX
; 76   : 				i += 4;

	lea	rax, QWORD PTR [r9+4]
	mov	QWORD PTR [rdx], rax

; 77   : 				if (i >= input.size())

	cmp	rax, QWORD PTR [r8+8]
	jae	$LN299@handleEsca
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR hex$79[rsp], xmm0

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR hex$79[rsp+24], 15

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR hex$79[rsp], 0

; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR hex$79[rsp+16], 4
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	rax, QWORD PTR [r8]
	mov	ecx, DWORD PTR [r9+rax+1]
	mov	DWORD PTR hex$79[rsp], ecx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR hex$79[rsp+4], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 133  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
	mov	r14, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR hex$79[rsp]

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR hex$79[rsp+24], 15
	cmova	rbx, QWORD PTR hex$79[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 136  :     _Errno_ref               = 0;

	mov	DWORD PTR [rax], 0

; 137  :     const unsigned long _Ans = _CSTD strtoul(_Ptr, &_Eptr, _Base);

	mov	r8d, 16
	lea	rdx, QWORD PTR _Eptr$78[rsp]
	mov	rcx, rbx
	call	QWORD PTR __imp_strtoul
	mov	esi, eax

; 138  : 
; 139  :     if (_Ptr == _Eptr) {

	cmp	rbx, QWORD PTR _Eptr$78[rsp]
	jne	SHORT $LN155@handleEsca

; 140  :         _Xinvalid_argument("invalid stoul argument");

	lea	rcx, OFFSET FLAT:??_C@_0BH@DPNNDOEK@invalid?5stoul?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN155@handleEsca:

; 141  :     }
; 142  : 
; 143  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [r14], 34			; 00000022H
	jne	SHORT $LN156@handleEsca

; 144  :         _Xout_of_range("stoul argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BM@MOLGGFGJ@stoul?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN156@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 84   : 				unsigned int codepoint = std::stoul(hex, nullptr, 16);

	mov	rcx, QWORD PTR [rdi+16]
	mov	rdx, QWORD PTR [rdi+24]

; 85   : 				if (codepoint <= 0x7F) {

	cmp	esi, 127				; 0000007fH
	jbe	$LN295@handleEsca

; 86   : 					string.push_back(static_cast<char>(codepoint));
; 87   : 				}
; 88   : 				else {
; 89   : 					// Convert Unicode codepoint to UTF-8
; 90   : 					if (codepoint <= 0x7FF) {

	mov	r9d, esi
	cmp	esi, 2047				; 000007ffH
	ja	SHORT $LN17@handleEsca

; 91   : 						// 2-byte UTF-8
; 92   : 						string.push_back(static_cast<char>(0xC0 | (codepoint >> 6)));

	shr	r9d, 6
	or	r9b, -64				; ffffffffffffffc0H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	cmp	rcx, rdx
	jae	$LN243@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN288@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 2299 :             return;

	jmp	SHORT $LN242@handleEsca
$LN17@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 97   : 						string.push_back(static_cast<char>(0xE0 | (codepoint >> 12)));

	shr	r9d, 12
	or	r9b, -32				; ffffffffffffffe0H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	cmp	rcx, rdx
	jae	SHORT $LN233@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN287@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN287@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 2299 :             return;

	jmp	SHORT $LN232@handleEsca
$LN233@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN232@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 98   : 						string.push_back(static_cast<char>(0x80 | ((codepoint >> 6) & 0x3F)));

	mov	r9d, esi
	shr	r9d, 6
	and	r9b, 63					; 0000003fH
	or	r9b, -128				; ffffffffffffff80H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN243@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN288@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN288@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 2299 :             return;

	jmp	SHORT $LN242@handleEsca
$LN243@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 102  : 				break;

	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN242@handleEsca:
	and	sil, 63					; 0000003fH
	mov	rdx, QWORD PTR [rdi+24]
	mov	rcx, QWORD PTR [rdi+16]
	or	sil, -128				; ffffffffffffff80H
$LN295@handleEsca:
	cmp	rcx, rdx
	jae	SHORT $LN253@handleEsca
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	cmp	rdx, 15
	jbe	SHORT $LN256@handleEsca
	mov	rdi, QWORD PTR [rdi]
$LN256@handleEsca:
	mov	BYTE PTR [rdi+rcx+1], 0
	mov	BYTE PTR [rdi+rcx], sil
	jmp	SHORT $LN252@handleEsca
$LN253@handleEsca:
	movzx	r9d, sil
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
	npad	1
$LN252@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR hex$79[rsp+24]
	cmp	rdx, 15
	jbe	$LN2@handleEsca

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR hex$79[rsp]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN196@handleEsca

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN196@handleEsca
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN196@handleEsca:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 102  : 				break;

	jmp	$LN2@handleEsca
$LN299@handleEsca:

; 78   : 					throw std::runtime_error("Invalid unicode escape");

	lea	rdx, OFFSET FLAT:??_C@_0BH@JICOIFBC@Invalid?5unicode?5escape@
	lea	rcx, QWORD PTR $T35[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T35[rsp]
	call	_CxxThrowException
	int	3
$LN19@handleEsca:

; 103  : 			}
; 104  : 			default:
; 105  : 				throw std::runtime_error(std::string("Invalid escape sequence: \\") + escaped);

	lea	rdx, OFFSET FLAT:??_C@_0BL@KLIDEEPE@Invalid?5escape?5sequence?3?5?2@
	lea	rcx, QWORD PTR $T75[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	movzx	r8d, bl
	mov	rdx, rax
	lea	rcx, QWORD PTR $T76[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T77[rsp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T77[rsp]
	call	_CxxThrowException
	npad	1
$LN298@handleEsca:

; 63   : 			if (i >= input.size()) throw std::runtime_error("Unterminated escape sequence");

	lea	rdx, OFFSET FLAT:??_C@_0BN@LPMKJIHG@Unterminated?5escape?5sequence@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN291@handleEsca:
$LN290@handleEsca:

; 107  : 		}

	DD	$LN5@handleEsca
	DD	$LN7@handleEsca
	DD	$LN6@handleEsca
	DD	$LN8@handleEsca
	DD	$LN9@handleEsca
	DD	$LN10@handleEsca
	DD	$LN11@handleEsca
	DD	$LN12@handleEsca
	DD	$LN13@handleEsca
	DD	$LN19@handleEsca
$LN289@handleEsca:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	7
	DB	8
??$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Parser::handleEscapedChar<MappedFile<0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T35 = 48
$T77 = 48
$T75 = 72
$T76 = 104
_Eptr$78 = 136
hex$79 = 144
__$ArrayPad$ = 176
input$ = 224
i$ = 232
string$ = 240
?dtor$0@?0???$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Parser::handleEscapedChar<MappedFile<0> >'::`1'::dtor$0
	lea	rcx, QWORD PTR hex$79[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Parser::handleEscapedChar<MappedFile<0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T35 = 48
$T77 = 48
$T75 = 72
$T76 = 104
_Eptr$78 = 136
hex$79 = 144
__$ArrayPad$ = 176
input$ = 224
i$ = 232
string$ = 240
?dtor$1@?0???$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Parser::handleEscapedChar<MappedFile<0> >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T75[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Parser::handleEscapedChar<MappedFile<0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T35 = 48
$T77 = 48
$T75 = 72
$T76 = 104
_Eptr$78 = 136
hex$79 = 144
__$ArrayPad$ = 176
input$ = 224
i$ = 232
string$ = 240
?dtor$2@?0???$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Json::Parser::handleEscapedChar<MappedFile<0> >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T76[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$handleEscapedChar@V?$MappedFile@$0A@@@@Parser@Json@@CAXAEAV?$MappedFile@$0A@@@AEA_KAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Json::Parser::handleEscapedChar<MappedFile<0> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@String@Json@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 8
value$ = 16
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@String@Json@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::String::String<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	vpxor	xmm0, xmm0, xmm0
	lea	rax, OFFSET FLAT:??_7String@Json@@6B@
	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	eax, eax

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx+8], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+24], rax

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+32], rax

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rcx+8], ymm0
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\String.h

; 17   : 		String(T&& value) : Value(), m_value(std::forward<T>(value)) {};

	mov	BYTE PTR [rdx], al
	mov	QWORD PTR [rdx+16], rax
	mov	rax, rcx
	mov	QWORD PTR [rdx+24], 15
	vzeroupper
	ret	0
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@String@Json@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::String::String<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@PEAVString@Json@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@PEAVString@Json@@@Z PROC ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::unique_ptr<Json::String,std::default_delete<Json::String> ><std::default_delete<Json::String>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3370 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VString@Json@@@std@@$0A@@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAA@PEAVString@Json@@@Z ENDP ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::unique_ptr<Json::String,std::default_delete<Json::String> ><std::default_delete<Json::String>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$make_unique@VBool@Json@@_N$0A@@std@@YA?AV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@0@$$QEA_N@Z
_TEXT	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
<_Args_0>$ = 72
??$make_unique@VBool@Json@@_N$0A@@std@@YA?AV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@0@$$QEA_N@Z PROC ; std::make_unique<Json::Bool,bool,0>, COMDAT

; 3629 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN21:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	mov	rbx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	movzx	ecx, BYTE PTR [rbx]
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	lea	rdx, OFFSET FLAT:??_7Bool@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3631 : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	QWORD PTR $T2[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Bool.h

; 13   : 		Bool(bool value) : Value(), m_value(value) {};

	mov	QWORD PTR [rax], rdx
	mov	BYTE PTR [rax+8], cl
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	rax, rdi

; 3631 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@VBool@Json@@_N$0A@@std@@YA?AV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@0@$$QEA_N@Z ENDP ; std::make_unique<Json::Bool,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VBool@Json@@U?$default_delete@VBool@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0VBool@Json@@U?$default_delete@VBool@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@1@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Bool,std::default_delete<Json::Bool>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3394 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0VBool@Json@@U?$default_delete@VBool@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@1@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Bool,std::default_delete<Json::Bool>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$make_unique@VNull@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@0@XZ
_TEXT	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
??$make_unique@VNull@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@0@XZ PROC ; std::make_unique<Json::Null,0>, COMDAT

; 3629 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN21:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 8
	call	??2@YAPEAX_K@Z				; operator new
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h

; 9    : 		Null() : Value() {};

	lea	rcx, OFFSET FLAT:??_7Null@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T2[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Null.h

; 9    : 		Null() : Value() {};

	mov	QWORD PTR [rax], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rbx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	rax, rbx

; 3631 : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$make_unique@VNull@Json@@$$V$0A@@std@@YA?AV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@0@XZ ENDP ; std::make_unique<Json::Null,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VNull@Json@@U?$default_delete@VNull@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0VNull@Json@@U?$default_delete@VNull@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@1@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Null,std::default_delete<Json::Null>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3394 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0VNull@Json@@U?$default_delete@VNull@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@1@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Null,std::default_delete<Json::Null>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$make_unique@VNumber@Json@@N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@$$QEAN@Z
_TEXT	SEGMENT
$T2 = 40
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
<_Args_0>$ = 72
??$make_unique@VNumber@Json@@N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@$$QEAN@Z PROC ; std::make_unique<Json::Number,double,0>, COMDAT

; 3629 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr

$LN21:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	ecx, 16
	mov	rbx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	vmovsd	xmm0, QWORD PTR [rbx]

; 3631 : }

	mov	rbx, QWORD PTR [rsp+72]
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	lea	rcx, OFFSET FLAT:??_7Number@Json@@6B@
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	QWORD PTR $T2[rsp], rax
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\ValueTypes\Number.h

; 13   : 		Number(double value) : Value(), m_value(value) {};

	vmovsd	QWORD PTR [rax+8], xmm0
	mov	QWORD PTR [rax], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdi], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3630 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	mov	rax, rdi

; 3631 : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@VNumber@Json@@N$0A@@std@@YA?AV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@0@$$QEAN@Z ENDP ; std::make_unique<Json::Number,double,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@1@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Number,std::default_delete<Json::Number>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3394 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@1@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><Json::Number,std::default_delete<Json::Number>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VString@Json@@@std@@@std@@YA$$QEAU?$default_delete@VString@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VString@Json@@@std@@@std@@YA$$QEAU?$default_delete@VString@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::String> >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@U?$default_delete@VString@Json@@@std@@@std@@YA$$QEAU?$default_delete@VString@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::String> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U?$default_delete@VString@Json@@@std@@PEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VString@Json@@@1@$$QEAPEAVString@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VString@Json@@@std@@PEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VString@Json@@@1@$$QEAPEAVString@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::String>,Json::String *>, COMDAT

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VString@Json@@@std@@PEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VString@Json@@@1@$$QEAPEAVString@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::String>,Json::String *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 853  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 854  :         auto& _My_data   = _Mypair._Myval2;
; 855  :         pointer& _Mylast = _My_data._Mylast;
; 856  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 857  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 858  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 859  :             _ASAN_VECTOR_MODIFY(1);
; 860  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx+8]

; 861  :         } else {
; 862  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 863  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 864  :             _ASAN_VECTOR_RELEASE_GUARD;
; 865  :         }
; 866  : 
; 867  :         _Orphan_range(_Mylast, _Mylast);
; 868  :         _Ty& _Result = *_Mylast;

	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [r8], rax
	mov	rax, QWORD PTR [rcx+8]

; 869  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 870  : 
; 871  :         return _Result;
; 872  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back_with_unused_capacity<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 112
_Whereptr$ = 120
<_Val_0>$ = 128
??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 875  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN390:
	mov	r11, rsp
	push	rbx
	push	rbp
	push	rsi
	push	r15
	sub	rsp, 72					; 00000048H

; 876  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 877  :         _Alty& _Al        = _Getal();
; 878  :         auto& _My_data    = _Mypair._Myval2;
; 879  :         pointer& _Myfirst = _My_data._Myfirst;
; 880  :         pointer& _Mylast  = _My_data._Mylast;
; 881  : 
; 882  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 883  : 
; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 885  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbx, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	rbp, rbx
	sub	rbp, rdx
	sub	rax, rdx
	mov	r15, r8
	sar	rbp, 3
	sar	rax, 3

; 886  : 
; 887  :         if (_Oldsize == max_size()) {

	mov	r8, 2305843009213693951			; 1fffffffffffffffH
	mov	rsi, rcx
	cmp	rax, r8
	je	$LN388@Emplace_re

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [r11+32], rdi
	sar	rcx, 3
	mov	QWORD PTR [r11-40], r12

; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [r11-48], r13

; 889  :         }
; 890  : 
; 891  :         const size_type _Newsize = _Oldsize + 1;

	lea	r13, QWORD PTR [rax+1]

; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	mov	rax, r8
	sub	rax, rdx
	mov	QWORD PTR [r11-56], r14
	cmp	rcx, rax
	ja	$LN362@Emplace_re

; 2012 :             return _Max; // geometric growth would overflow
; 2013 :         }
; 2014 : 
; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 117  :         if (_Count > _Max_possible) {

	mov	rcx, r13
	cmp	rax, r13
	cmovae	rcx, rax
	cmp	rcx, r8
	ja	$LN362@Emplace_re

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	lea	r14, QWORD PTR [rcx*8]

; 227  :     if (_Bytes == 0) {

	xor	r9d, r9d
	test	r14, r14
	jne	SHORT $LN23@Emplace_re

; 228  :         return nullptr;

	mov	edi, r9d
	jmp	SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	r14, 4096				; 00001000H
	jb	SHORT $LN25@Emplace_re

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [r14+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rcx, r14
	jbe	$LN362@Emplace_re

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN269@Emplace_re

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN386@Emplace_re
$LN25@Emplace_re:

; 136  :         return ::operator new(_Bytes);

	mov	rcx, r14
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN386@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 895  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	xor	r9d, r9d
$LN22@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r15]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 895  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	lea	r12, QWORD PTR [rdi+rbp*8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r15], r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 895  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	lea	rdx, QWORD PTR [r12+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r12], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 903  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	r8, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	cmp	rbx, r8
	jne	SHORT $LN3@Emplace_re
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1833 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	rdx, rdi

; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, r8
	je	SHORT $LN175@Emplace_re
	npad	9
$LL60@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1845 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 8

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx-8], rax

; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, r8
	jne	SHORT $LL60@Emplace_re
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 909  :         } else { // provide basic guarantee

	jmp	SHORT $LN175@Emplace_re
$LN3@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1833 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	r8, rdi

; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	je	SHORT $LN117@Emplace_re
$LL118@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1845 :         ++_Last;

	lea	r8, QWORD PTR [r8+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rcx, 8

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r8-8], rax

; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rbx
	jne	SHORT $LL118@Emplace_re
$LN117@Emplace_re:

; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);

	mov	rcx, QWORD PTR [rsi+8]

; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rcx
	je	SHORT $LN175@Emplace_re
$LL176@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1845 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx], r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rbx, 8

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx-8], rax

; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rcx
	jne	SHORT $LL176@Emplace_re
$LN175@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2069 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	je	SHORT $LN262@Emplace_re

; 2070 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rsi+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN237@Emplace_re
	npad	7
$LL238@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN256@Emplace_re

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN256@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rbp
	jne	SHORT $LL238@Emplace_re
$LN237@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN270@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN269@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN270@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN262@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2076 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rdi+r13*8]
	mov	QWORD PTR [rsi], rdi
	mov	r13, QWORD PTR [rsp+56]

; 910  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);
; 911  :             _Constructed_first = _Newvec;
; 912  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);
; 913  :         }
; 914  : 
; 915  :         _Guard._New_begin = nullptr;
; 916  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 917  :         return _Newvec + _Whereoff;

	mov	rax, r12
	mov	r12, QWORD PTR [rsp+64]

; 2076 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rsi+8], rcx

; 2077 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+rdi]
	mov	rdi, QWORD PTR [rsp+136]
	mov	r14, QWORD PTR [rsp+48]
	mov	QWORD PTR [rsi+16], rcx

; 918  :     }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN269@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN388@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 888  :             _Xlength();

	call	?_Xlength@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Xlength
	int	3
$LN362@Emplace_re:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN385@Emplace_re:
??$_Emplace_reallocate@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@QEAV21@$$QEAV21@@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_reallocate<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
_TEXT	SEGMENT
$T3 = 32
$T20 = 32
$T30 = 32
$T33 = 32
$T31 = 56
$T32 = 88
input$ = 144
i$ = 152
??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z PROC ; Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 166  : 		static inline size_t skipCommentSIMD16(const Container& input, size_t i) {

$LN144:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rbx, rdx
	mov	rdi, rcx

; 167  : 
; 168  : 			//static const __m256i ws_slash = _mm256_set1_epi8('/');
; 169  : 			static const __m128i ws_star = _mm_set1_epi8('*');

	mov	esi, OFFSET FLAT:_Init_thread_epoch
	mov	rax, QWORD PTR gs:88
	add	rsi, QWORD PTR [rax]
	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR ?$TSS0@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, eax ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
	jle	SHORT $LN2@skipCommen
	lea	rcx, OFFSET FLAT:?$TSS0@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS0@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, -1 ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
	jne	SHORT $LN2@skipCommen
	vmovdqu	xmm0, XMMWORD PTR __xmm@2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a
	vmovdqu	XMMWORD PTR ?ws_star@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_star
	lea	rcx, OFFSET FLAT:?$TSS0@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS0
	call	_Init_thread_footer
$LN2@skipCommen:

; 170  : 			static const __m128i ws_lf = _mm_set1_epi8('\n');

	mov	eax, DWORD PTR [rsi]
	cmp	DWORD PTR ?$TSS1@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, eax ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
	jle	SHORT $LN3@skipCommen
	lea	rcx, OFFSET FLAT:?$TSS1@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
	call	_Init_thread_header
	cmp	DWORD PTR ?$TSS1@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA, -1 ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
	jne	SHORT $LN3@skipCommen
	vmovdqu	xmm0, XMMWORD PTR __xmm@0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a
	vmovdqu	XMMWORD PTR ?ws_lf@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B, xmm0 ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_lf
	lea	rcx, OFFSET FLAT:?$TSS1@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::$TSS1
	call	_Init_thread_footer
$LN3@skipCommen:

; 171  : 			__m128i chunk;
; 172  : 			uint16_t mask;
; 173  : 
; 174  : 			i += 2;

	add	rbx, 2

; 175  : 			if (i >= input.size())

	mov	rdx, QWORD PTR [rdi+16]
	cmp	rbx, rdx
	jae	$LN142@skipCommen
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 453  :         return _Myres > _Small_string_capacity;

	lea	r9, QWORD PTR [rdi+24]
	mov	r8, QWORD PTR [r9]

; 445  :         if (_Large_mode_engaged()) {

	cmp	r8, 15
	jbe	SHORT $LN133@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
	lea	r10, QWORD PTR [rdi+24]
	jmp	SHORT $LN123@skipCommen
$LN133@skipCommen:
	mov	r10, r9
$LN123@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 177  : 			char c = input[i - 1];

	movzx	eax, BYTE PTR [rax+rbx-1]

; 178  : 			if (c == '/')

	cmp	al, 47					; 0000002fH
	jne	$LN15@skipCommen

; 179  : 			{
; 180  : 				while (i + 16 <= input.size()) {

	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rdx
	ja	SHORT $LN5@skipCommen
	vmovdqu	xmm2, XMMWORD PTR ?ws_lf@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_lf
	npad	6
$LL4@skipCommen:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	r8, 15
	jbe	SHORT $LN134@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi]
$LN134@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 182  : 					mask = _mm_movemask_epi8(_mm_cmpeq_epi8(chunk, ws_lf));

	vpcmpeqb xmm1, xmm2, XMMWORD PTR [rcx+rbx]
	vpmovmskb ecx, xmm1

; 183  : 					if (mask != 0)

	test	cx, cx
	jne	SHORT $LN102@skipCommen

; 185  : 					i += 16;

	add	rbx, 16
	add	rax, 16

; 179  : 			{
; 180  : 				while (i + 16 <= input.size()) {

	cmp	rax, rdx
	jbe	SHORT $LL4@skipCommen

; 208  : 					if (input[i] == '*' && ++i < input.size() && input[i] == '/') {

	lea	r9, QWORD PTR [rdi+24]
$LN5@skipCommen:

; 187  : 				for (; i < input.size() && input[i] != '\n'; ++i);

	mov	rcx, rdx
	cmp	rbx, rdx
	jae	SHORT $LN7@skipCommen
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [r9]
$LL8@skipCommen:

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN51@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN51@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 187  : 				for (; i < input.size() && input[i] != '\n'; ++i);

	cmp	BYTE PTR [rax+rbx], 10
	je	SHORT $LN7@skipCommen
	inc	rbx
	cmp	rbx, rcx
	jb	SHORT $LL8@skipCommen
$LN7@skipCommen:

; 215  : 		};

	mov	rax, rbx
$LN1@skipCommen:
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN102@skipCommen:

; 184  : 						return i + CTZ16(mask);

	tzcnt	ax, cx
	movzx	eax, ax
	add	rax, rbx
	jmp	SHORT $LN1@skipCommen
$LN15@skipCommen:

; 188  : 				return i;
; 189  : 			}
; 190  : 			else if (c == '*')

	cmp	al, 42					; 0000002aH
	jne	$LN18@skipCommen

; 191  : 			{
; 192  : 				while (i + 16 <= input.size()) {

	mov	rcx, rdx
	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rdx
	ja	SHORT $LN127@skipCommen
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	vmovdqu	xmm2, XMMWORD PTR ?ws_star@?1???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4T__m128i@@B ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`2'::ws_star
$LL9@skipCommen:

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	r8, 15
	jbe	SHORT $LN136@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN136@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 194  : 					mask = _mm_movemask_epi8(_mm_cmpeq_epi8(chunk, ws_star));

	vpcmpeqb xmm1, xmm2, XMMWORD PTR [rax+rbx]
	vpmovmskb eax, xmm1

; 195  : 					if (mask != 0) {

	test	ax, ax
	je	SHORT $LN19@skipCommen

; 196  : 						size_t j = i + CTZ16(mask) + 1;

	tzcnt	ax, ax
	movzx	eax, ax
	inc	rax
	add	rax, rbx

; 197  : 						if (j >= input.size())

	cmp	rax, rdx
	jae	SHORT $LN103@skipCommen
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	r8, 15
	jbe	SHORT $LN135@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi]
$LN135@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 199  : 						else if (input[j] == '/')

	cmp	BYTE PTR [rcx+rax], 47			; 0000002fH
	je	SHORT $LN1@skipCommen

; 200  : 							return j;
; 201  : 						i = j + 1;

	lea	rbx, QWORD PTR [rax+1]

; 202  : 						continue;

	jmp	SHORT $LN108@skipCommen
$LN19@skipCommen:

; 203  : 					}
; 204  : 					i += 16;

	add	rbx, 16
$LN108@skipCommen:

; 191  : 			{
; 192  : 				while (i + 16 <= input.size()) {

	mov	rcx, rdx
	lea	rax, QWORD PTR [rbx+16]
	cmp	rax, rdx
	jbe	SHORT $LL9@skipCommen
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	lea	r10, QWORD PTR [rdi+24]
$LN127@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 206  : 				for (; i < input.size(); ++i)

	cmp	rbx, rcx
	jae	SHORT $LN114@skipCommen
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [r10]
$LL13@skipCommen:

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN138@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN138@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 208  : 					if (input[i] == '*' && ++i < input.size() && input[i] == '/') {

	cmp	BYTE PTR [rax+rbx], 42			; 0000002aH
	jne	SHORT $LN11@skipCommen
	inc	rbx
	cmp	rbx, rcx
	jae	SHORT $LN11@skipCommen
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 445  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN91@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN91@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 208  : 					if (input[i] == '*' && ++i < input.size() && input[i] == '/') {

	cmp	BYTE PTR [rax+rbx], 47			; 0000002fH
	je	$LN7@skipCommen
$LN11@skipCommen:

; 206  : 				for (; i < input.size(); ++i)

	inc	rbx
	cmp	rbx, rcx
	jae	SHORT $LN114@skipCommen
	jmp	SHORT $LL13@skipCommen
$LN103@skipCommen:

; 198  : 							throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T20[rsp]
	call	_CxxThrowException
	int	3
$LN114@skipCommen:

; 209  : 						return i;
; 210  : 					}
; 211  : 				}
; 212  : 				throw std::runtime_error("Endless block comment");

	lea	rdx, OFFSET FLAT:??_C@_0BG@PEGDFFCL@Endless?5block?5comment@
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T30[rsp]
	call	_CxxThrowException
	int	3
$LN18@skipCommen:

; 213  : 			}
; 214  : 			throw std::runtime_error(std::string("Invalid comment syntax") + input[i]);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movzx	ebx, BYTE PTR [rax]
	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T31[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	movzx	r8d, bl
	mov	rdx, rax
	lea	rcx, QWORD PTR $T32[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T33[rsp]
	call	_CxxThrowException
	npad	1
$LN142@skipCommen:

; 176  : 				throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
	int	3
$LN140@skipCommen:
??$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ENDP ; Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T20 = 32
$T30 = 32
$T33 = 32
$T31 = 56
$T32 = 88
input$ = 144
i$ = 152
?dtor$0@?0???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
	lea	rcx, QWORD PTR $T31[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T20 = 32
$T30 = 32
$T33 = 32
$T31 = 56
$T32 = 88
input$ = 144
i$ = 152
?dtor$1@?0???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T32[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$skipCommentSIMD16@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Parser::skipCommentSIMD16<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$skipCommentScalar@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
_TEXT	SEGMENT
$T1 = 32
$T14 = 32
$T15 = 32
input$ = 80
i$ = 88
??$skipCommentScalar@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z PROC ; Json::Parser::skipCommentScalar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 219  : 		static inline size_t skipCommentScalar(const Container& input, size_t i) {

$LN76:
	sub	rsp, 72					; 00000048H

; 220  : 			++i;
; 221  : 			if (i >= input.size()) throw std::runtime_error("Invalid comment syntax");

	mov	r8, QWORD PTR [rcx+16]
	inc	rdx
	cmp	rdx, r8
	jae	$LN74@skipCommen
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	r9, QWORD PTR [rcx+24]

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN69@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN69@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 222  : 			char c = input[i];

	movzx	r10d, BYTE PTR [rax+rdx]

; 223  : 			++i;

	inc	rdx

; 224  : 			if (c == lineComment) {

	cmp	r10b, 47				; 0000002fH
	jne	SHORT $LN9@skipCommen

; 225  : 				for (; i < input.size() && input[i] != '\n'; ++i); // skip to end of line

	cmp	rdx, r8
	jae	SHORT $LN3@skipCommen
$LL4@skipCommen:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN28@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN28@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 225  : 				for (; i < input.size() && input[i] != '\n'; ++i); // skip to end of line

	cmp	BYTE PTR [rax+rdx], 10
	je	SHORT $LN3@skipCommen
	inc	rdx
	cmp	rdx, r8
	jb	SHORT $LL4@skipCommen
$LN3@skipCommen:

; 238  : 		}

	mov	rax, rdx
	add	rsp, 72					; 00000048H
	ret	0
$LN9@skipCommen:

; 226  : 				return i;
; 227  : 			}
; 228  : 			else if (c == blockCommentStart) {

	cmp	r10b, 42				; 0000002aH
	jne	$LN11@skipCommen

; 229  : 				for (; i < input.size(); ++i)

	cmp	rdx, r8
	jae	SHORT $LN60@skipCommen
	npad	8
$LL7@skipCommen:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN70@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN70@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 231  : 					if (input[i] == blockCommentEnd && ++i < input.size() && input[i] == commentStart) {

	cmp	BYTE PTR [rax+rdx], 42			; 0000002aH
	jne	SHORT $LN5@skipCommen
	inc	rdx
	cmp	rdx, r8
	jae	SHORT $LN5@skipCommen
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN48@skipCommen

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN48@skipCommen:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 231  : 					if (input[i] == blockCommentEnd && ++i < input.size() && input[i] == commentStart) {

	cmp	BYTE PTR [rax+rdx], 47			; 0000002fH
	je	SHORT $LN3@skipCommen
$LN5@skipCommen:

; 229  : 				for (; i < input.size(); ++i)

	inc	rdx
	cmp	rdx, r8
	jae	SHORT $LN60@skipCommen
	jmp	SHORT $LL7@skipCommen
$LN74@skipCommen:

; 220  : 			++i;
; 221  : 			if (i >= input.size()) throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN60@skipCommen:

; 232  : 						return i;
; 233  : 					}
; 234  : 				}
; 235  : 				throw std::runtime_error("Endless block comment");

	lea	rdx, OFFSET FLAT:??_C@_0BG@PEGDFFCL@Endless?5block?5comment@
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T14[rsp]
	call	_CxxThrowException
	int	3
$LN11@skipCommen:

; 236  : 			}
; 237  : 			throw std::runtime_error("Invalid comment syntax");

	lea	rdx, OFFSET FLAT:??_C@_0BH@NMENEEPL@Invalid?5comment?5syntax@
	lea	rcx, QWORD PTR $T15[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T15[rsp]
	call	_CxxThrowException
	int	3
$LN72@skipCommen:
??$skipCommentScalar@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ENDP ; Json::Parser::skipCommentScalar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z
_TEXT	SEGMENT
$T1 = 48
$T37 = 48
$T81 = 48
$T79 = 72
$T80 = 104
_Eptr$82 = 136
hex$83 = 144
__$ArrayPad$ = 176
input$ = 224
i$ = 232
string$ = 240
??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z PROC ; Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 62   : 		{

$LN320:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	r8, rcx

; 63   : 			if (i >= input.size()) throw std::runtime_error("Unterminated escape sequence");

	mov	r9, QWORD PTR [rdx]
	cmp	r9, QWORD PTR [rcx+16]
	jae	$LN317@handleEsca
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
	jbe	SHORT $LN304@handleEsca

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rcx]
$LN304@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 64   : 			char escaped = input[i];

	movsx	ebx, BYTE PTR [r9+rax]

; 65   : 			switch (escaped) {

	mov	eax, ebx
	add	eax, -34				; ffffffdeH
	cmp	eax, 83					; 00000053H
	ja	$LN19@handleEsca
	cdqe
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN308@handleEsca[r10+rax]
	mov	ecx, DWORD PTR $LN309@handleEsca[r10+rax*4]
	add	rcx, r10
	jmp	rcx
$LN5@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN35@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN38@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN38@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 34			; 00000022H

; 2299 :             return;

	jmp	SHORT $LN2@handleEsca
$LN35@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 34					; 00000022H
$LN315@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 107  : 		}

	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN2@handleEsca:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+248]
	add	rsp, 192				; 000000c0H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN6@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN45@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN48@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN48@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 92			; 0000005cH

; 2299 :             return;

	jmp	SHORT $LN2@handleEsca
$LN45@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 92					; 0000005cH
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 67   : 			case '\\': string.push_back('\\'); break;

	jmp	SHORT $LN315@handleEsca
$LN7@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN55@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN58@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN58@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 47			; 0000002fH

; 2299 :             return;

	jmp	SHORT $LN2@handleEsca
$LN55@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 47					; 0000002fH
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 68   : 			case '/':  string.push_back('/'); break;

	jmp	$LN315@handleEsca
$LN8@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN65@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN68@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN68@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 8

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN65@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 8
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 69   : 			case 'b':  string.push_back('\b'); break;

	jmp	$LN315@handleEsca
$LN9@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN75@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN78@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN78@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 12

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN75@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 12
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 70   : 			case 'f':  string.push_back('\f'); break;

	jmp	$LN315@handleEsca
$LN10@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN85@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN88@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN88@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 10

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN85@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 10
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 71   : 			case 'n':  string.push_back('\n'); break;

	jmp	$LN315@handleEsca
$LN11@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN95@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN98@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN98@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 13

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN95@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 13
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 72   : 			case 'r':  string.push_back('\r'); break;

	jmp	$LN315@handleEsca
$LN12@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN105@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN108@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN108@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	WORD PTR [rdi+rcx], 9

; 2299 :             return;

	jmp	$LN2@handleEsca
$LN105@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	r9b, 9
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 73   : 			case 't':  string.push_back('\t'); break;

	jmp	$LN315@handleEsca
$LN13@handleEsca:

; 74   : 			case 'u': {
; 75   : 				// Unicode escape \uXXXX
; 76   : 				i += 4;

	lea	rax, QWORD PTR [r9+4]
	mov	QWORD PTR [rdx], rax

; 77   : 				if (i >= input.size())

	cmp	rax, QWORD PTR [r8+16]
	jae	$LN318@handleEsca
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR hex$83[rsp], xmm0

; 861  :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR hex$83[rsp+24], 15

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR hex$83[rsp], 0

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [r8+24], 15
	jbe	SHORT $LN138@handleEsca

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [r8]
$LN138@handleEsca:

; 1515 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR hex$83[rsp+16], 4
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR [r9+r8+1]
	mov	DWORD PTR hex$83[rsp], eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1518 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR hex$83[rsp+4], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 133  :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

	call	QWORD PTR __imp__errno
	mov	r14, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR hex$83[rsp]

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR hex$83[rsp+24], 15
	cmova	rbx, QWORD PTR hex$83[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\string

; 136  :     _Errno_ref               = 0;

	mov	DWORD PTR [rax], 0

; 137  :     const unsigned long _Ans = _CSTD strtoul(_Ptr, &_Eptr, _Base);

	mov	r8d, 16
	lea	rdx, QWORD PTR _Eptr$82[rsp]
	mov	rcx, rbx
	call	QWORD PTR __imp_strtoul
	mov	esi, eax

; 138  : 
; 139  :     if (_Ptr == _Eptr) {

	cmp	rbx, QWORD PTR _Eptr$82[rsp]
	jne	SHORT $LN171@handleEsca

; 140  :         _Xinvalid_argument("invalid stoul argument");

	lea	rcx, OFFSET FLAT:??_C@_0BH@DPNNDOEK@invalid?5stoul?5argument@
	call	QWORD PTR __imp_?_Xinvalid_argument@std@@YAXPEBD@Z
	int	3
$LN171@handleEsca:

; 141  :     }
; 142  : 
; 143  :     if (_Errno_ref == ERANGE) {

	cmp	DWORD PTR [r14], 34			; 00000022H
	jne	SHORT $LN172@handleEsca

; 144  :         _Xout_of_range("stoul argument out of range");

	lea	rcx, OFFSET FLAT:??_C@_0BM@MOLGGFGJ@stoul?5argument?5out?5of?5range@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN172@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 84   : 				unsigned int codepoint = std::stoul(hex, nullptr, 16);

	mov	rcx, QWORD PTR [rdi+16]
	mov	rdx, QWORD PTR [rdi+24]

; 85   : 				if (codepoint <= 0x7F) {

	cmp	esi, 127				; 0000007fH
	jbe	$LN314@handleEsca

; 86   : 					string.push_back(static_cast<char>(codepoint));
; 87   : 				}
; 88   : 				else {
; 89   : 					// Convert Unicode codepoint to UTF-8
; 90   : 					if (codepoint <= 0x7FF) {

	mov	r9d, esi
	cmp	esi, 2047				; 000007ffH
	ja	SHORT $LN17@handleEsca

; 91   : 						// 2-byte UTF-8
; 92   : 						string.push_back(static_cast<char>(0xC0 | (codepoint >> 6)));

	shr	r9d, 6
	or	r9b, -64				; ffffffffffffffc0H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	cmp	rcx, rdx
	jae	$LN259@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN307@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 2299 :             return;

	jmp	SHORT $LN258@handleEsca
$LN17@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 97   : 						string.push_back(static_cast<char>(0xE0 | (codepoint >> 12)));

	shr	r9d, 12
	or	r9b, -32				; ffffffffffffffe0H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	cmp	rcx, rdx
	jae	SHORT $LN249@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN306@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN306@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 2299 :             return;

	jmp	SHORT $LN248@handleEsca
$LN249@handleEsca:

; 2300 :         }
; 2301 : 
; 2302 :         _Reallocate_grow_by(

	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN248@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 98   : 						string.push_back(static_cast<char>(0x80 | ((codepoint >> 6) & 0x3F)));

	mov	r9d, esi
	shr	r9d, 6
	and	r9b, 63					; 0000003fH
	or	r9b, -128				; ffffffffffffff80H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2292 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 2293 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rdx, QWORD PTR [rdi+24]
	cmp	rcx, rdx
	jae	SHORT $LN259@handleEsca

; 2294 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2295 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 436  :         if (_Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN307@handleEsca

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN307@handleEsca:

; 2297 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rcx], r9b

; 2298 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rcx+1], 0

; 2299 :             return;

	jmp	SHORT $LN258@handleEsca
$LN259@handleEsca:
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 102  : 				break;

	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN258@handleEsca:
	and	sil, 63					; 0000003fH
	mov	rdx, QWORD PTR [rdi+24]
	mov	rcx, QWORD PTR [rdi+16]
	or	sil, -128				; ffffffffffffff80H
$LN314@handleEsca:
	cmp	rcx, rdx
	jae	SHORT $LN269@handleEsca
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	cmp	rdx, 15
	jbe	SHORT $LN272@handleEsca
	mov	rdi, QWORD PTR [rdi]
$LN272@handleEsca:
	mov	BYTE PTR [rdi+rcx+1], 0
	mov	BYTE PTR [rdi+rcx], sil
	jmp	SHORT $LN268@handleEsca
$LN269@handleEsca:
	movzx	r9d, sil
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
	npad	1
$LN268@handleEsca:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3083 :         if (_My_data._Large_mode_engaged()) {

	mov	rdx, QWORD PTR hex$83[rsp+24]
	cmp	rdx, 15
	jbe	$LN2@handleEsca

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR hex$83[rsp]
	mov	rax, rcx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN212@handleEsca

; 202  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 203  : 
; 204  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rax, rcx
	sub	rax, 8
	cmp	rax, 31
	jbe	SHORT $LN212@handleEsca
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN212@handleEsca:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h

; 102  : 				break;

	jmp	$LN2@handleEsca
$LN318@handleEsca:

; 78   : 					throw std::runtime_error("Invalid unicode escape");

	lea	rdx, OFFSET FLAT:??_C@_0BH@JICOIFBC@Invalid?5unicode?5escape@
	lea	rcx, QWORD PTR $T37[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T37[rsp]
	call	_CxxThrowException
	int	3
$LN19@handleEsca:

; 103  : 			}
; 104  : 			default:
; 105  : 				throw std::runtime_error(std::string("Invalid escape sequence: \\") + escaped);

	lea	rdx, OFFSET FLAT:??_C@_0BL@KLIDEEPE@Invalid?5escape?5sequence?3?5?2@
	lea	rcx, QWORD PTR $T79[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	movzx	r8d, bl
	mov	rdx, rax
	lea	rcx, QWORD PTR $T80[rsp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T81[rsp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T81[rsp]
	call	_CxxThrowException
	npad	1
$LN317@handleEsca:

; 63   : 			if (i >= input.size()) throw std::runtime_error("Unterminated escape sequence");

	lea	rdx, OFFSET FLAT:??_C@_0BN@LPMKJIHG@Unterminated?5escape?5sequence@
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN310@handleEsca:
	npad	3
$LN309@handleEsca:

; 107  : 		}

	DD	$LN5@handleEsca
	DD	$LN7@handleEsca
	DD	$LN6@handleEsca
	DD	$LN8@handleEsca
	DD	$LN9@handleEsca
	DD	$LN10@handleEsca
	DD	$LN11@handleEsca
	DD	$LN12@handleEsca
	DD	$LN13@handleEsca
	DD	$LN19@handleEsca
$LN308@handleEsca:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	7
	DB	8
??$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z ENDP ; Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T37 = 48
$T81 = 48
$T79 = 72
$T80 = 104
_Eptr$82 = 136
hex$83 = 144
__$ArrayPad$ = 176
input$ = 224
i$ = 232
string$ = 240
?dtor$0@?0???$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z@4HA PROC ; `Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
	lea	rcx, QWORD PTR hex$83[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z@4HA ENDP ; `Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T37 = 48
$T81 = 48
$T79 = 72
$T80 = 104
_Eptr$82 = 136
hex$83 = 144
__$ArrayPad$ = 176
input$ = 224
i$ = 232
string$ = 240
?dtor$1@?0???$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z@4HA PROC ; `Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T79[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z@4HA ENDP ; `Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T37 = 48
$T81 = 48
$T79 = 72
$T80 = 104
_Eptr$82 = 136
hex$83 = 144
__$ArrayPad$ = 176
input$ = 224
i$ = 232
string$ = 240
?dtor$2@?0???$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z@4HA PROC ; `Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T80[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???$handleEscapedChar@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Parser@Json@@CAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEA_KAEAV23@@Z@4HA ENDP ; `Json::Parser::handleEscapedChar<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN41:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	add	rdx, 16
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 319  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *>, COMDAT

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@YAAEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@M@std@@YA$$QEAMAEAM@Z PROC			; std::forward<float>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@M@std@@YA$$QEAMAEAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Unfancy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@PEAV10@@Z PROC ; std::_Unfancy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 69   :     return _Ptr;

	mov	rax, rcx

; 70   : }

	ret	0
??$_Unfancy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$destroy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$destroy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::destroy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rdx]
	test	rcx, rcx
	je	SHORT $LN16@destroy

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN16@destroy:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 743  :     }

	ret	0
??$destroy@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::destroy<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAPEAV10@@Z PROC ; std::forward<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAPEAV10@@Z ENDP ; std::forward<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z PROC ; std::construct_at<char *,char * &>, COMDAT

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 464  : }

	ret	0
??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z ENDP ; std::construct_at<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > * const &>, COMDAT

; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);
; 1387 :     }
; 1388 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >, COMDAT

; 1620 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	cmp	rcx, rdx

; 2040 :     // copy _Val throughout raw [_First, _Last)
; 2041 :     _STD _Adl_verify_range(_First, _Last);
; 2042 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 2043 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 2044 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2045 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2046 :     } else {
; 2047 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2048 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2049 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2050 :                 return;
; 2051 :             }
; 2052 :         }
; 2053 : 
; 2054 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 2055 :         while (_Backout._Last != _ULast) {

	je	SHORT $LN3@uninitiali
	npad	11
$LL2@uninitiali:

; 1634 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax

; 1635 :         ++_Last;

	add	rcx, 8

; 2040 :     // copy _Val throughout raw [_First, _Last)
; 2041 :     _STD _Adl_verify_range(_First, _Last);
; 2042 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 2043 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 2044 :     if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2045 :         _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 2046 :     } else {
; 2047 :         if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
; 2048 :             if (_STD _Is_all_bits_zero(_Val)) {
; 2049 :                 _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 2050 :                 return;
; 2051 :             }
; 2052 :         }
; 2053 : 
; 2054 :         _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
; 2055 :         while (_Backout._Last != _ULast) {

	cmp	rcx, rdx
	jne	SHORT $LL2@uninitiali
$LN3@uninitiali:

; 2056 :             _Backout._Emplace_back(_Val);
; 2057 :         }
; 2058 : 
; 2059 :         _Backout._Release();
; 2060 :     }
; 2061 : }

	ret	0
??$uninitialized_fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::uninitialized_fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Val$ = 32
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >, COMDAT

; 5286 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN22:
	sub	rsp, 8
	mov	r10, rdx
	xor	eax, eax
	sub	rdx, rcx
	mov	r9, rcx
	add	rdx, 7
	shr	rdx, 3
	cmp	rcx, r10
	cmova	rdx, rax

; 5287 :     // copy _Val through [_First, _Last)
; 5288 :     _STD _Adl_verify_range(_First, _Last);
; 5289 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5290 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5291 :     } else {
; 5292 :         auto _UFirst      = _STD _Get_unwrapped(_First);
; 5293 :         const auto _ULast = _STD _Get_unwrapped(_Last);
; 5294 : #if _HAS_CXX20
; 5295 :         if (!_STD is_constant_evaluated())
; 5296 : #endif // _HAS_CXX20
; 5297 :         {
; 5298 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5299 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5300 :                 return;
; 5301 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5302 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5303 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5304 :                     return;
; 5305 :                 }
; 5306 :             }
; 5307 :         }
; 5308 : 
; 5309 :         for (; _UFirst != _ULast; ++_UFirst) {

	test	rdx, rdx
	je	SHORT $LN11@fill
	cmp	rdx, 4
	jb	SHORT $LN11@fill

; 5310 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	add	rcx, -8
	lea	rcx, QWORD PTR [rcx+rdx*8]
	cmp	r9, r8
	ja	SHORT $LN12@fill

; 5286 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

	cmp	rcx, r8
	jae	SHORT $LN11@fill
$LN12@fill:
	mov	QWORD PTR [rsp], rdi
	and	rdx, -4
	mov	rdi, r9
	lea	rdx, QWORD PTR [rdx*8]
	mov	rcx, rdx
	shr	rcx, 3
	rep stosq
	add	r9, rdx
	mov	rdi, QWORD PTR [rsp]
$LN11@fill:

; 5287 :     // copy _Val through [_First, _Last)
; 5288 :     _STD _Adl_verify_range(_First, _Last);
; 5289 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5290 :         _STD _Fill_vbool(_First, _Last, _Val);
; 5291 :     } else {
; 5292 :         auto _UFirst      = _STD _Get_unwrapped(_First);
; 5293 :         const auto _ULast = _STD _Get_unwrapped(_Last);
; 5294 : #if _HAS_CXX20
; 5295 :         if (!_STD is_constant_evaluated())
; 5296 : #endif // _HAS_CXX20
; 5297 :         {
; 5298 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5299 :                 _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5300 :                 return;
; 5301 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5302 :                 if (_STD _Is_all_bits_zero(_Val)) {
; 5303 :                     _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5304 :                     return;
; 5305 :                 }
; 5306 :             }
; 5307 :         }
; 5308 : 
; 5309 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r9, r10
	je	SHORT $LN3@fill
	npad	9
$LL10@fill:

; 5310 :             *_UFirst = _Val;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [r9], rax
	add	r9, 8
	cmp	r9, r10
	jne	SHORT $LL10@fill
$LN3@fill:

; 5311 :         }
; 5312 :     }
; 5313 : }

	add	rsp, 8
	ret	0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1>::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1><std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 321  :     if constexpr (is_array_v<_Ty>) {
; 322  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 323  :     } else {
; 324  :         _Obj.~_Ty();
; 325  :     }
; 326  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	rax, rcx

; 123  : }

	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 64
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 225  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN20:
	sub	rsp, 56					; 00000038H

; 226  :     // allocate _Bytes
; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN2@Allocate

; 228  :         return nullptr;

	xor	eax, eax

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);
; 257  :     }
; 258  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@Allocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN19@Allocate

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN10@Allocate
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	xor	edx, edx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN10@Allocate:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 254  :         }
; 255  : #endif // defined(_M_IX86) || defined(_M_X64)
; 256  :         return _Traits::_Allocate(_Bytes);
; 257  :     }
; 258  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN4@Allocate:
	add	rsp, 56					; 00000038H

; 136  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN19@Allocate:

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN17@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::~unique_ptr<Json::Number,std::default_delete<Json::Number> >, COMDAT

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

	ret	0
??1?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::~unique_ptr<Json::Number,std::default_delete<Json::Number> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::~unique_ptr<Json::Null,std::default_delete<Json::Null> >, COMDAT

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

	ret	0
??1?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::~unique_ptr<Json::Null,std::default_delete<Json::Null> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::~unique_ptr<Json::Bool,std::default_delete<Json::Bool> >, COMDAT

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

	ret	0
??1?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::~unique_ptr<Json::Bool,std::default_delete<Json::Bool> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?release@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAPEAVString@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAPEAVString@Json@@XZ PROC ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::release, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3466 :     }

	ret	0
?release@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAPEAVString@Json@@XZ ENDP ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ PROC ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::get_deleter, COMDAT

; 3441 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3442 :     }

	ret	0
?get_deleter@?$unique_ptr@VString@Json@@U?$default_delete@VString@Json@@@std@@@std@@QEAAAEAU?$default_delete@VString@Json@@@2@XZ ENDP ; std::unique_ptr<Json::String,std::default_delete<Json::String> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??R?$default_delete@VString@Json@@@std@@QEBAXPEAVString@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VString@Json@@@std@@QEBAXPEAVString@Json@@@Z PROC ; std::default_delete<Json::String>::operator(), COMDAT

; 3307 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3308 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3309 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3310 :     }

	ret	0
??R?$default_delete@VString@Json@@@std@@QEBAXPEAVString@Json@@@Z ENDP ; std::default_delete<Json::String>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??C?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEBAPEAVObject@Json@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEBAPEAVObject@Json@@XZ PROC ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::operator->, COMDAT

; 3453 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3454 :     }

	ret	0
??C?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEBAPEAVObject@Json@@XZ ENDP ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::~unique_ptr<Json::Object,std::default_delete<Json::Object> >, COMDAT

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

	ret	0
??1?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::~unique_ptr<Json::Object,std::default_delete<Json::Object> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??C?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEBAPEAVArray@Json@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEBAPEAVArray@Json@@XZ PROC ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::operator->, COMDAT

; 3453 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3454 :     }

	ret	0
??C?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEBAPEAVArray@Json@@XZ ENDP ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??1?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::~unique_ptr<Json::Array,std::default_delete<Json::Array> >, COMDAT

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@unique_ptr

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN7@unique_ptr:

; 3427 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3428 :         }
; 3429 : 
; 3430 : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3431 :         if constexpr (is_pointer_v<pointer>) {
; 3432 :             if (!_STD _Is_constant_evaluated()) {
; 3433 :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 3434 :                 _Mypair._Myval2 = _Tombstone;
; 3435 :             }
; 3436 :         }
; 3437 : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 3438 :     }

	ret	0
??1?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::~unique_ptr<Json::Array,std::default_delete<Json::Array> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\array
;	COMDAT ??A?$array@E$03@std@@QEBAAEBE_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Pos$ = 16
??A?$array@E$03@std@@QEBAAEBE_K@Z PROC			; std::array<unsigned char,4>::operator[], COMDAT

; 539  : #if _MSVC_STL_HARDENING_ARRAY || _ITERATOR_DEBUG_LEVEL != 0
; 540  :         _STL_VERIFY(_Pos < _Size, "array subscript out of range");
; 541  : #endif
; 542  : 
; 543  :         return _Elems[_Pos];

	lea	rax, OFFSET FLAT:?whitespaceCharacters@Parser@Json@@2V?$array@E$03@std@@B ; Json::Parser::whitespaceCharacters
	add	rax, rdx

; 544  :     }

	ret	0
??A?$array@E$03@std@@QEBAAEBE_K@Z ENDP			; std::array<unsigned char,4>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::size, COMDAT

; 268  :         return static_cast<size_type>(_Mypair._Myval2._Mylast - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 269  :     }

	ret	0
?size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 64
_Count$ = 72
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >::allocate, COMDAT

; 988  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN27:
	sub	rsp, 56					; 00000038H

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN23@allocate

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN8@allocate

; 228  :         return nullptr;

	xor	eax, eax

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN8@allocate:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN10@allocate

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN23@allocate

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN16@allocate
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN16@allocate:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN10@allocate:
	add	rsp, 56					; 00000038H

; 136  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN23@allocate:

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN25@allocate:
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx

; 38   :         this->_Adopt(_Plist);
; 39   :     }

	mov	rax, rcx
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::operator==, COMDAT

; 193  : #if _ITERATOR_DEBUG_LEVEL == 2
; 194  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 196  : 
; 197  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 198  :     }

	ret	0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::deallocate, COMDAT

; 714  :     /* strengthened */ {

	mov	rcx, rdx

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Alloc_sentinel_and_proxy, COMDAT

; 1847 :     void _Alloc_sentinel_and_proxy() {

$LN24:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1848 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1849 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 1850 :         auto& _Al     = _Getal();
; 1851 :         auto _Newhead = _Al.allocate(1);
; 1852 :         _Construct_in_place(_Newhead->_Next, _Newhead);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rax], rax

; 1853 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

	mov	QWORD PTR [rax+8], rax

; 1854 :         _Mypair._Myval2._Myhead = _Newhead;

	mov	QWORD PTR [rbx], rax

; 1855 :         _Proxy._Release();
; 1856 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Alloc_sentinel_and_proxy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?find@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T11 = 32
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
?find@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::find, COMDAT

; 1231 :     _NODISCARD iterator find(const key_type& _Keyval) {

$LN59:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [r8+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1231 :     _NODISCARD iterator find(const key_type& _Keyval) {

	mov	rbx, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3390 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r11, QWORD PTR [r8+16]

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rdx, r8
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1231 :     _NODISCARD iterator find(const key_type& _Keyval) {

	mov	rdi, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN16@find

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [r8]
$LN16@find:
	xor	r10d, r10d
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2292 :     return _Fnv1a_append_bytes(

	mov	r9, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r11, r11
	je	SHORT $LN27@find
	mov	rcx, 1099511628211			; 00000100000001b3H
	npad	3
$LL49@find:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+r10]
	inc	r10
	xor	r9, rax

; 2261 :         _Val *= _FNV_prime;

	imul	r9, rcx
	cmp	r10, r11
	jb	SHORT $LL49@find
$LN27@find:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1221 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	lea	rdx, QWORD PTR $T11[rsp]
	mov	rcx, rdi
	call	??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rcx, QWORD PTR [rax+8]

; 1222 :             if (_Target) {

	test	rcx, rcx
	je	SHORT $LN32@find
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rbx], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1233 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN32@find:

; 1226 :             return _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR [rdi+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rbx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1233 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?find@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::end, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 800  :         return _List.end();

	mov	rax, rdx

; 801  :     }

	ret	0
?end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAMXZ PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size, COMDAT

; 154  :         return _Mypair._Myval2._Myval2;

	mov	rax, rcx

; 155  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAAAEAMXZ ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@00@Z PROC ; std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@00@Z ENDP ; std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
_Size$ = 24
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT

; 486  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 487  :         return (_STD min)(_Size, _Mysize - _Off);

	cmp	QWORD PTR [rcx+16], r8
	cmovb	r8, QWORD PTR [rcx+16]
	mov	rax, r8

; 488  :     }

	ret	0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 481  :     [[noreturn]] static void _Xran() {

$LN4:
	sub	rsp, 40					; 00000028H

; 482  :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN3@Xran:
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcap$ = 56
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT

; 2436 :     constexpr void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap) {

$LN6:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 2437 :         // determine new minimum length of allocated storage
; 2438 :         if (_Mypair._Myval2._Myres >= _Newcap) { // requested capacity is not larger than current capacity, ignore

	cmp	QWORD PTR [rcx+24], rdx
	jae	SHORT $LN1@reserve
	mov	QWORD PTR [rsp+48], rbx

; 2439 :             return; // nothing to do
; 2440 :         }
; 2441 : 
; 2442 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rbx, QWORD PTR [rcx+16]

; 2443 :         _Reallocate_grow_by(_Newcap - _Old_size,

	sub	rdx, rbx
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >

; 2444 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
; 2445 :                 _STATIC_LAMBDA { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });
; 2446 : 
; 2447 :         // `_Reallocate_grow_by` calls `_ASAN_STRING_CREATE` assuming that the string
; 2448 :         // has size (initialized memory) equal to its new capacity (allocated memory).
; 2449 :         // This is not true for the `reserve` method, so we modify the ASan annotation.
; 2450 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _Old_size);
; 2451 :         _Mypair._Myval2._Mysize = _Old_size;

	mov	QWORD PTR [rdi+16], rbx
	mov	rbx, QWORD PTR [rsp+48]
$LN1@reserve:

; 2452 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@QEBA@QEADQEBD0@Z
_TEXT	SEGMENT
this$dead$ = 8
_New_ptr$ = 16
_Old_ptr$ = 24
_Old_size$ = 32
??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@QEBA@QEADQEBD0@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1>::operator(), COMDAT

; 2445 :                 _STATIC_LAMBDA { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });

	mov	rax, r8
	mov	rcx, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2445 :                 _STATIC_LAMBDA { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });

	lea	r8, QWORD PTR [r9+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
??R<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@QEBA@QEADQEBD0@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
;	COMDAT ?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z PROC ; std::_Narrow_char_traits<char,int>::compare, COMDAT

; 435  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 436  : #if _HAS_CXX17
; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	jmp	memcmp
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ENDP ; std::_Narrow_char_traits<char,int>::compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@Object@Json@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@Object@Json@@QEAAX_K@Z PROC		; Json::Object::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	vmovups	YMMWORD PTR [rcx], ymm0
	vmovups	YMMWORD PTR [rcx+32], ymm0
	xor	eax, eax
	mov	QWORD PTR [rcx+64], rax
	vzeroupper
	ret	0
?__autoclassinit2@Object@Json@@QEAAX_K@Z ENDP		; Json::Object::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@Array@Json@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@Array@Json@@QEAAX_K@Z PROC		; Json::Array::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	vmovups	YMMWORD PTR [rcx], ymm0
	vzeroupper
	ret	0
?__autoclassinit2@Array@Json@@QEAAX_K@Z ENDP		; Json::Array::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VString@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VString@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0VString@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VString@Json@@@1@@Z PROC ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::String,0>, COMDAT

; 3305 :     _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0VString@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VString@Json@@@1@@Z ENDP ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::String,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 978  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 978  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> ><std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0U?$default_delete@VObject@Json@@@std@@$0A@@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@PEAVObject@Json@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0U?$default_delete@VObject@Json@@@std@@$0A@@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@PEAVObject@Json@@@Z PROC ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::unique_ptr<Json::Object,std::default_delete<Json::Object> ><std::default_delete<Json::Object>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3370 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VObject@Json@@@std@@$0A@@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAA@PEAVObject@Json@@@Z ENDP ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::unique_ptr<Json::Object,std::default_delete<Json::Object> ><std::default_delete<Json::Object>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Keyval$ = 16
??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15

; 3390 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN14@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN14@operator:
	xor	r8d, r8d
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2292 :     return _Fnv1a_append_bytes(

	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN36@operator
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	6
$LL32@operator:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [rdx+r8]
	inc	r8
	xor	rax, rcx

; 2261 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	r8, r9
	jb	SHORT $LL32@operator
$LN36@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 144  :     }

	ret	0
??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
_Hashval$ = 88
??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1584 :     _NODISCARD _Hash_find_last_result<_Nodeptr> _Find_last(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN64:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1585 :         // find the insertion point for _Keyval and whether an element identical to _Keyval is already in the container
; 1586 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rbp, QWORD PTR [rcx+48]
	mov	r14, r8

; 1587 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1588 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR [rcx+8]
	and	rbp, r9
	shl	rbp, 4
	mov	rdi, rdx
	add	rbp, QWORD PTR [rcx+24]
	mov	rbx, QWORD PTR [rbp+8]

; 1589 :         if (_Where == _End) {

	cmp	rbx, rax
	jne	SHORT $LN5@Find_last

; 1590 :             return {_End, _Nodeptr{}};

	mov	QWORD PTR [rdx], rax

; 1611 :         }
; 1612 :     }

	mov	rax, rdx
	mov	QWORD PTR [rdx+8], 0
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
$LN5@Find_last:

; 1593 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rbp, QWORD PTR [rbp]
	mov	QWORD PTR [rsp+64], rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rsi, QWORD PTR [r8+16]
	mov	QWORD PTR [rsp+72], r15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1593 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r15, QWORD PTR [r8+24]
$LL4@Find_last:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+40], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1596 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN22@Find_last

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN22@Find_last:

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 445  :         if (_Large_mode_engaged()) {

	cmp	r15, 15
	jbe	SHORT $LN29@Find_last

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN29@Find_last:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	rsi, QWORD PTR [rbx+32]
	jne	SHORT $LN50@Find_last

; 605  :         return false;
; 606  :     }
; 607  : 
; 608  :     if (_Left_size == 0u) {

	test	rsi, rsi
	je	SHORT $LN45@Find_last

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rsi
	call	memcmp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1596 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN45@Find_last
$LN50@Find_last:

; 1604 :             }
; 1605 : 
; 1606 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rbp
	je	SHORT $LN46@Find_last

; 1608 :             }
; 1609 : 
; 1610 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
	jmp	SHORT $LL4@Find_last
$LN45@Find_last:

; 1597 :                 if constexpr (!_Traits::_Standard) {
; 1598 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1599 :                         return {_Where->_Next, _Nodeptr{}};
; 1600 :                     }
; 1601 :                 }
; 1602 : 
; 1603 :                 return {_Where->_Next, _Where};

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [rdi+8], rbx
	jmp	SHORT $LN60@Find_last
$LN46@Find_last:

; 1607 :                 return {_Where, _Nodeptr{}};

	mov	QWORD PTR [rdi], rbx
	mov	QWORD PTR [rdi+8], 0
$LN60@Find_last:

; 1611 :         }
; 1612 :     }

	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rdi
	mov	r15, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
??$_Find_last@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Hash_find_last_result@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Find_last<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
<_Vals_1>$ = 72
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 593  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN97:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r9
	mov	rbx, r8
	mov	rsi, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx

; 1167 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	xor	ebp, ebp
	mov	QWORD PTR [rcx+8], rbp

; 1168 :         _Ptr = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdx, rax
	mov	QWORD PTR [rsi+8], rax
	vpxor	xmm0, xmm0, xmm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rax+16], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rax+32], rbp

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rax+40], rbp

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	YMMWORD PTR [rax+16], ymm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	BYTE PTR [rbx], bpl
	mov	QWORD PTR [rbx+16], rbp
	mov	QWORD PTR [rbx+24], 15

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdi]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdi], rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx+48], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 596  :     }

	mov	rax, rsi
	vzeroupper
	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
<_Vals_0>$ = 64
<_Vals_1>$ = 72
?dtor$0@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z@4HA PROC ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
?dtor$0@?0???$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z@4HA ENDP ; `std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\unordered_map
;	COMDAT ??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z PROC ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 55   :         return _Val.first;

	mov	rax, rcx

; 56   :     }

	ret	0
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ENDP ; std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@$$QEA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,bool,0>, COMDAT

; 274  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 275  :     }

	mov	rax, rcx
	ret	0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@$$QEA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VObject@Json@@@std@@@std@@YA$$QEAU?$default_delete@VObject@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VObject@Json@@@std@@@std@@YA$$QEAU?$default_delete@VObject@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::Object> >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@U?$default_delete@VObject@Json@@@std@@@std@@YA$$QEAU?$default_delete@VObject@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::Object> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VObject@Json@@@1@$$QEAPEAVObject@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VObject@Json@@@1@$$QEAPEAVObject@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Object>,Json::Object *>, COMDAT

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VObject@Json@@@1@$$QEAPEAVObject@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Object>,Json::Object *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0U?$default_delete@VArray@Json@@@std@@$0A@@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@PEAVArray@Json@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0U?$default_delete@VArray@Json@@@std@@$0A@@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@PEAVArray@Json@@@Z PROC ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::unique_ptr<Json::Array,std::default_delete<Json::Array> ><std::default_delete<Json::Array>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3370 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VArray@Json@@@std@@$0A@@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAA@PEAVArray@Json@@@Z ENDP ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::unique_ptr<Json::Array,std::default_delete<Json::Array> ><std::default_delete<Json::Array>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VArray@Json@@@std@@@std@@YA$$QEAU?$default_delete@VArray@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VArray@Json@@@std@@@std@@YA$$QEAU?$default_delete@VArray@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::Array> >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@U?$default_delete@VArray@Json@@@std@@@std@@YA$$QEAU?$default_delete@VArray@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::Array> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VArray@Json@@@1@$$QEAPEAVArray@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VArray@Json@@@1@$$QEAPEAVArray@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Array>,Json::Array *>, COMDAT

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VArray@Json@@@1@$$QEAPEAVArray@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Array>,Json::Array *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEAPEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVString@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVString@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1><Json::String * &>, COMDAT

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAVString@Json@@@?$_Compressed_pair@U?$default_delete@VString@Json@@@std@@PEAVString@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVString@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1>::_Compressed_pair<std::default_delete<Json::String>,Json::String *,1><Json::String * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0U?$default_delete@VBool@Json@@@std@@$0A@@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAA@PEAVBool@Json@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0U?$default_delete@VBool@Json@@@std@@$0A@@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAA@PEAVBool@Json@@@Z PROC ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::unique_ptr<Json::Bool,std::default_delete<Json::Bool> ><std::default_delete<Json::Bool>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3370 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VBool@Json@@@std@@$0A@@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAA@PEAVBool@Json@@@Z ENDP ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::unique_ptr<Json::Bool,std::default_delete<Json::Bool> ><std::default_delete<Json::Bool>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VBool@Json@@@std@@@std@@YA$$QEAU?$default_delete@VBool@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VBool@Json@@@std@@@std@@YA$$QEAU?$default_delete@VBool@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::Bool> >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@U?$default_delete@VBool@Json@@@std@@@std@@YA$$QEAU?$default_delete@VBool@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::Bool> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VBool@Json@@@1@$$QEAPEAVBool@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VBool@Json@@@1@$$QEAPEAVBool@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Bool>,Json::Bool *>, COMDAT

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VBool@Json@@@1@$$QEAPEAVBool@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Bool>,Json::Bool *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0U?$default_delete@VNull@Json@@@std@@$0A@@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAA@PEAVNull@Json@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0U?$default_delete@VNull@Json@@@std@@$0A@@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAA@PEAVNull@Json@@@Z PROC ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::unique_ptr<Json::Null,std::default_delete<Json::Null> ><std::default_delete<Json::Null>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3370 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VNull@Json@@@std@@$0A@@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAA@PEAVNull@Json@@@Z ENDP ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::unique_ptr<Json::Null,std::default_delete<Json::Null> ><std::default_delete<Json::Null>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VNull@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNull@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VNull@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNull@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::Null> >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@U?$default_delete@VNull@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNull@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::Null> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNull@Json@@@1@$$QEAPEAVNull@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNull@Json@@@1@$$QEAPEAVNull@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Null>,Json::Null *>, COMDAT

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNull@Json@@@1@$$QEAPEAVNull@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Null>,Json::Null *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@N@std@@YA$$QEANAEAN@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@N@std@@YA$$QEANAEAN@Z PROC			; std::forward<double>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@N@std@@YA$$QEANAEAN@Z ENDP			; std::forward<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@PEAVNumber@Json@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@PEAVNumber@Json@@@Z PROC ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::unique_ptr<Json::Number,std::default_delete<Json::Number> ><std::default_delete<Json::Number>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3370 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VNumber@Json@@@std@@$0A@@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAA@PEAVNumber@Json@@@Z ENDP ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::unique_ptr<Json::Number,std::default_delete<Json::Number> ><std::default_delete<Json::Number>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VNumber@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNumber@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VNumber@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNumber@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::Number> >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@U?$default_delete@VNumber@Json@@@std@@@std@@YA$$QEAU?$default_delete@VNumber@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::Number> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNumber@Json@@@1@$$QEAPEAVNumber@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNumber@Json@@@1@$$QEAPEAVNumber@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Number>,Json::Number *>, COMDAT

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VNumber@Json@@@1@$$QEAPEAVNumber@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Number>,Json::Number *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PEAVString@Json@@@std@@YA$$QEAPEAVString@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVString@Json@@@std@@YA$$QEAPEAVString@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::String *>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@PEAVString@Json@@@std@@YA$$QEAPEAVString@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::String *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z PROC ; std::_Construct_in_place<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 469  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	rax, QWORD PTR [rdx]

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }

	mov	QWORD PTR [rdx], 0
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAXAEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@$$QEAV10@@Z ENDP ; std::_Construct_in_place<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z
_TEXT	SEGMENT
_Al$dead$ = 64
_Count$ = 72
??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 2294 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN30:
	sub	rsp, 56					; 00000038H

; 2295 : #if _HAS_CXX23
; 2296 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2297 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2298 :         _Count                  = _Allocated;
; 2299 :         return _Ptr;
; 2300 :     } else
; 2301 : #endif // _HAS_CXX23
; 2302 :     {
; 2303 :         return _Al.allocate(_Count);

	mov	rcx, QWORD PTR [rdx]

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN26@Allocate_a

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rcx*8]

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN10@Allocate_a

; 228  :         return nullptr;

	xor	eax, eax

; 2304 :     }
; 2305 : }

	add	rsp, 56					; 00000038H
	ret	0
$LN10@Allocate_a:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN12@Allocate_a

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN26@Allocate_a

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN18@Allocate_a
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN18@Allocate_a:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 2304 :     }
; 2305 : }

	add	rsp, 56					; 00000038H
	ret	0
$LN12@Allocate_a:
	add	rsp, 56					; 00000038H

; 136  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN26@Allocate_a:

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN28@Allocate_a:
??$_Allocate_at_least_helper@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$construct@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::construct<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx], rax

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	ret	0
??$construct@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::construct<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > * const &>, COMDAT

; 1380 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1381 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1382 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1383 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1384 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1385 :     } else {
; 1386 :         return static_cast<_Iter&&>(_It);
; 1387 :     }
; 1388 : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA?A_TAEBQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
??$_Uninitialized_move@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1977 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rax, r8

; 1978 :     // move [_First, _Last) to raw _Dest, using _Al
; 1979 :     // note: only called internally from elsewhere in the STL
; 1980 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1981 :     _STD _Adl_verify_range(_First, _Last);
; 1982 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1983 :     using _Ptrval     = typename _Alloc::value_type*;
; 1984 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1986 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1987 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1988 : #if _HAS_CXX20
; 1989 :         if (!_STD is_constant_evaluated())
; 1990 : #endif // _HAS_CXX20
; 1991 :         {
; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1993 :             return _Dest + (_ULast - _UFirst);
; 1994 :         }
; 1995 :     }
; 1996 : 
; 1997 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN70@Uninitiali

; 1977 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	xor	r9d, r9d
	npad	5
$LL4@Uninitiali:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1845 :         ++_Last;

	add	rcx, 8

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rax], r8

; 1845 :         ++_Last;

	add	rax, 8

; 1978 :     // move [_First, _Last) to raw _Dest, using _Al
; 1979 :     // note: only called internally from elsewhere in the STL
; 1980 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1981 :     _STD _Adl_verify_range(_First, _Last);
; 1982 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1983 :     using _Ptrval     = typename _Alloc::value_type*;
; 1984 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1985 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1986 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1987 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1988 : #if _HAS_CXX20
; 1989 :         if (!_STD is_constant_evaluated())
; 1990 : #endif // _HAS_CXX20
; 1991 :         {
; 1992 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1993 :             return _Dest + (_ULast - _UFirst);
; 1994 :         }
; 1995 :     }
; 1996 : 
; 1997 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1998 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	jne	SHORT $LL4@Uninitiali
$LN70@Uninitiali:

; 1999 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 2000 :     }
; 2001 : 
; 2002 :     return _Backout._Release();
; 2003 : }

	ret	0
??$_Uninitialized_move@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > *,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@AEAU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 64
_Ptr$ = 72
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN67:
	push	rbx
	sub	rsp, 48					; 00000030H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rdx+32]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	rbx, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	test	rcx, rcx
	je	SHORT $LN21@destroy

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN21@destroy:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN42@destroy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN50@destroy

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN49@destroy

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN50@destroy:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN42@destroy:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 743  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN49@destroy:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN64@destroy:
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$destroy_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_Location$ = 8
??$destroy_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z PROC ; std::destroy_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN14@destroy_at

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN14@destroy_at:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 339  : }

	ret	0
??$destroy_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ENDP ; std::destroy_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>, COMDAT

; 1353 :     // check that [_First, _Last) forms an iterator range
; 1354 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1355 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1356 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1357 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1358 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1359 :         _Verify_range(_First, _Last);
; 1360 :     }
; 1361 : }

	ret	0
??$_Adl_verify_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXAEBQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>, COMDAT

; 1633 :         // construct a new element at *_Last and increment
; 1634 :         _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1635 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1636 :     }

	ret	0
??$_Emplace_back@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAXAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::_Emplace_back<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 64
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN10:
	sub	rsp, 56					; 00000038H

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN9@Allocate_m

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN3@Allocate_m
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	xor	edx, edx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN3@Allocate_m:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

	add	rsp, 56					; 00000038H
	ret	0
$LN9@Allocate_m:

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN7@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAVString@Json@@$$T@std@@YAPEAVString@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVString@Json@@$$T@std@@YAPEAVString@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::String *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVString@Json@@$$T@std@@YAPEAVString@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::String *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 112  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx*8]

; 123  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * &>, COMDAT

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z
_TEXT	SEGMENT
this$ = 64
_Keyval$ = 72
_Hashval$ = 80
??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1216 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

$LN66:
	push	rbx
	push	rsi
	push	r15
	sub	rsp, 32					; 00000020H

; 1586 :         const size_type _Bucket = _Hashval & _Mask;

	mov	r9, QWORD PTR [rcx+48]

; 1216 :     _Nodeptr _Find(const _Keyty& _Keyval, const size_t _Hashval) const {

	mov	rsi, rdx

; 1587 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	mov	rax, QWORD PTR [rcx+24]
	and	r9, r8

; 1588 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r15, QWORD PTR [rcx+8]
	add	r9, r9
	mov	rbx, QWORD PTR [rax+r9*8+8]

; 1589 :         if (_Where == _End) {

	cmp	rbx, r15
	jne	SHORT $LN8@Find

; 1590 :             return {_End, _Nodeptr{}};

	xor	ebx, ebx
	jmp	SHORT $LN6@Find
$LN8@Find:
	mov	QWORD PTR [rsp+64], rbp

; 1593 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rbp, QWORD PTR [rax+r9*8]
	mov	QWORD PTR [rsp+72], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rdi, QWORD PTR [rdx+16]
	mov	QWORD PTR [rsp+80], r14
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1593 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	r14, QWORD PTR [rdx+24]
	npad	9
$LL7@Find:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+40], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1596 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	lea	rdx, QWORD PTR [rbx+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN25@Find

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN25@Find:

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rsi

; 445  :         if (_Large_mode_engaged()) {

	cmp	r14, 15
	jbe	SHORT $LN32@Find

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rsi]
$LN32@Find:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	rdi, QWORD PTR [rbx+32]
	jne	SHORT $LN53@Find

; 605  :         return false;
; 606  :     }
; 607  : 
; 608  :     if (_Left_size == 0u) {

	test	rdi, rdi
	je	SHORT $LN63@Find

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	call	memcmp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1596 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN63@Find
$LN53@Find:

; 1597 :                 if constexpr (!_Traits::_Standard) {
; 1598 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1599 :                         return {_Where->_Next, _Nodeptr{}};
; 1600 :                     }
; 1601 :                 }
; 1602 : 
; 1603 :                 return {_Where->_Next, _Where};
; 1604 :             }
; 1605 : 
; 1606 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rbp
	je	SHORT $LN49@Find

; 1608 :             }
; 1609 : 
; 1610 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
	jmp	SHORT $LL7@Find
$LN49@Find:

; 1607 :                 return {_Where, _Nodeptr{}};

	xor	ebx, ebx
$LN63@Find:
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+80]
$LN6@Find:

; 1217 :         if constexpr (_Traits::_Multi) {
; 1218 :             return _Find_first(_Keyval, _Hashval);
; 1219 :         } else {
; 1220 :             // use _Find_last for unique containers to avoid increase in code size of instantiating _Find_first
; 1221 :             auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;
; 1222 :             if (_Target) {

	test	rbx, rbx
	cmovne	r15, rbx

; 1223 :                 return _Target;

	mov	rax, r15

; 1224 :             }
; 1225 : 
; 1226 :             return _List._Mypair._Myval2._Myhead;
; 1227 :         }
; 1228 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rsi
	pop	rbx
	ret	0
??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEBAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >, COMDAT

; 3024 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN132:
	push	rbx
	push	rsi
	push	r15
	sub	rsp, 64					; 00000040H

; 3025 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3026 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3027 :         auto& _My_data            = _Mypair._Myval2;
; 3028 :         const size_type _Old_size = _My_data._Mysize;

	mov	r15, QWORD PTR [rcx+16]

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbx
	mov	rsi, rcx
	sub	rax, r15
	cmp	rax, rdx
	jb	$LN129@Reallocate

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	QWORD PTR [rsp+112], rbp
	lea	rbp, QWORD PTR [r15+rdx]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rdx, rbp
	mov	QWORD PTR [rsp+56], rdi
	or	rdx, 15
	mov	QWORD PTR [rsp+48], r14

; 3034 :         const size_type _Old_capacity = _My_data._Myres;

	mov	r14, QWORD PTR [rcx+24]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	cmp	rdx, rbx

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN127@Reallocate

; 2980 :             return _Max;
; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, r14
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	r14, rax
	ja	SHORT $LN127@Reallocate

; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r14+rcx]
	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbx+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN28@Reallocate

; 228  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN27@Reallocate
$LN28@Reallocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN30@Reallocate

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN130@Reallocate
	jmp	SHORT $LN35@Reallocate
$LN127@Reallocate:

; 136  :         return ::operator new(_Bytes);

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN35@Reallocate:
	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN72@Reallocate

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN27@Reallocate
$LN30@Reallocate:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN27@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], rbp

; 3042 :         _My_data._Myres       = _New_capacity;
; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	lea	r8, QWORD PTR [r15+1]
	mov	QWORD PTR [rsi+24], rbx

; 3044 :         if (_Old_capacity > _Small_string_capacity) {

	mov	rcx, rdi
	cmp	r14, 15
	jbe	SHORT $LN3@Reallocate

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r14+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN73@Reallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rbx, rax
	sub	rbx, 8
	cmp	rbx, 31
	ja	SHORT $LN72@Reallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rax
$LN73@Reallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3049 :         } else {

	jmp	SHORT $LN79@Reallocate
$LN72@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN3@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	call	memcpy
$LN79@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3055 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+112]
	mov	r14, QWORD PTR [rsp+48]

; 3056 :     }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	rsi
	pop	rbx
	ret	0
$LN129@Reallocate:

; 3030 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN130@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN126@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??reserve@01@QEAAX0@Z@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::_Release, COMDAT

; 1658 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1659 :         return _Last;
; 1660 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>, COMDAT

; 1628 :         _STD _Destroy_range(_First, _Last);
; 1629 :     }

	ret	0
??1?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::~_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>, COMDAT

; 1620 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Uninitialized_backout@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>::_Uninitialized_backout<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_Release, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx+8]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx+8], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1164 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >, COMDAT

; 598  :     ~_List_node_emplace_op2() {

$LN29:
	push	rbx
	sub	rsp, 32					; 00000020H

; 599  :         if (this->_Ptr != pointer{}) {

	mov	rdx, QWORD PTR [rcx+8]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN2@List_node_

; 600  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

	add	rdx, 16
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
$LN2@List_node_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1172 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN12@List_node_

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 602  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@List_node_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 602  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV32@AEBV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
_Val$ = 8
__formal$dead$ = 16
?_Extract@?$_In_place_key_extract_map_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV32@AEBV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@Z PROC ; std::_In_place_key_extract_map_impl<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::_Extract, COMDAT

; 2166 :         return _Val;

	mov	rax, rcx

; 2167 :     }

	ret	0
?_Extract@?$_In_place_key_extract_map_impl@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@SAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV32@AEBV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@Z ENDP ; std::_In_place_key_extract_map_impl<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?release@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAPEAVNumber@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAPEAVNumber@Json@@XZ PROC ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::release, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3466 :     }

	ret	0
?release@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAPEAVNumber@Json@@XZ ENDP ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ PROC ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::get_deleter, COMDAT

; 3441 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3442 :     }

	ret	0
?get_deleter@?$unique_ptr@VNumber@Json@@U?$default_delete@VNumber@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNumber@Json@@@2@XZ ENDP ; std::unique_ptr<Json::Number,std::default_delete<Json::Number> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??R?$default_delete@VNumber@Json@@@std@@QEBAXPEAVNumber@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VNumber@Json@@@std@@QEBAXPEAVNumber@Json@@@Z PROC ; std::default_delete<Json::Number>::operator(), COMDAT

; 3307 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3308 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3309 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3310 :     }

	ret	0
??R?$default_delete@VNumber@Json@@@std@@QEBAXPEAVNumber@Json@@@Z ENDP ; std::default_delete<Json::Number>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@$00@std@@QEAAAEAU?$default_delete@VNull@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@$00@std@@QEAAAEAU?$default_delete@VNull@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::Null>,Json::Null *,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@$00@std@@QEAAAEAU?$default_delete@VNull@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::Null>,Json::Null *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?release@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAAPEAVNull@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAAPEAVNull@Json@@XZ PROC ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::release, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3466 :     }

	ret	0
?release@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAAPEAVNull@Json@@XZ ENDP ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNull@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNull@Json@@@2@XZ PROC ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::get_deleter, COMDAT

; 3441 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3442 :     }

	ret	0
?get_deleter@?$unique_ptr@VNull@Json@@U?$default_delete@VNull@Json@@@std@@@std@@QEAAAEAU?$default_delete@VNull@Json@@@2@XZ ENDP ; std::unique_ptr<Json::Null,std::default_delete<Json::Null> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??R?$default_delete@VNull@Json@@@std@@QEBAXPEAVNull@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VNull@Json@@@std@@QEBAXPEAVNull@Json@@@Z PROC ; std::default_delete<Json::Null>::operator(), COMDAT

; 3307 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3308 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3309 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3310 :     }

	ret	0
??R?$default_delete@VNull@Json@@@std@@QEBAXPEAVNull@Json@@@Z ENDP ; std::default_delete<Json::Null>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@$00@std@@QEAAAEAU?$default_delete@VBool@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@$00@std@@QEAAAEAU?$default_delete@VBool@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::Bool>,Json::Bool *,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@$00@std@@QEAAAEAU?$default_delete@VBool@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::Bool>,Json::Bool *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?release@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAAPEAVBool@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAAPEAVBool@Json@@XZ PROC ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::release, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3466 :     }

	ret	0
?release@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAAPEAVBool@Json@@XZ ENDP ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAAAEAU?$default_delete@VBool@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAAAEAU?$default_delete@VBool@Json@@@2@XZ PROC ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::get_deleter, COMDAT

; 3441 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3442 :     }

	ret	0
?get_deleter@?$unique_ptr@VBool@Json@@U?$default_delete@VBool@Json@@@std@@@std@@QEAAAEAU?$default_delete@VBool@Json@@@2@XZ ENDP ; std::unique_ptr<Json::Bool,std::default_delete<Json::Bool> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??R?$default_delete@VBool@Json@@@std@@QEBAXPEAVBool@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VBool@Json@@@std@@QEBAXPEAVBool@Json@@@Z PROC ; std::default_delete<Json::Bool>::operator(), COMDAT

; 3307 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3308 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3309 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3310 :     }

	ret	0
??R?$default_delete@VBool@Json@@@std@@QEBAXPEAVBool@Json@@@Z ENDP ; std::default_delete<Json::Bool>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@$00@std@@QEAAAEAU?$default_delete@VObject@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@$00@std@@QEAAAEAU?$default_delete@VObject@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::Object>,Json::Object *,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@$00@std@@QEAAAEAU?$default_delete@VObject@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::Object>,Json::Object *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?release@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAPEAVObject@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAPEAVObject@Json@@XZ PROC ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::release, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3466 :     }

	ret	0
?release@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAPEAVObject@Json@@XZ ENDP ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAAEAU?$default_delete@VObject@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAAEAU?$default_delete@VObject@Json@@@2@XZ PROC ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::get_deleter, COMDAT

; 3441 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3442 :     }

	ret	0
?get_deleter@?$unique_ptr@VObject@Json@@U?$default_delete@VObject@Json@@@std@@@std@@QEAAAEAU?$default_delete@VObject@Json@@@2@XZ ENDP ; std::unique_ptr<Json::Object,std::default_delete<Json::Object> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??R?$default_delete@VObject@Json@@@std@@QEBAXPEAVObject@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VObject@Json@@@std@@QEBAXPEAVObject@Json@@@Z PROC ; std::default_delete<Json::Object>::operator(), COMDAT

; 3307 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3308 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3309 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3310 :     }

	ret	0
??R?$default_delete@VObject@Json@@@std@@QEBAXPEAVObject@Json@@@Z ENDP ; std::default_delete<Json::Object>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@$00@std@@QEAAAEAU?$default_delete@VArray@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@$00@std@@QEAAAEAU?$default_delete@VArray@Json@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<Json::Array>,Json::Array *,1>::_Get_first, COMDAT

; 1539 :         return *this;

	mov	rax, rcx

; 1540 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@$00@std@@QEAAAEAU?$default_delete@VArray@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<Json::Array>,Json::Array *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?release@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAPEAVArray@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAPEAVArray@Json@@XZ PROC ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::release, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3466 :     }

	ret	0
?release@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAPEAVArray@Json@@XZ ENDP ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAAEAU?$default_delete@VArray@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAAEAU?$default_delete@VArray@Json@@@2@XZ PROC ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::get_deleter, COMDAT

; 3441 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3442 :     }

	ret	0
?get_deleter@?$unique_ptr@VArray@Json@@U?$default_delete@VArray@Json@@@std@@@std@@QEAAAEAU?$default_delete@VArray@Json@@@2@XZ ENDP ; std::unique_ptr<Json::Array,std::default_delete<Json::Array> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??R?$default_delete@VArray@Json@@@std@@QEBAXPEAVArray@Json@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??R?$default_delete@VArray@Json@@@std@@QEBAXPEAVArray@Json@@@Z PROC ; std::default_delete<Json::Array>::operator(), COMDAT

; 3307 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

	mov	r8, rdx

; 3308 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3309 :         delete _Ptr;

	test	rdx, rdx
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r8
	mov	edx, 1
	rex_jmp	QWORD PTR [rax]
$LN3@operator:

; 3310 :     }

	ret	0
??R?$default_delete@VArray@Json@@@std@@QEBAXPEAVArray@Json@@@Z ENDP ; std::default_delete<Json::Array>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >, COMDAT

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >, COMDAT

; 353  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >::allocate, COMDAT

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	ecx, 56					; 00000038H
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >::deallocate, COMDAT

; 982  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

	mov	rcx, rdx

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Make_iter, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], r8

; 1137 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

	mov	rax, rdx

; 1138 :     }

	ret	0
?_Make_iter@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::end, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1113 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

	mov	rax, rdx

; 1114 :     }

	ret	0
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Rehash_for_1, COMDAT

; 1678 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;
; 1679 :         const auto _Newsize = _Oldsize + 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	r9, rcx
	add	rdx, 1

; 1707 :         const size_type _Old_buckets = bucket_count();

	mov	r8, QWORD PTR [rcx+56]

; 1703 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	vxorps	xmm0, xmm0, xmm0
	js	SHORT $LN18@Rehash_for
	vcvtsi2ss xmm0, xmm0, rdx
	jmp	SHORT $LN19@Rehash_for
$LN18@Rehash_for:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	vcvtsi2ss xmm0, xmm0, rax
	vaddss	xmm0, xmm0, xmm0
$LN19@Rehash_for:
	vdivss	xmm0, xmm0, DWORD PTR [rcx]
	vxorps	xmm1, xmm1, xmm1
	vroundss xmm1, xmm1, xmm0, 2
	vmovss	xmm0, DWORD PTR __real@5f000000
	xor	ecx, ecx
	vcomiss	xmm1, xmm0
	jb	SHORT $LN17@Rehash_for
	vsubss	xmm1, xmm1, xmm0
	vcomiss	xmm1, xmm0
	jae	SHORT $LN17@Rehash_for
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN17@Rehash_for:
	vcvttss2si rax, xmm1
	add	rax, rcx

; 1708 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

	mov	ecx, 8
	cmp	rax, rcx
	cmova	rcx, rax

; 1709 :         if (_Old_buckets >= _Req_buckets) {

	cmp	r8, rcx
	jae	SHORT $LN3@Rehash_for

; 1710 :             // we already have enough buckets so there's no need to change the count
; 1711 :             return _Old_buckets;
; 1712 :         }
; 1713 : 
; 1714 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	r8, 512					; 00000200H
	jae	SHORT $LN5@Rehash_for
	lea	rax, QWORD PTR [r8*8]
	mov	r8, rax
	cmp	rax, rcx
	jae	SHORT $LN3@Rehash_for
$LN5@Rehash_for:

; 1715 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1716 :             return _Old_buckets * 8;
; 1717 :         }
; 1718 : 
; 1719 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1720 :         return _Req_buckets;

	mov	r8, rcx
$LN3@Rehash_for:

; 1680 :         _Forced_rehash(_Desired_grow_bucket_count(_Newsize));

	mov	rdx, r8
	mov	rcx, r9
	jmp	?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Forced_rehash
?_Rehash_for_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Rehash_for_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_NXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Check_rehash_required_1, COMDAT

; 1672 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1673 :         const auto _Newsize      = _Oldsize + 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	r8, rcx
	add	rdx, 1

; 1674 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	vxorps	xmm0, xmm0, xmm0
	js	SHORT $LN9@Check_reha
	vcvtsi2ss xmm0, xmm0, rdx
	jmp	SHORT $LN10@Check_reha
$LN9@Check_reha:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	vcvtsi2ss xmm0, xmm0, rax
	vaddss	xmm0, xmm0, xmm0
$LN10@Check_reha:
	mov	rcx, QWORD PTR [rcx+56]
	vxorps	xmm1, xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN7@Check_reha
	vcvtsi2ss xmm1, xmm1, rcx
	vdivss	xmm0, xmm0, xmm1
	vcomiss	xmm0, DWORD PTR [r8]
	seta	al

; 1675 :     }

	ret	0
$LN7@Check_reha:

; 1674 :         return max_load_factor() < static_cast<float>(_Newsize) / static_cast<float>(bucket_count());

	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	vcvtsi2ss xmm1, xmm1, rax
	vaddss	xmm1, xmm1, xmm1
	vdivss	xmm0, xmm0, xmm1
	vcomiss	xmm0, DWORD PTR [r8]
	seta	al

; 1675 :     }

	ret	0
?_Check_rehash_required_1@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_NXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Check_rehash_required_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAXXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Check_max_size, COMDAT

; 1664 :     void _Check_max_size() const {

$LN6:
	sub	rsp, 40					; 00000028H

; 1665 :         const size_type _Oldsize = _List._Mypair._Myval2._Mysize;
; 1666 :         if (_Oldsize == _List.max_size()) {

	mov	rax, 329406144173384850			; 0492492492492492H
	cmp	QWORD PTR [rcx+16], rax
	jne	SHORT $LN2@Check_max_

; 1667 :             _Xlength_error("unordered_map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BL@GOIGLPKN@unordered_map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2@Check_max_:

; 1668 :         }
; 1669 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Check_max_:
?_Check_max_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAXXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Check_max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_KQEAU32@1@Z
_TEXT	SEGMENT
this$ = 8
_Hashval$ = 16
_Insert_before$ = 24
_Newnode$ = 32
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_KQEAU32@1@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Insert_new_node_before, COMDAT

; 1634 :         const _Nodeptr _Insert_after = _Insert_before->_Prev;

	mov	r11, QWORD PTR [r8+8]
	mov	rax, r9

; 1635 :         ++_List._Mypair._Myval2._Mysize;

	inc	QWORD PTR [rcx+16]
	mov	r9, rdx
	mov	r10, rcx

; 1636 :         _Construct_in_place(_Newnode->_Next, _Insert_before);

	mov	QWORD PTR [rax], r8

; 1637 :         _Construct_in_place(_Newnode->_Prev, _Insert_after);

	mov	QWORD PTR [rax+8], r11

; 1638 :         _Insert_after->_Next  = _Newnode;

	mov	QWORD PTR [r11], rax

; 1639 :         _Insert_before->_Prev = _Newnode;

	mov	QWORD PTR [r8+8], rax

; 1640 : 
; 1641 :         const auto _Head                = _List._Mypair._Myval2._Myhead;
; 1642 :         const auto _Bucket_array        = _Vec._Mypair._Myval2._Myfirst;
; 1643 :         const size_type _Bucket         = _Hashval & _Mask;

	mov	rdx, QWORD PTR [rcx+48]

; 1644 :         _Unchecked_iterator& _Bucket_lo = _Bucket_array[_Bucket << 1];

	mov	rcx, QWORD PTR [rcx+24]
	and	rdx, r9
	add	rdx, rdx

; 1645 :         _Unchecked_iterator& _Bucket_hi = _Bucket_array[(_Bucket << 1) + 1];
; 1646 :         if (_Bucket_lo._Ptr == _Head) {

	mov	r9, QWORD PTR [rcx+rdx*8]
	cmp	r9, QWORD PTR [r10+8]
	jne	SHORT $LN2@Insert_new

; 1647 :             // bucket is empty, set both
; 1648 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rdx*8], rax

; 1654 :             // new node is the highest element in the bucket
; 1655 :             _Bucket_hi._Ptr = _Newnode;
; 1656 :         }
; 1657 : 
; 1658 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1659 :         _Stl_internal_check_container_invariants();
; 1660 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1661 :         return _Newnode;
; 1662 :     }

	mov	QWORD PTR [rcx+rdx*8+8], rax
	ret	0
$LN2@Insert_new:

; 1649 :             _Bucket_hi._Ptr = _Newnode;
; 1650 :         } else if (_Bucket_lo._Ptr == _Insert_before) {

	cmp	r9, r8
	jne	SHORT $LN4@Insert_new

; 1651 :             // new node is the lowest element in the bucket
; 1652 :             _Bucket_lo._Ptr = _Newnode;

	mov	QWORD PTR [rcx+rdx*8], rax

; 1654 :             // new node is the highest element in the bucket
; 1655 :             _Bucket_hi._Ptr = _Newnode;
; 1656 :         }
; 1657 : 
; 1658 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1659 :         _Stl_internal_check_container_invariants();
; 1660 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1661 :         return _Newnode;
; 1662 :     }

	ret	0
$LN4@Insert_new:

; 1653 :         } else if (_Bucket_hi._Ptr == _Insert_after) {

	cmp	QWORD PTR [rcx+rdx*8+8], r11
	jne	SHORT $LN9@Insert_new

; 1654 :             // new node is the highest element in the bucket
; 1655 :             _Bucket_hi._Ptr = _Newnode;
; 1656 :         }
; 1657 : 
; 1658 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1659 :         _Stl_internal_check_container_invariants();
; 1660 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1661 :         return _Newnode;
; 1662 :     }

	mov	QWORD PTR [rcx+rdx*8+8], rax
$LN9@Insert_new:
	ret	0
?_Insert_new_node_before@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@_KQEAU32@1@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Insert_new_node_before
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Reallocation_guard::~_Reallocation_guard, COMDAT

; 620  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

$LN57:
	push	rsi
	sub	rsp, 48					; 00000030H

; 621  :             if (_New_begin != nullptr) {

	cmp	QWORD PTR [rcx+8], 0
	mov	rsi, rcx
	je	SHORT $LN32@Reallocati
	mov	QWORD PTR [rsp+72], rbx

; 622  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	rbx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+80], rdi
	mov	rdi, QWORD PTR [rcx+32]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN7@Reallocati
$LL8@Reallocati:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN26@Reallocati

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN26@Reallocati:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL8@Reallocati
$LN7@Reallocati:

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR [rsi+16]
	mov	rcx, QWORD PTR [rsi+8]
	mov	rdi, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+72]
	shl	rdx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@Reallocati

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN39@Reallocati

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN40@Reallocati:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 625  :         }

	add	rsp, 48					; 00000030H
	pop	rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN32@Reallocati:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 625  :         }

	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN39@Reallocati:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN54@Reallocati:
??1_Reallocation_guard@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@0@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Orphan_range, COMDAT

; 2223 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAXPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@0@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z
_TEXT	SEGMENT
this$ = 80
_Newvec$ = 88
_Newsize$ = 96
_Newcapacity$ = 104
?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array, COMDAT

; 2059 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

$LN57:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 2060 :         // orphan all iterators, discard old array, acquire new array
; 2061 :         auto& _Al         = _Getal();
; 2062 :         auto& _My_data    = _Mypair._Myval2;
; 2063 :         pointer& _Myfirst = _My_data._Myfirst;
; 2064 :         pointer& _Mylast  = _My_data._Mylast;
; 2065 :         pointer& _Myend   = _My_data._Myend;
; 2066 : 
; 2067 :         _My_data._Orphan_all();
; 2068 : 
; 2069 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, r9
	mov	r15, r8
	mov	r14, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN32@Change_arr
	mov	QWORD PTR [rsp+88], rdi

; 2070 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN7@Change_arr
$LL8@Change_arr:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN26@Change_arr

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN26@Change_arr:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL8@Change_arr
$LN7@Change_arr:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+88]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2072 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@Change_arr

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN39@Change_arr

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN40@Change_arr:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN32@Change_arr:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector

; 2079 :     }

	mov	rbx, QWORD PTR [rsp+96]
	lea	rax, QWORD PTR [r14+r15*8]
	mov	QWORD PTR [rsi], r14
	mov	QWORD PTR [rsi+8], rax
	lea	rax, QWORD PTR [r14+rbp*8]
	mov	rbp, QWORD PTR [rsp+104]
	mov	QWORD PTR [rsi+16], rax
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN39@Change_arr:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN54@Change_arr:
?_Change_array@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEAAXQEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K1@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Calculate_growth, COMDAT

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 3

; 2007 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2008 :         const size_type _Oldcapacity = capacity();
; 2009 :         const auto _Max              = max_size();
; 2010 : 
; 2011 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 2012 :             return _Max; // geometric growth would overflow
; 2013 :         }
; 2014 : 
; 2015 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 2016 : 
; 2017 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 2018 :             return _Newsize; // geometric growth would be insufficient
; 2019 :         }
; 2020 : 
; 2021 :         return _Geometric; // geometric growth is sufficient
; 2022 :     }

	ret	0
?_Calculate_growth@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?max_size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size, COMDAT

; 1919 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1920 :     }

	ret	0
?max_size@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z
_TEXT	SEGMENT
this$ = 64
_Off$dead$ = 72
_Ptr$dead$ = 80
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 1778 :     _CONSTEXPR20 basic_string& insert(const size_type _Off, _In_z_ const _Elem* const _Ptr) {

$LN102:
	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	sub	rsp, 48					; 00000030H

; 1733 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [rcx+16]

; 1778 :     _CONSTEXPR20 basic_string& insert(const size_type _Off, _In_z_ const _Elem* const _Ptr) {

	mov	rdi, rcx

; 1738 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();

	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, rcx
	sub	rax, r8
	cmp	rax, 23
	jb	$LN7@insert
	mov	QWORD PTR [rsp+64], rbx

; 1739 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1740 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
; 1741 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1742 : 
; 1743 :         if (_Check_overlap) {
; 1744 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1745 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [r8+23]
	mov	QWORD PTR [rsp+72], rsi

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rbx, rdi

; 1738 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();

	mov	QWORD PTR [rsp+80], r14

; 1739 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1740 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
; 1741 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1742 : 
; 1743 :         if (_Check_overlap) {
; 1744 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1745 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rdi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rcx, 15
	jbe	SHORT $LN17@insert

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rdi]
$LN17@insert:

; 1751 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {

	lea	rax, OFFSET FLAT:??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@+23
	mov	ebp, 23
	lea	r14, OFFSET FLAT:??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@
	cmp	rax, rbx
	jbe	SHORT $LN10@insert
	lea	rax, QWORD PTR [r8+rbx]
	cmp	r14, rax
	ja	SHORT $LN10@insert

; 1754 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

	cmp	rbx, r14
	ja	SHORT $LN11@insert

; 1755 :                 _Ptr_shifted_after = 0;

	xor	esi, esi

; 1756 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

	jmp	SHORT $LN12@insert
$LN11@insert:

; 1757 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

	mov	rsi, rbx
	sub	rsi, r14
	jmp	SHORT $LN12@insert
$LN10@insert:

; 1752 :                 // inserted content is before the shifted region, or does not alias
; 1753 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

	mov	rsi, rbp
$LN12@insert:

; 1758 :             }
; 1759 : 
; 1760 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	r8
	lea	rcx, QWORD PTR [rbx+23]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memmove

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rbx
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1762 :             _Traits::copy(

	sub	rbp, rsi
	lea	rdx, QWORD PTR [r14+23]
	add	rdx, rsi
	lea	rcx, QWORD PTR [rbx+rsi]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rbp
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1780 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r14, QWORD PTR [rsp+80]
	mov	rax, rdi
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 1781 :     }

	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN7@insert:

; 1767 :         return _Reallocate_grow_by(

	mov	ebp, 23
	mov	rcx, rdi
	mov	edx, ebp
	mov	QWORD PTR [rsp+40], rbp
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>

; 1781 :     }

	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	xor	eax, eax
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::`scalar deleting destructor', COMDAT
$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN14@scalar

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN14@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAXI@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0U?$default_delete@VValue@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0U?$default_delete@VValue@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><std::default_delete<Json::Value>,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3386 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VValue@Json@@@std@@$0A@@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::unique_ptr<Json::Value,std::default_delete<Json::Value> ><std::default_delete<Json::Value>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VObject@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VObject@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0VObject@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VObject@Json@@@1@@Z PROC ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Object,0>, COMDAT

; 3305 :     _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0VObject@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VObject@Json@@@1@@Z ENDP ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Object,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VArray@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VArray@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0VArray@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VArray@Json@@@1@@Z PROC ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Array,0>, COMDAT

; 3305 :     _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0VArray@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VArray@Json@@@1@@Z ENDP ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Array,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VBool@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VBool@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0VBool@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VBool@Json@@@1@@Z PROC ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Bool,0>, COMDAT

; 3305 :     _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0VBool@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VBool@Json@@@1@@Z ENDP ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VNull@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNull@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0VNull@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNull@Json@@@1@@Z PROC ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Null,0>, COMDAT

; 3305 :     _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0VNull@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNull@Json@@@1@@Z ENDP ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Null,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ??$?0VNumber@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNumber@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0VNumber@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNumber@Json@@@1@@Z PROC ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Number,0>, COMDAT

; 3305 :     _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0VNumber@Json@@$0A@@?$default_delete@VValue@Json@@@std@@QEAA@AEBU?$default_delete@VNumber@Json@@@1@@Z ENDP ; std::default_delete<Json::Value>::default_delete<Json::Value><Json::Number,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEAPEAVObject@Json@@@?$_Compressed_pair@U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVObject@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAVObject@Json@@@?$_Compressed_pair@U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVObject@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Object>,Json::Object *,1>::_Compressed_pair<std::default_delete<Json::Object>,Json::Object *,1><Json::Object * &>, COMDAT

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAVObject@Json@@@?$_Compressed_pair@U?$default_delete@VObject@Json@@@std@@PEAVObject@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVObject@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Object>,Json::Object *,1>::_Compressed_pair<std::default_delete<Json::Object>,Json::Object *,1><Json::Object * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
this$dead$ = 48
_Keyval1$ = 56
_Keyval2$ = 64
??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 148  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

$LN37:
	sub	rsp, 40					; 00000028H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [r8+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 148  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

	mov	r9, r8
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rcx, QWORD PTR [r8+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 148  :         noexcept(_Nothrow_compare<_Keyeq, _Keyty1, _Keyty2>) {

	mov	rax, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN14@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r8]
$LN14@operator:

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN21@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN21@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	r8, rcx
	je	SHORT $LN28@operator

; 605  :         return false;

	xor	al, al
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 150  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	xor	al, 1

; 151  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 608  :     if (_Left_size == 0u) {

	test	r8, r8
	jne	SHORT $LN29@operator

; 609  :         return true;

	mov	al, 1
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 150  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	xor	al, al

; 151  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN29@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rdx, r9
	mov	rcx, rax
	call	memcmp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	sete	al
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 150  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	xor	al, 1

; 151  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$?RV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator()<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
<_Args_1>$ = 32
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	ecx, ecx
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rdx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rdx+16], rcx

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rdx+24], rcx

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [r8]
	vmovups	YMMWORD PTR [rdx], ymm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	BYTE PTR [r8], cl
	mov	QWORD PTR [r8+16], rcx
	mov	QWORD PTR [r8+24], 15
	mov	rax, QWORD PTR [r9]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdx+32], rax
	vzeroupper

; 729  : #if _HAS_CXX20
; 730  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 731  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 733  : #endif // ^^^ !_HAS_CXX20 ^^^
; 734  :     }

	ret	0
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PEAVObject@Json@@@std@@YA$$QEAPEAVObject@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVObject@Json@@@std@@YA$$QEAPEAVObject@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Object *>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@PEAVObject@Json@@@std@@YA$$QEAPEAVObject@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Object *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEAPEAVArray@Json@@@?$_Compressed_pair@U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVArray@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAVArray@Json@@@?$_Compressed_pair@U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVArray@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Array>,Json::Array *,1>::_Compressed_pair<std::default_delete<Json::Array>,Json::Array *,1><Json::Array * &>, COMDAT

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAVArray@Json@@@?$_Compressed_pair@U?$default_delete@VArray@Json@@@std@@PEAVArray@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVArray@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Array>,Json::Array *,1>::_Compressed_pair<std::default_delete<Json::Array>,Json::Array *,1><Json::Array * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PEAVArray@Json@@@std@@YA$$QEAPEAVArray@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVArray@Json@@@std@@YA$$QEAPEAVArray@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Array *>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@PEAVArray@Json@@@std@@YA$$QEAPEAVArray@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Array *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEAPEAVString@Json@@@std@@YAAEAPEAVString@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVString@Json@@@std@@YAAEAPEAVString@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::String * &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEAPEAVString@Json@@@std@@YAAEAPEAVString@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::String * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEAPEAVBool@Json@@@?$_Compressed_pair@U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVBool@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAVBool@Json@@@?$_Compressed_pair@U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVBool@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Bool>,Json::Bool *,1>::_Compressed_pair<std::default_delete<Json::Bool>,Json::Bool *,1><Json::Bool * &>, COMDAT

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAVBool@Json@@@?$_Compressed_pair@U?$default_delete@VBool@Json@@@std@@PEAVBool@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVBool@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Bool>,Json::Bool *,1>::_Compressed_pair<std::default_delete<Json::Bool>,Json::Bool *,1><Json::Bool * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PEAVBool@Json@@@std@@YA$$QEAPEAVBool@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVBool@Json@@@std@@YA$$QEAPEAVBool@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Bool *>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@PEAVBool@Json@@@std@@YA$$QEAPEAVBool@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Bool *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEAPEAVNull@Json@@@?$_Compressed_pair@U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNull@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAVNull@Json@@@?$_Compressed_pair@U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNull@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Null>,Json::Null *,1>::_Compressed_pair<std::default_delete<Json::Null>,Json::Null *,1><Json::Null * &>, COMDAT

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAVNull@Json@@@?$_Compressed_pair@U?$default_delete@VNull@Json@@@std@@PEAVNull@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNull@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Null>,Json::Null *,1>::_Compressed_pair<std::default_delete<Json::Null>,Json::Null *,1><Json::Null * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PEAVNull@Json@@@std@@YA$$QEAPEAVNull@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVNull@Json@@@std@@YA$$QEAPEAVNull@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Null *>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@PEAVNull@Json@@@std@@YA$$QEAPEAVNull@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Null *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0AEAPEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNumber@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNumber@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1><Json::Number * &>, COMDAT

; 1531 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAVNumber@Json@@@?$_Compressed_pair@U?$default_delete@VNumber@Json@@@std@@PEAVNumber@Json@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAVNumber@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1>::_Compressed_pair<std::default_delete<Json::Number>,Json::Number *,1><Json::Number * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PEAVNumber@Json@@@std@@YA$$QEAPEAVNumber@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVNumber@Json@@@std@@YA$$QEAPEAVNumber@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Number *>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@PEAVNumber@Json@@@std@@YA$$QEAPEAVNumber@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Number *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@$$QEAV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@$$QEAV10@@Z PROC ; std::construct_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 464  : }

	ret	0
??$construct_at@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V12@@std@@YAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@QEAV10@$$QEAV10@@Z ENDP ; std::construct_at<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$move@AEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z PROC ; std::move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > &>, COMDAT

; 1513 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1514 : }

	ret	0
??$move@AEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT

; 1844 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [r8], rax

; 1845 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1846 :     }

	ret	0
??$_Emplace_back@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAX$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Emplace_back<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@@Z
_TEXT	SEGMENT
_Location$ = 64
??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@@Z PROC ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 330  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN64:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx+32]
	test	rcx, rcx
	je	SHORT $LN19@destroy_at

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN19@destroy_at:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN40@destroy_at
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN48@destroy_at

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN47@destroy_at

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN48@destroy_at:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN40@destroy_at:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 339  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN47@destroy_at:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN61@destroy_at:
??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@@Z ENDP ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 64
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
$LN53:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx+32]
	test	rcx, rcx
	je	SHORT $LN10@pair

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN10@pair:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN31@pair
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN39@pair

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN38@pair

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN39@pair:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN31@pair:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN38@pair:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN50@pair:
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>, COMDAT

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@AEBV12@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::_Construct_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *>, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * &>, COMDAT

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 464  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@QEAPEAU10@AEAPEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@$$T@std@@YAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAVNumber@Json@@$$T@std@@YAPEAVNumber@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVNumber@Json@@$$T@std@@YAPEAVNumber@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::Number *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVNumber@Json@@$$T@std@@YAPEAVNumber@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::Number *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAVNull@Json@@$$T@std@@YAPEAVNull@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVNull@Json@@$$T@std@@YAPEAVNull@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::Null *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVNull@Json@@$$T@std@@YAPEAVNull@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::Null *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAVBool@Json@@$$T@std@@YAPEAVBool@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVBool@Json@@$$T@std@@YAPEAVBool@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::Bool *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVBool@Json@@$$T@std@@YAPEAVBool@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::Bool *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAVObject@Json@@$$T@std@@YAPEAVObject@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVObject@Json@@$$T@std@@YAPEAVObject@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::Object *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVObject@Json@@$$T@std@@YAPEAVObject@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::Object *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAVArray@Json@@$$T@std@@YAPEAVArray@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVArray@Json@@$$T@std@@YAPEAVArray@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::Array *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVArray@Json@@$$T@std@@YAPEAVArray@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::Array *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$dead$ = 8
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<56>, COMDAT

; 113  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 114  : 
; 115  :     if constexpr (_Overflow_is_possible) {
; 116  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 117  :         if (_Count > _Max_possible) {
; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	mov	eax, 56					; 00000038H

; 123  : }

	ret	0
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<56>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > const >, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@YAPEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@YAPEAV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * const &>, COMDAT

; 470  : #if _HAS_CXX20
; 471  :     if (_STD is_constant_evaluated()) {
; 472  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 473  :     } else
; 474  : #endif // _HAS_CXX20
; 475  :     {
; 476  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 477  :     }
; 478  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Release, COMDAT

; 1849 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1850 :         return _Last;
; 1851 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1838 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN37:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1839 :         _STD _Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]

; 1102 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Uninitiali
$LL7@Uninitiali:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN25@Uninitiali

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN25@Uninitiali:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1102 :         for (; _First != _Last; ++_First) {

	add	rbx, 8
	cmp	rbx, rdi
	jne	SHORT $LL7@Uninitiali
$LN6@Uninitiali:

; 1840 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::~_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >, COMDAT

; 1833 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@QEAA@PEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@AEAV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Uninitialized_backout_al<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >, COMDAT

; 1172 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@Alloc_cons

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Alloc_cons:

; 1173 :             _Al.deallocate(_Ptr, 1);
; 1174 :         }
; 1175 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_Allocate, COMDAT

; 1166 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN24:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1167 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 1168 :         _Ptr = _Al.allocate(1);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rbx+8], rax

; 1169 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >, COMDAT

; 1160 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::max_size, COMDAT

; 1208 :         return (_STD min)(

	mov	rax, 329406144173384850			; 0492492492492492H

; 1209 :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alnode_traits::max_size(_Getal()));
; 1210 :     }

	ret	0
?max_size@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Get_first, COMDAT

; 1543 :         return *this;

	mov	rax, rcx

; 1544 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@2@$00@std@@QEBAAEBU?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$00@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_Keyval$ = 8
??R?$_Conditionally_enabled_hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$00@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Conditionally_enabled_hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,1>::operator(), COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2305 :         noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {

	mov	r8, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3390 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [rcx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN11@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rcx]
$LN11@operator:
	xor	edx, edx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2292 :     return _Fnv1a_append_bytes(

	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN33@operator
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	4
$LL29@operator:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [r8+rdx]
	inc	rdx
	xor	rax, rcx

; 2261 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	rdx, r9
	jb	SHORT $LL29@operator
$LN33@operator:

; 2306 :         return hash<_Kty>::_Do_hash(_Keyval);
; 2307 :     }

	ret	0
??R?$_Conditionally_enabled_hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$00@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Conditionally_enabled_hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T63 = 32
_Bucket_lo$1$ = 40
this$GSCopy$1$ = 48
tv1298 = 56
this$ = 128
_Buckets$ = 136
?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Forced_rehash, COMDAT

; 1727 :     void _Forced_rehash(size_type _Buckets) {

$LN350:
	push	r13
	sub	rsp, 112				; 00000070H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h

; 41   :     _BitScanReverse64(&_Result, _Value);

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1727 :     void _Forced_rehash(size_type _Buckets) {

	mov	QWORD PTR this$GSCopy$1$[rsp], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h

; 41   :     _BitScanReverse64(&_Result, _Value);

	bsr	rax, rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1735 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	r9d, 1
	mov	r13, rcx
	shlx	rax, r9, rax

; 1736 :         if (_Buckets > _Max_storage_buckets) {

	cmp	rdx, rax
	jbe	SHORT $LN8@Forced_reh

; 1737 :             _Xlength_error("invalid hash bucket count");

	lea	rcx, OFFSET FLAT:??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN8@Forced_reh:
	mov	QWORD PTR [rsp+144], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h

; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	rax, QWORD PTR [rdx-1]
	mov	QWORD PTR [rsp+104], rbp

; 25   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	rax, r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 1129 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead, nullptr);

	mov	rbp, QWORD PTR [rcx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h

; 41   :     _BitScanReverse64(&_Result, _Value);

	bsr	rax, rax
	mov	QWORD PTR [rsp+96], rsi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1747 :         _Vec._Assign_grow(_Buckets << 1, _End);

	mov	r8, rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xbit_ops.h

; 53   :     return 1 + _Floor_of_log_2(_Value - 1);

	inc	eax
	mov	QWORD PTR [rsp+88], rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1744 :         _Buckets                       = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	shlx	rbx, r9, rax
	mov	QWORD PTR [rsp+80], r12

; 1747 :         _Vec._Assign_grow(_Buckets << 1, _End);

	lea	r12, QWORD PTR [rcx+24]
	mov	rcx, r12
	mov	QWORD PTR tv1298[rsp], r12
	lea	rdx, QWORD PTR [rbx+rbx]
	call	?_Assign_grow@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEAAX_KV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@@Z ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::_Assign_grow

; 1748 :         _Mask   = _Buckets - 1;
; 1749 :         _Maxidx = _Buckets;

	mov	QWORD PTR [r13+56], rbx
	lea	rax, QWORD PTR [rbx-1]
	mov	QWORD PTR [r13+48], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 1121 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rdi, QWORD PTR [r13+8]

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rdi, QWORD PTR [rdi]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1756 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	rsi, rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	rdi, rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1756 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	je	$LN345@Forced_reh
	mov	QWORD PTR [rsp+72], r14
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	mov	QWORD PTR [rsp+64], r15
	mov	r10, 1099511628211			; 00000100000001b3H
$LL4@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	r9, QWORD PTR [rdi+40]

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR [rdi+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	rsi, QWORD PTR [rsi]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3390 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r14, QWORD PTR [rdi+32]

; 453  :         return _Myres > _Small_string_capacity;

	mov	QWORD PTR $T63[rsp], r9

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN320@Forced_reh

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdi+16]
$LN320@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	xor	ecx, ecx

; 2292 :     return _Fnv1a_append_bytes(

	mov	rdx, rax

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r14, r14
	je	SHORT $LN107@Forced_reh
	npad	7
$LL108@Forced_reh:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	xor	rdx, rax

; 2261 :         _Val *= _FNV_prime;

	imul	rdx, r10
	cmp	rcx, r14
	jb	SHORT $LL108@Forced_reh
	mov	QWORD PTR $T63[rsp], r9
$LN107@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 860  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r10, QWORD PTR [r13+48]
	and	r10, rdx

; 1757 :             ++_Next_inserted;
; 1758 : 
; 1759 :             auto& _Inserted_key     = _Traits::_Kfn(*_Inserted);
; 1760 :             const size_type _Bucket = bucket(_Inserted_key);
; 1761 : 
; 1762 :             // _Bucket_lo and _Bucket_hi are the *inclusive* range of elements in the bucket, or _Unchecked_end() if
; 1763 :             // the bucket is empty; if !_Standard then [_Bucket_lo, _Bucket_hi] is a sorted range.
; 1764 :             _Unchecked_iterator& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1];

	shl	r10, 4
	add	r10, QWORD PTR [r12]
	mov	QWORD PTR _Bucket_lo$1$[rsp], r10

; 1765 :             _Unchecked_iterator& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1];
; 1766 : 
; 1767 :             if (_Bucket_lo == _End) {

	cmp	QWORD PTR [r10], rbp
	jne	SHORT $LN9@Forced_reh

; 1768 :                 // The bucket was empty, set it to the inserted element.
; 1769 :                 _Bucket_lo = _Inserted;

	mov	QWORD PTR [r10], rdi

; 1770 :                 _Bucket_hi = _Inserted;
; 1771 :                 continue;

	jmp	$LN347@Forced_reh
$LN9@Forced_reh:

; 1772 :             }
; 1773 : 
; 1774 :             // Search the bucket for the insertion location and move element if necessary.
; 1775 :             _Unchecked_const_iterator _Insert_before = _Bucket_hi;

	mov	rbx, QWORD PTR [r10+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+40], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 42   :         return _Ptr->_Myval;

	lea	rdx, QWORD PTR [rbx+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN212@Forced_reh

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN212@Forced_reh:

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [rdi+16]

; 453  :         return _Myres > _Small_string_capacity;

	mov	r12, r14
	mov	r13, r9

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN319@Forced_reh

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi+16]
$LN319@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	r14, rax
	jne	SHORT $LN10@Forced_reh

; 605  :         return false;
; 606  :     }
; 607  : 
; 608  :     if (_Left_size == 0u) {

	test	r14, r14
	je	$LN315@Forced_reh

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, r14
	call	memcmp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1776 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	mov	r10, QWORD PTR _Bucket_lo$1$[rsp]

; 150  :         return !static_cast<bool>(_Mypair._Myval2._Get_first()(_Keyval1, _Keyval2));

	mov	r9, r13
	mov	QWORD PTR $T63[rsp], r13
	mov	r14, r12
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1776 :             if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*_Insert_before))) {

	je	$LN315@Forced_reh
$LN10@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 72   :         return _Ptr == _Right._Ptr;

	mov	r12, QWORD PTR [r10]
	cmp	r12, rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1791 :                 if (_Bucket_lo == _Insert_before) {

	je	SHORT $LN291@Forced_reh
	npad	6
$LL7@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+40], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 42   :         return _Ptr->_Myval;

	lea	rdx, QWORD PTR [rbx+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN32@Forced_reh

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN32@Forced_reh:

; 444  :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR [rdi+16]

; 445  :         if (_Large_mode_engaged()) {

	cmp	r9, 15
	jbe	SHORT $LN39@Forced_reh

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi+16]
$LN39@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	r14, rax
	jne	SHORT $LN316@Forced_reh

; 605  :         return false;
; 606  :     }
; 607  : 
; 608  :     if (_Left_size == 0u) {

	test	r14, r14
	je	SHORT $LN292@Forced_reh

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, r14
	call	memcmp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1801 :                 if (!_Traitsobj(_Inserted_key, _Traits::_Kfn(*--_Insert_before))) {

	je	SHORT $LN292@Forced_reh
	mov	r9, QWORD PTR $T63[rsp]
$LN316@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	r12, rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1791 :                 if (_Bucket_lo == _Insert_before) {

	jne	SHORT $LL7@Forced_reh
	mov	r10, QWORD PTR _Bucket_lo$1$[rsp]
$LN291@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 484  :         const auto _First_prev  = _First->_Prev;

	mov	rdx, QWORD PTR [rdi+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1797 :                     _Bucket_lo = _Inserted;

	mov	r13, QWORD PTR this$GSCopy$1$[rsp]
	mov	r12, QWORD PTR tv1298[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 485  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [rdx], rsi

; 486  :         const auto _Last_prev   = _Last->_Prev;

	mov	rcx, QWORD PTR [rsi+8]

; 487  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [rcx], rbx

; 488  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [rbx+8]

; 489  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdi

; 490  : 
; 491  :         // fixup the _Prev values
; 492  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rbx+8], rcx

; 493  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rsi+8], rdx

; 494  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdi+8], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1797 :                     _Bucket_lo = _Inserted;

	mov	QWORD PTR [r10], rdi
	jmp	SHORT $LN2@Forced_reh
$LN292@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	r8, QWORD PTR [rbx]

; 484  :         const auto _First_prev  = _First->_Prev;

	mov	rdx, QWORD PTR [rdi+8]

; 494  :         _First->_Prev  = _Before_prev;

	mov	r13, QWORD PTR this$GSCopy$1$[rsp]
	mov	r12, QWORD PTR tv1298[rsp]
	mov	QWORD PTR [rdx], rsi
	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx], r8
	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [r8+8], rcx
	mov	QWORD PTR [rsi+8], rdx
	mov	QWORD PTR [rdi+8], rax
	jmp	SHORT $LN2@Forced_reh
$LN315@Forced_reh:

; 50   :         _Ptr = _Ptr->_Next;

	mov	r8, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1780 :                 if (_Insert_before != _Inserted) { // avoid splice on element already in position

	cmp	r8, rdi
	je	SHORT $LN284@Forced_reh
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 484  :         const auto _First_prev  = _First->_Prev;

	mov	rdx, QWORD PTR [rdi+8]

; 485  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [rdx], rsi

; 486  :         const auto _Last_prev   = _Last->_Prev;

	mov	rcx, QWORD PTR [rsi+8]

; 487  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [rcx], r8

; 488  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [r8+8]

; 489  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdi

; 490  : 
; 491  :         // fixup the _Prev values
; 492  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [r8+8], rcx

; 493  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [rsi+8], rdx

; 494  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdi+8], rax
$LN284@Forced_reh:
	mov	r13, QWORD PTR this$GSCopy$1$[rsp]
	mov	r12, QWORD PTR tv1298[rsp]
$LN347@Forced_reh:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1756 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	mov	QWORD PTR [r10+8], rdi
$LN2@Forced_reh:
	mov	rdi, rsi
	mov	rax, -3750763034362895579		; cbf29ce484222325H
	mov	r10, 1099511628211			; 00000100000001b3H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	rsi, rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1756 :         for (_Unchecked_iterator _Next_inserted = _Inserted; _Inserted != _End; _Inserted = _Next_inserted) {

	jne	$LL4@Forced_reh
	mov	r15, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
$LN345@Forced_reh:
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+144]
	mov	r12, QWORD PTR [rsp+80]

; 1802 :                     // Found insertion point, move the element here, bucket bounds are already okay.
; 1803 :                     ++_Insert_before;
; 1804 :                     // Element can't be already in position here because all elements we're inserting are after all
; 1805 :                     // the elements already in buckets, and *_Insert_before isn't the highest element in the bucket.
; 1806 :                     _Mylist::_Scary_val::_Unchecked_splice(_Insert_before._Ptr, _Inserted._Ptr, _Next_inserted._Ptr);
; 1807 :                     break;
; 1808 :                 }
; 1809 :             }
; 1810 :         }
; 1811 : 
; 1812 :         _Guard._Target = nullptr;
; 1813 : 
; 1814 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1815 :         _Stl_internal_check_container_invariants();
; 1816 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1817 :     }

	add	rsp, 112				; 00000070H
	pop	r13
	ret	0
$LN346@Forced_reh:
?_Forced_rehash@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_For_size$ = 16
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Desired_grow_bucket_count, COMDAT

; 1707 :         const size_type _Old_buckets = bucket_count();

	mov	r8, QWORD PTR [rcx+56]

; 1703 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	vxorps	xmm0, xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN16@Desired_gr
	vcvtsi2ss xmm0, xmm0, rdx
	jmp	SHORT $LN17@Desired_gr
$LN16@Desired_gr:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	vcvtsi2ss xmm0, xmm0, rax
	vaddss	xmm0, xmm0, xmm0
$LN17@Desired_gr:
	vdivss	xmm0, xmm0, DWORD PTR [rcx]
	vxorps	xmm1, xmm1, xmm1
	vroundss xmm1, xmm1, xmm0, 2
	vmovss	xmm0, DWORD PTR __real@5f000000
	xor	eax, eax
	vcomiss	xmm1, xmm0
	jb	SHORT $LN15@Desired_gr
	vsubss	xmm1, xmm1, xmm0
	vcomiss	xmm1, xmm0
	jae	SHORT $LN15@Desired_gr
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
$LN15@Desired_gr:
	vcvttss2si rcx, xmm1
	add	rcx, rax

; 1708 :         const size_type _Req_buckets = (_STD max)(_Min_buckets, _Min_load_factor_buckets(_For_size));

	mov	eax, 8
	cmp	rcx, rax
	cmova	rax, rcx

; 1709 :         if (_Old_buckets >= _Req_buckets) {

	cmp	r8, rax
	jb	SHORT $LN2@Desired_gr

; 1710 :             // we already have enough buckets so there's no need to change the count
; 1711 :             return _Old_buckets;

	mov	rax, r8

; 1715 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1716 :             return _Old_buckets * 8;
; 1717 :         }
; 1718 : 
; 1719 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1720 :         return _Req_buckets;
; 1721 :     }

	ret	0
$LN2@Desired_gr:

; 1712 :         }
; 1713 : 
; 1714 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	r8, 512					; 00000200H
	jae	SHORT $LN3@Desired_gr
	lea	rcx, QWORD PTR [r8*8]
	cmp	rcx, rax
	cmovae	rax, rcx
$LN3@Desired_gr:

; 1715 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1716 :             return _Old_buckets * 8;
; 1717 :         }
; 1718 : 
; 1719 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1720 :         return _Req_buckets;
; 1721 :     }

	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?max_load_factor@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::max_load_factor, COMDAT

; 916  :         return _Max_bucket_size();

	vmovss	xmm0, DWORD PTR [rcx]

; 917  :     }

	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::bucket_count, COMDAT

; 851  :         return _Maxidx;

	mov	rax, QWORD PTR [rcx+56]

; 852  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size, COMDAT

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal, COMDAT

; 2231 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2232 :     }

	ret	0
?_Getal@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\vector
;	COMDAT ?capacity@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::capacity, COMDAT

; 1923 :         auto& _My_data = _Mypair._Myval2;
; 1924 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1925 :     }

	ret	0
?capacity@?$vector@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 64
_Count$ = 72
?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z PROC ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocate, COMDAT

; 988  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN27:
	sub	rsp, 56					; 00000038H

; 117  :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN23@allocate

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN8@allocate

; 228  :         return nullptr;

	xor	eax, eax

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN8@allocate:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN10@allocate

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN23@allocate

; 136  :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	jne	SHORT $LN16@allocate
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN16@allocate:

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 989  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 990  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 991  :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN10@allocate:
	add	rsp, 56					; 00000038H

; 136  :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN23@allocate:

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN25@allocate:
?allocate@?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@QEAAPEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@_K@Z ENDP ; std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
_TEXT	SEGMENT
this$ = 64
_Off$dead$ = 72
_Ptr$dead$ = 80
_Count$ = 88
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 1730 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN97:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 1731 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 1732 :         _Mypair._Myval2._Check_offset(_Off);
; 1733 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [rcx+16]
	mov	rsi, rcx

; 1734 : 
; 1735 :         // We can't check for overlapping ranges when constant evaluated since comparison of pointers into string
; 1736 :         // literals is unspecified, so always reallocate and copy to the new buffer if constant evaluated.
; 1737 : #if _HAS_CXX20
; 1738 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();

	mov	rcx, QWORD PTR [rcx+24]
	mov	rdi, r9
	mov	rax, rcx
	sub	rax, r8
	cmp	r9, rax
	ja	$LN2@insert
	mov	QWORD PTR [rsp+64], rbx

; 1739 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1740 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
; 1741 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1742 : 
; 1743 :         if (_Check_overlap) {
; 1744 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1745 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [r8+r9]
	mov	QWORD PTR [rsp+72], rbp

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rbx, rsi

; 1734 : 
; 1735 :         // We can't check for overlapping ranges when constant evaluated since comparison of pointers into string
; 1736 :         // literals is unspecified, so always reallocate and copy to the new buffer if constant evaluated.
; 1737 : #if _HAS_CXX20
; 1738 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();

	mov	QWORD PTR [rsp+80], r14

; 1739 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1740 :         const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
; 1741 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1742 : 
; 1743 :         if (_Check_overlap) {
; 1744 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1745 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rsi+16], rax

; 436  :         if (_Large_mode_engaged()) {

	cmp	rcx, 15
	jbe	SHORT $LN12@insert

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rsi]
$LN12@insert:

; 1746 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 1747 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 1748 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 1749 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 1750 :             size_type _Ptr_shifted_after;
; 1751 :             if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {

	lea	rbp, OFFSET FLAT:??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@
	lea	rax, QWORD PTR [r9+rbp]
	cmp	rax, rbx
	jbe	SHORT $LN5@insert
	lea	rax, QWORD PTR [r8+rbx]
	cmp	rbp, rax
	ja	SHORT $LN5@insert

; 1754 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

	cmp	rbx, rbp
	ja	SHORT $LN6@insert

; 1755 :                 _Ptr_shifted_after = 0;

	xor	r14d, r14d

; 1756 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

	jmp	SHORT $LN7@insert
$LN6@insert:

; 1757 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

	mov	r14, rbx
	sub	r14, rbp
	jmp	SHORT $LN7@insert
$LN5@insert:

; 1752 :                 // inserted content is before the shifted region, or does not alias
; 1753 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

	mov	r14, rdi
$LN7@insert:

; 1758 :             }
; 1759 : 
; 1760 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	r8
	lea	rcx, QWORD PTR [rbx+r9]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 174  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	call	memmove

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r14
	mov	rdx, rbp
	mov	rcx, rbx
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1762 :             _Traits::copy(

	mov	r8, rdi
	lea	rdx, QWORD PTR [r14+rdi]
	sub	r8, r14
	lea	rcx, QWORD PTR [rbx+r14]
	add	rdx, rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1764 :             return *this;

	mov	r14, QWORD PTR [rsp+80]
	mov	rax, rsi
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 1768 :             _Count,
; 1769 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 1770 :                 const _Elem* const _Ptr, const size_type _Count) _STATIC_LAMBDA {
; 1771 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 1772 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 1773 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 1774 :             },
; 1775 :             _Off, _Ptr, _Count);
; 1776 :     }

	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@insert:

; 1765 :         }
; 1766 : 
; 1767 :         return _Reallocate_grow_by(

	mov	rdx, rdi
	mov	QWORD PTR [rsp+40], rdi
	mov	rcx, rsi
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>

; 1768 :             _Count,
; 1769 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 1770 :                 const _Elem* const _Ptr, const size_type _Count) _STATIC_LAMBDA {
; 1771 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 1772 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 1773 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 1774 :             },
; 1775 :             _Off, _Ptr, _Count);
; 1776 :     }

	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Off$dead$ = 80
_Ptr$dead$ = 88
_Count$ = 96
??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator(), COMDAT

; 1770 :                 const _Elem* const _Ptr, const size_type _Count) _STATIC_LAMBDA {

$LN51:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rbx, QWORD PTR _Count$[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1770 :                 const _Elem* const _Ptr, const size_type _Count) _STATIC_LAMBDA {

	mov	rdi, rdx
	mov	rbp, r8
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	lea	rdx, OFFSET FLAT:??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@
	mov	r8, rbx
	mov	rcx, rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1770 :                 const _Elem* const _Ptr, const size_type _Count) _STATIC_LAMBDA {

	mov	rsi, r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1773 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	r8, QWORD PTR [rsi+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 1773 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	rcx, QWORD PTR [rdi+rbx]

; 1774 :             },

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	jmp	memcpy
??R<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV23@_KQEBD0@Z@QEBA@QEAD10010@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 64
__flags$dead$ = 72
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::`scalar deleting destructor', COMDAT
$LN60:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3426 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx+32]
	test	rcx, rcx
	je	SHORT $LN16@scalar

; 3309 :         delete _Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	edx, 1
	call	QWORD PTR [rax]
$LN16@scalar:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

	mov	rdx, QWORD PTR [rbx+24]

; 3083 :         if (_My_data._Large_mode_engaged()) {

	cmp	rdx, 15
	jbe	SHORT $LN37@scalar
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	inc	rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN45@scalar

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rcx, rax
	sub	rcx, 8
	cmp	rcx, 31
	ja	SHORT $LN44@scalar

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN45@scalar:

; 289  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN37@scalar:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3090 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0
	mov	rax, rbx

; 3091 :         _My_data._Myres  = _Small_string_capacity;

	mov	QWORD PTR [rbx+24], 15

; 3092 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3093 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN44@scalar:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN57@scalar:
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VValue@Json@@@std@@@std@@YA$$QEAU?$default_delete@VValue@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@VValue@Json@@@std@@@std@@YA$$QEAU?$default_delete@VValue@Json@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<Json::Value> >, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@U?$default_delete@VValue@Json@@@std@@@std@@YA$$QEAU?$default_delete@VValue@Json@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<Json::Value> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ??$?0U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VValue@Json@@@1@$$QEAPEAVValue@Json@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VValue@Json@@@1@$$QEAPEAVValue@Json@@@Z PROC ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Value>,Json::Value *>, COMDAT

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@@?$_Compressed_pair@U?$default_delete@VValue@Json@@@std@@PEAVValue@Json@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@VValue@Json@@@1@$$QEAPEAVValue@Json@@@Z ENDP ; std::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1>::_Compressed_pair<std::default_delete<Json::Value>,Json::Value *,1><std::default_delete<Json::Value>,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEAPEAVObject@Json@@@std@@YAAEAPEAVObject@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVObject@Json@@@std@@YAAEAPEAVObject@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Object * &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEAPEAVObject@Json@@@std@@YAAEAPEAVObject@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Object * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@QEAU10@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
<_Args_1>$ = 24
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@QEAU10@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z PROC ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	r9d, r9d
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], r9

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], r9

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rcx], ymm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	BYTE PTR [rdx], r9b
	mov	QWORD PTR [rdx+16], r9
	mov	QWORD PTR [rdx+24], 15
	mov	rax, QWORD PTR [r8]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8], r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx+32], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
	vzeroupper

; 464  : }

	ret	0
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@0@QEAU10@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@0@@Z ENDP ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEAPEAVArray@Json@@@std@@YAAEAPEAVArray@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVArray@Json@@@std@@YAAEAPEAVArray@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Array * &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEAPEAVArray@Json@@@std@@YAAEAPEAVArray@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Array * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEAPEAVBool@Json@@@std@@YAAEAPEAVBool@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVBool@Json@@@std@@YAAEAPEAVBool@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Bool * &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEAPEAVBool@Json@@@std@@YAAEAPEAVBool@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Bool * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEAPEAVNull@Json@@@std@@YAAEAPEAVNull@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVNull@Json@@@std@@YAAEAPEAVNull@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Null * &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEAPEAVNull@Json@@@std@@YAAEAPEAVNull@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Null * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEAPEAVNumber@Json@@@std@@YAAEAPEAVNumber@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVNumber@Json@@@std@@YAAEAPEAVNumber@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Number * &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEAPEAVNumber@Json@@@std@@YAAEAPEAVNumber@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Number * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >, COMDAT

; 1525 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1526 : }

	ret	0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@AEBV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@AEBV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z PROC ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>, COMDAT

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 464  : }

	ret	0
??$construct_at@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@AEBV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@QEAV10@AEBV10@@Z ENDP ; std::construct_at<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * const &>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@AEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@YAAEBQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEBQEAU12@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEBQEAU12@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * const &>, COMDAT

; 463  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 464  : }

	ret	0
??$construct_at@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@AEBQEAU12@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> *,std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$dead$ = 120
<_Args_1>$dead$ = 128
<_Args_2>$ = 136
??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>, COMDAT

; 3024 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN190:
	push	rbx
	push	rbp
	push	rsi
	push	r12
	sub	rsp, 56					; 00000038H

; 3025 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3026 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3027 :         auto& _My_data            = _Mypair._Myval2;
; 3028 :         const size_type _Old_size = _My_data._Mysize;

	mov	rbp, QWORD PTR [rcx+16]

; 3029 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	r12, QWORD PTR <_Args_2>$[rsp]
	mov	rax, rbx
	sub	rax, rbp
	mov	rsi, rcx
	cmp	rax, rdx
	jb	$LN187@Reallocate

; 3031 :         }
; 3032 : 
; 3033 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	QWORD PTR [rsp+112], rdi
	mov	QWORD PTR [rsp+120], r14
	lea	r14, QWORD PTR [rdx+rbp]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rdx, r14
	mov	QWORD PTR [rsp+48], r15

; 3034 :         const size_type _Old_capacity = _My_data._Myres;

	mov	r15, QWORD PTR [rcx+24]

; 2978 :         const size_type _Masked = _Requested | _Alloc_mask;

	or	rdx, 15
	cmp	rdx, rbx

; 2979 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN185@Reallocate

; 2980 :             return _Max;
; 2981 :         }
; 2982 : 
; 2983 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, r15
	mov	rax, rbx
	shr	rcx, 1
	sub	rax, rcx
	cmp	r15, rax
	ja	SHORT $LN185@Reallocate

; 2984 :             return _Max;
; 2985 :         }
; 2986 : 
; 2987 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r15+rcx]
	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax

; 825  :         ++_Capacity; // Take null terminator into consideration

	lea	rcx, QWORD PTR [rbx+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 227  :     if (_Bytes == 0) {

	test	rcx, rcx
	jne	SHORT $LN28@Reallocate

; 228  :         return nullptr;

	xor	edi, edi
	jmp	SHORT $LN27@Reallocate
$LN28@Reallocate:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN30@Reallocate

; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 185  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN188@Reallocate
	jmp	SHORT $LN35@Reallocate
$LN185@Reallocate:

; 136  :         return ::operator new(_Bytes);

	mov	rax, -9223372036854775808		; 8000000000000000H
	add	rax, 39					; 00000027H
$LN35@Reallocate:
	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN86@Reallocate

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN27@Reallocate
$LN30@Reallocate:

; 136  :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN27@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3041 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], r14

; 3042 :         _My_data._Myres       = _New_capacity;

	lea	r14, QWORD PTR [r12+rdi]
	mov	QWORD PTR [rsi+24], rbx

; 3043 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3044 :         if (_Old_capacity > _Small_string_capacity) {

	mov	r8, r12
	lea	rdx, OFFSET FLAT:??_C@_0BI@OEGKDOAJ@Invalid?5object?5syntax?3?5@
	mov	rcx, rdi
	cmp	r15, 15
	jbe	SHORT $LN3@Reallocate

; 3045 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
	lea	r8, QWORD PTR [rbp+1]
	mov	rdx, rbx
	mov	rcx, r14
	call	memcpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	lea	rdx, QWORD PTR [r15+1]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN87@Reallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	sub	rbx, rax
	sub	rbx, 8
	cmp	rbx, 31
	ja	SHORT $LN86@Reallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rax
$LN87@Reallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3049 :         } else {

	jmp	SHORT $LN107@Reallocate
$LN86@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp__invoke_watson
	int	3
$LN3@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 121  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	memcpy
	lea	r8, QWORD PTR [rbp+1]
	mov	rdx, rsi
	mov	rcx, r14
	call	memcpy
$LN107@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3055 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	r14, QWORD PTR [rsp+120]
	mov	rdi, QWORD PTR [rsp+112]
	mov	r15, QWORD PTR [rsp+48]

; 3056 :     }

	add	rsp, 56					; 00000038H
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN187@Reallocate:

; 3030 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN188@Reallocate:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 186  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN184@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@_KQEBD0@Z@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??insert@01@QEAAAEAV01@0QEBD0@Z@_KPEBD3@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert'::`2'::<lambda_1>,unsigned __int64,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::max_size, COMDAT

; 272  :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 273  :             static_cast<size_type>(_STD _Max_limit<difference_type>()), _Aliter_traits::max_size(_Mypair._Get_first()));
; 274  :     }

	ret	0
?max_size@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T4 = 32
this$ = 64
??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Clear_guard::~_Clear_guard, COMDAT

; 487  :         ~_Clear_guard() {

$LN88:
	push	rdi
	sub	rsp, 48					; 00000030H

; 488  :             if (_Target) {

	mov	rdi, QWORD PTR [rcx]
	test	rdi, rdi
	je	$LN5@Clear_guar

; 1163 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rdi+16]

; 1164 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	$LN5@Clear_guar

; 1165 :             return;
; 1166 :         }
; 1167 : 
; 1168 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1169 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1170 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1171 :             // as many buckets as elements, remove element-by-element.
; 1172 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rdi+56]
	shr	rax, 3
	mov	QWORD PTR [rsp+80], rsi
	mov	rsi, QWORD PTR [rdi+8]
	cmp	rax, rcx
	jbe	SHORT $LN7@Clear_guar

; 1173 :                 const auto _Head = _List._Mypair._Myval2._Myhead;
; 1174 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	rdx, QWORD PTR [rsi]
	mov	r8, rsi
	mov	rcx, rdi
	mov	rsi, QWORD PTR [rsp+80]

; 489  :                 _Target->clear();
; 490  :             }
; 491  :         }

	add	rsp, 48					; 00000030H
	pop	rdi

; 1174 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_erase
$LN7@Clear_guar:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rsi, QWORD PTR [rsi]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rsi, rsi
	je	SHORT $LN77@Clear_guar
	mov	QWORD PTR [rsp+72], rbx
	npad	11
$LL16@Clear_guar:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rsi]

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rsi+16]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rsi, rbx
	test	rbx, rbx
	jne	SHORT $LL16@Clear_guar
	mov	rbx, QWORD PTR [rsp+72]
$LN77@Clear_guar:

; 1508 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1181 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T4[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 1508 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1509 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rax+8], rax

; 1510 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rdi+16], 0

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rdi+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1181 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rdi+32]
	mov	rcx, QWORD PTR [rdi+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T4[rsp], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1181 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
	mov	rsi, QWORD PTR [rsp+80]
$LN5@Clear_guar:

; 489  :                 _Target->clear();
; 490  :             }
; 491  :         }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??1_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Clear_guard::~_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??0_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Target_$ = 16
??0_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Clear_guard::_Clear_guard, COMDAT

; 482  :         explicit _Clear_guard(_Hash* const _Target_) : _Target(_Target_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0_Clear_guard@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@QEAV12@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Clear_guard::_Clear_guard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator==, COMDAT

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 73   :     }

	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator--, COMDAT

; 61   :         _Ptr = _Ptr->_Prev;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+8]

; 62   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 63   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator++, COMDAT

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 51   :         return *this;

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator*, COMDAT

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::operator++, COMDAT

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]

; 107  :         _Mybase::operator++();
; 108  :         return *this;

	mov	rax, rcx

; 50   :         _Ptr = _Ptr->_Next;

	mov	QWORD PTR [rcx], rdx

; 109  :     }

	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::operator*, COMDAT

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 16

; 99   :         return const_cast<reference>(_Mybase::operator*());
; 100  :     }

	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@QEAU32@00@Z
_TEXT	SEGMENT
_Before$ = 8
_First$ = 16
_Last$ = 24
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@QEAU32@00@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Unchecked_splice, COMDAT

; 479  :         // splice [_First, _Last) before _Before; returns _Last
; 480  :         _STL_INTERNAL_CHECK(_Before != _First && _Before != _Last && _First != _Last);
; 481  :         // 3 reads and 6 writes
; 482  : 
; 483  :         // fixup the _Next values
; 484  :         const auto _First_prev  = _First->_Prev;

	mov	r10, QWORD PTR [rdx+8]

; 485  :         _First_prev->_Next      = _Last;

	mov	QWORD PTR [r10], r8

; 486  :         const auto _Last_prev   = _Last->_Prev;

	mov	r9, QWORD PTR [r8+8]

; 487  :         _Last_prev->_Next       = _Before;

	mov	QWORD PTR [r9], rcx

; 488  :         const auto _Before_prev = _Before->_Prev;

	mov	rax, QWORD PTR [rcx+8]

; 489  :         _Before_prev->_Next     = _First;

	mov	QWORD PTR [rax], rdx

; 490  : 
; 491  :         // fixup the _Prev values
; 492  :         _Before->_Prev = _Last_prev;

	mov	QWORD PTR [rcx+8], r9

; 493  :         _Last->_Prev   = _First_prev;

	mov	QWORD PTR [r8+8], r10

; 494  :         _First->_Prev  = _Before_prev;

	mov	QWORD PTR [rdx+8], rax

; 495  : 
; 496  :         return _Last;

	mov	rax, r8

; 497  :     }

	ret	0
?_Unchecked_splice@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@SAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@QEAU32@00@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::max_size, COMDAT

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 329406144173384850			; 0492492492492492H

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Getal, COMDAT

; 1867 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1868 :     }

	ret	0
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@AEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEBAAEBU?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEBAAEBU?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Get_first, COMDAT

; 1543 :         return *this;

	mov	rax, rcx

; 1544 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@M$00@std@@QEBAAEBU?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Max_bucket_size, COMDAT

; 1824 :         return _Traitsobj._Get_max_bucket_size();

	mov	rax, rcx

; 1825 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBAAEBMXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_For_size$ = 16
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Min_load_factor_buckets, COMDAT

; 1702 :         // returns the minimum number of buckets necessary for the elements in _List
; 1703 :         return static_cast<size_type>(_CSTD ceilf(static_cast<float>(_For_size) / max_load_factor()));

	vxorps	xmm0, xmm0, xmm0
	test	rdx, rdx
	js	SHORT $LN8@Min_load_f
	vcvtsi2ss xmm0, xmm0, rdx
	jmp	SHORT $LN9@Min_load_f
$LN8@Min_load_f:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	vcvtsi2ss xmm0, xmm0, rax
	vaddss	xmm0, xmm0, xmm0
$LN9@Min_load_f:
	vdivss	xmm0, xmm0, DWORD PTR [rcx]
	vxorps	xmm1, xmm1, xmm1
	vroundss xmm1, xmm1, xmm0, 2
	vmovss	xmm0, DWORD PTR __real@5f000000
	xor	ecx, ecx
	vcomiss	xmm1, xmm0
	jb	SHORT $LN7@Min_load_f
	vsubss	xmm1, xmm1, xmm0
	vcomiss	xmm1, xmm0
	jae	SHORT $LN7@Min_load_f
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN7@Min_load_f:
	vcvttss2si rax, xmm1
	add	rax, rcx

; 1704 :     }

	ret	0
?_Min_load_factor_buckets@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@IEBA_K_K@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Keyval$ = 16
?bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::bucket, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15

; 3390 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r10, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN17@bucket

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN17@bucket:
	xor	r9d, r9d
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2292 :     return _Fnv1a_append_bytes(

	mov	r8, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r10, r10
	je	SHORT $LN28@bucket
	mov	r11, 1099511628211			; 00000100000001b3H
	npad	6
$LL35@bucket:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+r9]
	inc	r9
	xor	r8, rax

; 2261 :         _Val *= _FNV_prime;

	imul	r8, r11
	cmp	r9, r10
	jb	SHORT $LL35@bucket
$LN28@bucket:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 860  :         return _Traitsobj(_Keyval) & _Mask;

	mov	rax, QWORD PTR [rcx+48]
	and	rax, r8

; 861  :     }

	ret	0
?bucket@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_end, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 816  :         return _List._Unchecked_end();

	mov	rax, rdx

; 817  :     }

	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_begin, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 1121 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx+8]

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 808  :         return _List._Unchecked_begin();

	mov	rax, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 809  :     }

	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility
;	COMDAT ??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
this$dead$ = 48
_Left$ = 56
_Right$ = 64
??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator(), COMDAT

; 604  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

$LN34:
	sub	rsp, 40					; 00000028H
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [r8+24], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility

; 604  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

	mov	r9, r8
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rcx, QWORD PTR [r8+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility

; 604  :         noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {

	mov	rax, rdx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN11@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r8]
$LN11@operator:

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN18@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN18@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	r8, rcx
	je	SHORT $LN25@operator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility

; 605  :         return _Left == _Right;

	xor	al, al

; 606  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN25@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 608  :     if (_Left_size == 0u) {

	test	r8, r8
	jne	SHORT $LN26@operator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility

; 605  :         return _Left == _Right;

	mov	al, 1

; 606  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN26@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rdx, r9
	mov	rcx, rax
	call	memcmp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	sete	al
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xutility

; 606  :     }

	add	rsp, 40					; 00000028H
	ret	0
??R?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Do_hash@?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_Keyval$ = 8
?_Do_hash@?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Do_hash, COMDAT

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15

; 3389 :     _NODISCARD static size_t _Do_hash(const basic_string<_Elem, char_traits<_Elem>, _Alloc>& _Keyval) noexcept {

	mov	r8, rcx

; 3390 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [rcx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@Do_hash

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rcx]
$LN8@Do_hash:
	xor	edx, edx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2292 :     return _Fnv1a_append_bytes(

	mov	rax, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN30@Do_hash
	mov	r10, 1099511628211			; 00000100000001b3H
	npad	4
$LL26@Do_hash:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	ecx, BYTE PTR [r8+rdx]
	inc	rdx
	xor	rax, rcx

; 2261 :         _Val *= _FNV_prime;

	imul	rax, r10
	cmp	rdx, r9
	jb	SHORT $LL26@Do_hash
$LN30@Do_hash:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3391 :     }

	ret	0
?_Do_hash@?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::_Do_hash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first, COMDAT

; 1543 :         return *this;

	mov	rax, rcx

; 1544 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::_Vector_val<std::_Simple_types<std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?release@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAVValue@Json@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAVValue@Json@@XZ PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::release, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory

; 3466 :     }

	ret	0
?release@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAPEAVValue@Json@@XZ ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ PROC ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::get_deleter, COMDAT

; 3441 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3442 :     }

	ret	0
?get_deleter@?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@std@@QEAAAEAU?$default_delete@VValue@Json@@@2@XZ ENDP ; std::unique_ptr<Json::Value,std::default_delete<Json::Value> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3258 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

$LN31:
	sub	rsp, 40					; 00000028H

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN8@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN8@operator:

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rcx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN15@operator

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN15@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	r8, rax
	je	SHORT $LN22@operator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3259 :     return _Left._Equal(_Right);

	xor	al, al

; 3260 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN22@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 608  :     if (_Left_size == 0u) {

	test	r8, r8
	jne	SHORT $LN23@operator
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3259 :     return _Left._Equal(_Right);

	mov	al, 1

; 3260 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN23@operator:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	sete	al
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3260 : }

	add	rsp, 40					; 00000028H
	ret	0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,0>, COMDAT
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 517  :     size_type _Mysize = 0; // current length of string (size)

	xor	r9d, r9d
	vpxor	xmm0, xmm0, xmm0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	vmovups	XMMWORD PTR [rcx], xmm0

; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	QWORD PTR [rcx+16], r9

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	QWORD PTR [rcx+24], r9

; 1286 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rcx], ymm0
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	BYTE PTR [rdx], r9b
	mov	QWORD PTR [rdx+16], r9
	mov	QWORD PTR [rdx+24], 15
	mov	rax, QWORD PTR [r8]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8], r9
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 1536 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx+32], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility

; 275  :     }

	mov	rax, rcx
	vzeroupper
	ret	0
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
;	COMDAT ??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z PROC ; std::forward<Json::Value *>, COMDAT

; 1502 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1503 : }

	ret	0
??$forward@PEAVValue@Json@@@std@@YA$$QEAPEAVValue@Json@@AEAPEAV12@@Z ENDP ; std::forward<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\utility
;	COMDAT ??$exchange@PEAVValue@Json@@$$T@std@@YAPEAVValue@Json@@AEAPEAV12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAVValue@Json@@$$T@std@@YAPEAVValue@Json@@AEAPEAV12@$$QEA$$T@Z PROC ; std::exchange<Json::Value *,std::nullptr_t>, COMDAT

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 775  :     return _Old_val;
; 776  : }

	ret	0
??$exchange@PEAVValue@Json@@$$T@std@@YAPEAVValue@Json@@AEAPEAV12@$$QEA$$T@Z ENDP ; std::exchange<Json::Value *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1>::_Get_first, COMDAT

; 1543 :         return *this;

	mov	rax, rcx

; 1544 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::max_size, COMDAT

; 746  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 747  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1>::_Get_first, COMDAT

; 1543 :         return *this;

	mov	rax, rcx

; 1544 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Unchecked_begin, COMDAT

; 1121 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR [rcx]

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]

; 1121 :         return _Unchecked_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, rdx

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx

; 1122 :     }

	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T4 = 32
this$ = 64
?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::clear, COMDAT

; 1155 :     void clear() noexcept {

$LN82:
	push	rsi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx

; 1156 :         // TRANSITION, ABI:
; 1157 :         // LWG-2550 requires implementations to make clear() O(size()), independent of bucket_count().
; 1158 :         // Unfortunately our current data structure / ABI does not allow achieving this in the general case because:
; 1159 :         //   (1) Finding the bucket that goes with an element requires running the hash function
; 1160 :         //   (2) The hash function operator() may throw exceptions, and
; 1161 :         //   (3) clear() is a noexcept function.
; 1162 :         // We do comply with LWG-2550 if the hash function is noexcept, or if the container was empty.
; 1163 :         const auto _Oldsize = _List._Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 1164 :         if (_Oldsize == 0) {

	test	rcx, rcx
	je	$LN1@clear

; 1165 :             return;
; 1166 :         }
; 1167 : 
; 1168 :         if constexpr (_Nothrow_hash<_Traits, key_type>) {
; 1169 :             // In testing, hash<size_t>{}(size_t{}) takes about 14 times as much time as assigning a pointer, or
; 1170 :             // ~7-8 times as much as clearing a bucket. Therefore, if we would need to assign over more than 8 times
; 1171 :             // as many buckets as elements, remove element-by-element.
; 1172 :             if (bucket_count() / 8 > _Oldsize) {

	mov	rax, QWORD PTR [rsi+56]
	shr	rax, 3
	mov	QWORD PTR [rsp+80], rdi
	mov	rdi, QWORD PTR [rsi+8]
	cmp	rax, rcx
	jbe	SHORT $LN3@clear

; 1173 :                 const auto _Head = _List._Mypair._Myval2._Myhead;
; 1174 :                 _Unchecked_erase(_Head->_Next, _Head);

	mov	rdx, QWORD PTR [rdi]
	mov	r8, rdi
	mov	rcx, rsi
	mov	rdi, QWORD PTR [rsp+80]

; 1182 :     }

	add	rsp, 48					; 00000030H
	pop	rsi

; 1173 :                 const auto _Head = _List._Mypair._Myval2._Myhead;
; 1174 :                 _Unchecked_erase(_Head->_Next, _Head);

	jmp	?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_erase
$LN3@clear:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rdi, QWORD PTR [rdi]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rdi, rdi
	je	SHORT $LN72@clear
	mov	QWORD PTR [rsp+72], rbx
	npad	4
$LL12@clear:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdi]

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rdi+16]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rdi, rbx
	test	rbx, rbx
	jne	SHORT $LL12@clear
	mov	rbx, QWORD PTR [rsp+72]
$LN72@clear:

; 1508 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1181 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	lea	r8, QWORD PTR $T4[rsp]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 1508 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	QWORD PTR [rax], rax

; 1509 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rax+8], rax

; 1510 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rsi+16], 0

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rsi+8]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1181 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	mov	rdx, QWORD PTR [rsi+32]
	mov	rcx, QWORD PTR [rsi+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR $T4[rsp], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1181 :         _STD fill(_Vec._Mypair._Myval2._Myfirst, _Vec._Mypair._Myval2._Mylast, _Unchecked_end());

	call	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@std@@V12@@std@@YAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > > > >
	mov	rdi, QWORD PTR [rsp+80]
$LN1@clear:

; 1182 :     }

	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
?clear@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBAAEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBAAEBMXZ PROC ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size, COMDAT

; 158  :         return _Mypair._Myval2._Myval2;

	mov	rax, rcx

; 159  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEBAAEBMXZ ENDP ; std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::clear, COMDAT

; 1504 :     void clear() noexcept { // erase all

$LN61:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1505 :         auto& _My_data = _Mypair._Myval2;
; 1506 :         _My_data._Orphan_non_end();
; 1507 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

	mov	rdx, QWORD PTR [rcx]
	mov	rsi, rcx

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rdi, QWORD PTR [rdx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	test	rdi, rdi
	je	SHORT $LN54@clear
	mov	QWORD PTR [rsp+56], rbx
	npad	8
$LL7@clear:

; 328  :             _Pnext = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdi]

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rdi+16]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	mov	rdi, rbx
	test	rbx, rbx
	jne	SHORT $LL7@clear
	mov	rbx, QWORD PTR [rsp+56]
$LN54@clear:

; 1508 :         _My_data._Myhead->_Next = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rax], rax

; 1509 :         _My_data._Myhead->_Prev = _My_data._Myhead;

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rax+8], rax

; 1510 :         _My_data._Mysize        = 0;

	mov	QWORD PTR [rsi+8], 0

; 1511 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clear@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z
_TEXT	SEGMENT
_Eraser$$sroa$568$1$ = 32
_End$1$ = 40
tv859 = 48
_Bucket_bounds$1$ = 56
this$ = 112
_First$ = 120
_Last$ = 128
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_erase, COMDAT

; 1031 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept(_Nothrow_hash<_Traits, key_type>) {

$LN239:
	mov	rax, rsp
	push	rbp
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	r14, r8
	mov	r15, rdx
	mov	rbp, rcx

; 1032 :         if (_First == _Last) {

	cmp	rdx, r8
	je	$LN236@Unchecked_
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+40], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1042 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	lea	r8, QWORD PTR [rdx+16]
	mov	r10, QWORD PTR [rcx+24]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3390 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [r8+16]
	mov	QWORD PTR [rax+16], rbx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1011 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	rbx, rdx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax-32], r12
	mov	QWORD PTR [rax-40], r13

; 1033 :             return _Last;
; 1034 :         }
; 1035 : 
; 1036 :         const auto _End           = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR _End$1$[rsp], rax

; 1011 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR _Eraser$$sroa$568$1$[rsp], rax

; 1037 :         const auto _Bucket_bounds = _Vec._Mypair._Myval2._Myfirst;

	mov	QWORD PTR _Bucket_bounds$1$[rsp], r10
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN39@Unchecked_

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [r8]
$LN39@Unchecked_:
	xor	ecx, ecx
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2292 :     return _Fnv1a_append_bytes(

	mov	rdx, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	r11, 1099511628211			; 00000100000001b3H
	test	r9, r9
	je	SHORT $LN50@Unchecked_
	npad	3
$LL202@Unchecked_:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rcx+r8]
	inc	rcx
	xor	rdx, rax

; 2261 :         _Val *= _FNV_prime;

	imul	rdx, r11
	cmp	rcx, r9
	jb	SHORT $LL202@Unchecked_
$LN50@Unchecked_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 860  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r12, QWORD PTR [rbp+48]
	and	r12, rdx

; 1043 :             // nothrow hereafter this block
; 1044 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r12, 4
	add	r12, r10

; 1045 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1046 :             const bool _Update_lo  = _Bucket_lo == _Eraser._Next;

	mov	rax, QWORD PTR [r12]

; 1047 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	r13, QWORD PTR [r12+8]
	mov	QWORD PTR tv859[rsp], rax
$LL4@Unchecked_:

; 1048 :             for (;;) { // remove elements until we hit the end of the bucket
; 1049 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rdi, rbx
	mov	rsi, rbx

; 1015 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rdi+16]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1017 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [rbp+16]

; 1050 :                 _Eraser._Bump_erased();
; 1051 :                 if (_At_bucket_back) {

	cmp	rdi, r13
	je	SHORT $LN188@Unchecked_

; 1052 :                     break;
; 1053 :                 }
; 1054 : 
; 1055 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, r14
	jne	SHORT $LL4@Unchecked_

; 1056 :                     if (_Update_lo) {

	cmp	QWORD PTR tv859[rsp], r15
	jne	SHORT $LN196@Unchecked_
$LN193@Unchecked_:

; 1021 :             _Predecessor->_Next = _Next;

	mov	QWORD PTR [r12], rbx
$LN196@Unchecked_:
	mov	rax, QWORD PTR _Eraser$$sroa$568$1$[rsp]
	mov	r12, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+128]
	mov	r13, QWORD PTR [rsp+64]
	mov	QWORD PTR [rax], rbx

; 1022 :             _Next->_Prev        = _Predecessor;

	mov	QWORD PTR [rbx+8], rax
	mov	rbx, QWORD PTR [rsp+120]
$LN236@Unchecked_:

; 1098 :         }
; 1099 : 
; 1100 :         return _Last;
; 1101 :     }

	mov	rax, r14
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN188@Unchecked_:

; 1057 :                         // erased the bucket's prefix
; 1058 :                         _Bucket_lo = _Eraser._Next;
; 1059 :                     }
; 1060 : 
; 1061 :                     return _Last;
; 1062 :                 }
; 1063 :             }
; 1064 : 
; 1065 :             if (_Update_lo) {

	mov	r13, QWORD PTR _End$1$[rsp]
	cmp	QWORD PTR tv859[rsp], r15
	jne	SHORT $LN14@Unchecked_

; 1066 :                 // emptied the bucket
; 1067 :                 _Bucket_lo = _End;

	mov	QWORD PTR [r12], r13

; 1068 :                 _Bucket_hi = _End;

	mov	rax, r13

; 1069 :             } else {

	jmp	SHORT $LN182@Unchecked_
$LN14@Unchecked_:

; 1070 :                 _Bucket_hi = _Predecessor;

	mov	rax, QWORD PTR _Eraser$$sroa$568$1$[rsp]
$LN182@Unchecked_:

; 1071 :             }
; 1072 :         }
; 1073 : 
; 1074 :         // hereafter we are always erasing buckets' prefixes
; 1075 :         while (_Eraser._Next != _Last) {

	mov	QWORD PTR [r12+8], rax
	cmp	rbx, r14
	je	SHORT $LN196@Unchecked_
	npad	12
$LL5@Unchecked_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rbx+40], 15
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1076 :             const size_type _Bucket = bucket(_Traits::_Kfn(_Eraser._Next->_Myval)); // throws

	lea	r8, QWORD PTR [rbx+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 3390 :         return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());

	mov	r9, QWORD PTR [r8+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN116@Unchecked_

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [r8]
$LN116@Unchecked_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\type_traits

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	xor	edx, edx

; 2292 :     return _Fnv1a_append_bytes(

	mov	rcx, -3750763034362895579		; cbf29ce484222325H

; 2259 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	test	r9, r9
	je	SHORT $LN127@Unchecked_
	mov	r13, 1099511628211			; 00000100000001b3H
	npad	3
$LL204@Unchecked_:

; 2260 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [rdx+r8]
	inc	rdx
	xor	rcx, rax

; 2261 :         _Val *= _FNV_prime;

	imul	rcx, r13
	cmp	rdx, r9
	jb	SHORT $LL204@Unchecked_
	mov	r13, QWORD PTR _End$1$[rsp]
$LN127@Unchecked_:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 860  :         return _Traitsobj(_Keyval) & _Mask;

	mov	r12, QWORD PTR [rbp+48]
	and	r12, rcx

; 1077 :             // nothrow hereafter this block
; 1078 :             _Nodeptr& _Bucket_lo   = _Bucket_bounds[_Bucket << 1]._Ptr;

	shl	r12, 4
	add	r12, QWORD PTR _Bucket_bounds$1$[rsp]

; 1079 :             _Nodeptr& _Bucket_hi   = _Bucket_bounds[(_Bucket << 1) + 1]._Ptr;
; 1080 :             const _Nodeptr _Old_hi = _Bucket_hi;

	mov	r15, QWORD PTR [r12+8]
	npad	2
$LL9@Unchecked_:

; 1081 :             for (;;) { // remove elements until we hit the end of the bucket
; 1082 :                 const bool _At_bucket_back = _Eraser._Next == _Old_hi;

	mov	rdi, rbx
	mov	rsi, rbx

; 1015 :             _Next               = _Oldnext->_Next;

	mov	rbx, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rdi+16]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1017 :             --_List._Mypair._Myval2._Mysize;

	dec	QWORD PTR [rbp+16]

; 1083 :                 _Eraser._Bump_erased();
; 1084 :                 if (_At_bucket_back) {

	cmp	rdi, r15
	je	SHORT $LN192@Unchecked_

; 1085 :                     break;
; 1086 :                 }
; 1087 : 
; 1088 :                 if (_Eraser._Next == _Last) {

	cmp	rbx, r14
	jne	SHORT $LL9@Unchecked_
	jmp	$LN193@Unchecked_
$LN192@Unchecked_:

; 1089 :                     // erased the bucket's prefix
; 1090 :                     _Bucket_lo = _Eraser._Next;
; 1091 :                     return _Last;
; 1092 :                 }
; 1093 :             }
; 1094 : 
; 1095 :             // emptied the bucket
; 1096 :             _Bucket_lo = _End;

	mov	QWORD PTR [r12], r13

; 1097 :             _Bucket_hi = _End;

	mov	QWORD PTR [r12+8], r13
	cmp	rbx, r14
	jne	$LL5@Unchecked_

; 1071 :             }
; 1072 :         }
; 1073 : 
; 1074 :         // hereafter we are always erasing buckets' prefixes
; 1075 :         while (_Eraser._Next != _Last) {

	jmp	$LN196@Unchecked_
?_Unchecked_erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@PEAU32@QEAU32@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT

; 2846 :     _CONSTEXPR20 bool _Equal(const basic_string& _Right) const noexcept {

$LN28:
	sub	rsp, 40					; 00000028H

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rdx+24], 15

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR [rdx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN5@Equal

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN5@Equal:

; 445  :         if (_Large_mode_engaged()) {

	cmp	QWORD PTR [rcx+24], 15

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rcx+16]

; 445  :         if (_Large_mode_engaged()) {

	jbe	SHORT $LN12@Equal

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN12@Equal:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 604  :     if (_Left_size != _Right_size) {

	cmp	r8, rax
	je	SHORT $LN19@Equal
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	xor	al, al

; 2850 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN19@Equal:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 608  :     if (_Left_size == 0u) {

	test	r8, r8
	jne	SHORT $LN20@Equal
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2848 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	al, 1

; 2850 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN20@Equal:
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 437  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 612  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	sete	al
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xstring

; 2850 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??1_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Range_eraser::~_Range_eraser, COMDAT

; 1021 :             _Predecessor->_Next = _Next;

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx], rax

; 1022 :             _Next->_Prev        = _Predecessor;

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+8], rax

; 1023 :         }

	ret	0
??1_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Range_eraser::~_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Range_eraser::_Bump_erased, COMDAT

; 1013 :         void _Bump_erased() noexcept {

$LN45:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1014 :             const auto _Oldnext = _Next;

	mov	rbx, QWORD PTR [rcx+16]
	mov	rdi, rcx

; 1015 :             _Next               = _Oldnext->_Next;

	mov	rax, QWORD PTR [rbx]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rdx, QWORD PTR [rbx+16]
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1015 :             _Next               = _Oldnext->_Next;

	mov	QWORD PTR [rcx+16], rax
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash

; 1017 :             --_List._Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rdi]

; 1018 :         }

	mov	rbx, QWORD PTR [rsp+56]
	dec	QWORD PTR [rax+8]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Bump_erased@_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Range_eraser::_Bump_erased
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\xhash
;	COMDAT ??0_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_List_$ = 16
_First_$ = 24
??0_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@@Z PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Range_eraser::_Range_eraser, COMDAT

; 1011 :             : _List(_List_), _Predecessor(_First_->_Prev), _Next(_First_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0_Range_eraser@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@$0A@@std@@@std@@QEAA@AEAV?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@2@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@PEAX@2@@Z ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::unique_ptr<Json::Value,std::default_delete<Json::Value> >,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > >,0> >::_Range_eraser::_Range_eraser
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File A:\ProgramFiles\VisualStudio\VC\Tools\MSVC\14.44.35207\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@QEAAXXZ PROC ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Orphan_non_end, COMDAT

; 387  : #if _ITERATOR_DEBUG_LEVEL == 2
; 388  :         _Lockit _Lock(_LOCK_DEBUG);
; 389  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 390  :         const auto _Head          = _Myhead;
; 391  :         while (*_Pnext) {
; 392  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 393  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 394  :                 _Pnext = _Pnextnext;
; 395  :             } else { // orphan the iterator
; 396  :                 (*_Pnext)->_Myproxy = nullptr;
; 397  :                 *_Pnext             = *_Pnextnext;
; 398  :             }
; 399  :         }
; 400  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 401  :     }

	ret	0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$unique_ptr@VValue@Json@@U?$default_delete@VValue@Json@@@std@@@2@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::unique_ptr<Json::Value,std::default_delete<Json::Value> > > > >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
	movsxd	rax, DWORD PTR [rcx-4]
	sub	rcx, rax
	jmp	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
END
