; Listing generated by Microsoft (R) Optimizing Compiler Version 19.50.35721.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Avx2WmemEnabledWeakValue
PUBLIC	??$in_place_index@$0A@@std@@3U?$in_place_index_t@$0A@@1@B ; std::in_place_index<0>
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
msvcjmc	SEGMENT
__ED5CB687_concurrencysal@h DB 01H
__E45EDB60_sal@h DB 01H
__D35E0FCE_vadefs@h DB 01H
__C27BE271_vcruntime@h DB 01H
__26A6A76C_xkeycheck@h DB 01H
__E31B3605_yvals_core@h DB 01H
__CAE7E606___msvc_sanitizer_annotate_container@hpp DB 01H
__735960E1_corecrt@h DB 01H
__9A5272F0_vcruntime_new@h DB 01H
__42867C4A_vcruntime_new_debug@h DB 01H
__15FC02C9_crtdbg@h DB 01H
__65A7AE52_crtdefs@h DB 01H
__99C021FC_use_ansi@h DB 01H
__5FCF1118_yvals@h DB 01H
__60B45B40_corecrt_stdio_config@h DB 01H
__CFA3741E_corecrt_wstdio@h DB 01H
__B3FE3303_stdio@h DB 01H
__7816C314_cstdio DB 01H
__13DE2371_errno@h DB 01H
__913C9CB3_vcruntime_string@h DB 01H
__8ACB2152_corecrt_memcpy_s@h DB 01H
__EA6C9D17_corecrt_memory@h DB 01H
__0DF2AF52_corecrt_wstring@h DB 01H
__6E889ECC_string@h DB 01H
__A51D0F47_cstring DB 01H
__8BDC0229_corecrt_wconio@h DB 01H
__108B2620_corecrt_wctype@h DB 01H
__547F429B_corecrt_wdirect@h DB 01H
__260A2221_corecrt_share@h DB 01H
__EB642103_corecrt_wio@h DB 01H
__F49D648E_corecrt_wprocess@h DB 01H
__8B813BF6_corecrt_wstdlib@h DB 01H
__9E5BC8DA_corecrt_wtime@h DB 01H
__2A5E3E75_types@h DB 01H
__B16B2B9B_stat@h DB 01H
__D889C389_intrin0@inl@h DB 01H
__3B3089AB_setjmp@h DB 01H
__5CE08A7F_mmintrin@h DB 01H
__211DB995_corecrt_malloc@h DB 01H
__7CD62D9E_malloc@h DB 01H
__42AE8E25_xmmintrin@h DB 01H
__27CC07E9_emmintrin@h DB 01H
__F86D6F60_pmmintrin@h DB 01H
__48B41CE2_tmmintrin@h DB 01H
__618F0961_smmintrin@h DB 01H
__04ED80AD_nmmintrin@h DB 01H
__D1567AE3_wmmintrin@h DB 01H
__1AC237E4_zmmintrin@h DB 01H
__2DD6952E_immintrin@h DB 01H
__9715746B_ammintrin@h DB 01H
__1D0635DC_intrin@h DB 01H
__4DD8D0FE_wchar@h DB 01H
__E29D1547_cwchar DB 01H
__62CE13B5_xtr1common DB 01H
__A15D9071_iosfwd DB 01H
__955456CD_stddef@h DB 01H
__4C447D0A_cstddef DB 01H
__F79AC0B4_initializer_list DB 01H
__AB5361A8_stdint@h DB 01H
__54D146DA_cstdint DB 01H
__680F61A7_type_traits DB 01H
__4323F09F_concepts DB 01H
__109A9D16_compare DB 01H
__DE82222C_utility DB 01H
__B73D1048___msvc_iter_core@hpp DB 01H
__15254F97_limits@h DB 01H
__6D608555_climits DB 01H
__1D9A7FA2_corecrt_math@h DB 01H
__2E93F1C0_math@h DB 01H
__99AED4FB_corecrt_search@h DB 01H
__E8FB0A68_stdlib@h DB 01H
__E98FA7A7_cstdlib DB 01H
__C78B1955_xutility DB 01H
__FEA281E8___msvc_string_view@hpp DB 01H
__CB8A55F3_float@h DB 01H
__0B520893_cfloat DB 01H
__7C8A1759_intrin0@h DB 01H
__6DB445F7_limits DB 01H
__C071288D_corecrt_terminate@h DB 01H
__7747910A_eh@h DB 01H
__4A687918_vcruntime_exception@h DB 01H
__ADF8C0C4_exception DB 01H
__EBEDE495_new DB 01H
__A7F44C12_xatomic@h DB 01H
__20C7CC96_tuple DB 01H
__B41741EF_xmemory DB 01H
__3ABE9893_xpolymorphic_allocator@h DB 01H
__C0C4C773_xstring DB 01H
__6CD6613D_ctype@h DB 01H
__77DD24B3_cctype DB 01H
__A5C9CFE5_string DB 01H
__C395D46E___msvc_bit_utils@hpp DB 01H
__20193517_vector DB 01H
__D1A2D489_xsmf_control@h DB 01H
__5C102AE6_variant DB 01H
__86E4D5D7_cmath DB 01H
__1099CBE1_list DB 01H
__4D844272_xbit_ops@h DB 01H
__8D0EBA0A_xnode_handle@h DB 01H
__E94B15B1_xhash DB 01H
__B4850007_unordered_map DB 01H
__8E829D7E_span DB 01H
__24B6FA99_stdexcept DB 01H
__E6EE7F14_string_view DB 01H
__B73B1AB1_array DB 01H
__A3D3F6D7_vcruntime_typeinfo@h DB 01H
__B754EA4C_typeinfo DB 01H
__D91C7F2A_xatomic_wait@h DB 01H
__EEAFAE40___msvc_threads_core@hpp DB 01H
__1FF36214_time@h DB 01H
__405749DF_ctime DB 01H
__714FFA14_xtimec@h DB 01H
__F88E164F_xthreads@h DB 01H
__06811935_atomic DB 01H
__D11A4979_memory DB 01H
__9E93B77E___msvc_heap_algorithms@hpp DB 01H
__F5ABCB6B___msvc_minmax@hpp DB 01H
__47348210_algorithm DB 01H
__85852BDB_share@h DB 01H
__43DB425A___msvc_system_error_abi@hpp DB 01H
__E537B7EF_cerrno DB 01H
__A083E855_xcall_once@h DB 01H
__F75A0417_xerrc@h DB 01H
__1FDEFA75_system_error DB 01H
__FD5F1E76_xfacet DB 01H
__D602BFDF___msvc_xlocinfo_types@hpp DB 01H
__FFBDF365_locale@h DB 01H
__7A237B76_clocale DB 01H
__A8DD0984_xlocinfo DB 01H
__1FFAB342_xlocale DB 01H
__91387E97_xiosbase DB 01H
__26164225_streambuf DB 01H
__1D1D39B2___msvc_filebuf@hpp DB 01H
__D627AE15_iterator DB 01H
__817DD555_xlocnum DB 01H
__1320DE83_ios DB 01H
__1D8A815F___msvc_ostream@hpp DB 01H
__6F3A5CBC_istream DB 01H
__99722C55_fstream DB 01H
__186C3B2B_SIMDUtils@h DB 01H
__9AC28836_Parser@h DB 01H
__6DE13511_Value@h DB 01H
__0CEA6986_ostream DB 01H
__A5F2634A_iostream DB 01H
__3FD16450_Main@cpp DB 01H
msvcjmc	ENDS
;	COMDAT ??$in_place_index@$0A@@std@@3U?$in_place_index_t@$0A@@1@B
CONST	SEGMENT
??$in_place_index@$0A@@std@@3U?$in_place_index_t@$0A@@1@B	ORG $+1 ; std::in_place_index<0>
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsprintf_s_l
PUBLIC	_vscprintf_l
PUBLIC	sprintf_s
PUBLIC	_scprintf
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??0exception@std@@QEAA@XZ			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_variant_access@std@@QEAA@XZ		; std::bad_variant_access::bad_variant_access
PUBLIC	?what@bad_variant_access@std@@UEBAPEBDXZ	; std::bad_variant_access::what
PUBLIC	??1bad_variant_access@std@@UEAA@XZ		; std::bad_variant_access::~bad_variant_access
PUBLIC	??0bad_variant_access@std@@QEAA@AEBV01@@Z	; std::bad_variant_access::bad_variant_access
PUBLIC	??_Gbad_variant_access@std@@UEAAPEAXI@Z		; std::bad_variant_access::`scalar deleting destructor'
PUBLIC	?_Throw_bad_variant_access@std@@YAXXZ		; std::_Throw_bad_variant_access
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QEAA@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
PUBLIC	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IEAA@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
PUBLIC	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z ; std::to_string
PUBLIC	??0runtime_error@std@@QEAA@PEBD@Z		; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UEAA@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QEAA@AEBV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UEAAPEAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ; std::_Traits_copy_batch<std::char_traits<char>,char>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$construct_at@D$$V@std@@YAPEADQEAD@Z		; std::construct_at<char>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGAAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Variant_storage_<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
PUBLIC	?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGBAAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Variant_storage_<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
PUBLIC	?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ ; std::_Variant_storage_<1,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
PUBLIC	?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ ; std::_Variant_storage_<1,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
PUBLIC	?_Get@?$_Variant_storage_@$00NPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBNXZ ; std::_Variant_storage_<1,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
PUBLIC	?_Get@?$_Variant_storage_@$00HNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBHXZ ; std::_Variant_storage_<1,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
PUBLIC	?_Get@?$_Variant_storage_@$00_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEB_NXZ ; std::_Variant_storage_<1,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
PUBLIC	?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
PUBLIC	?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
PUBLIC	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
PUBLIC	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
PUBLIC	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
PUBLIC	??0Value@Json@@QEAA@XZ				; Json::Value::Value
PUBLIC	??1Value@Json@@QEAA@XZ				; Json::Value::~Value
PUBLIC	??4Value@Json@@QEAAAEAV01@$$QEAV01@@Z		; Json::Value::operator=
PUBLIC	?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Value::stringify
PUBLIC	?fromFile@Value@Json@@SA?AV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::fromFile
PUBLIC	?__autoclassinit2@Value@Json@@QEAAX_K@Z		; Json::Value::__autoclassinit2
PUBLIC	??_GValue@Json@@QEAAPEAXI@Z			; Json::Value::`scalar deleting destructor'
PUBLIC	??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::vector<Json::Value,std::allocator<Json::Value> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::vector<Json::Value,std::allocator<Json::Value> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<0,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<0,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Variant_raw_get@$0A@AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<0,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>
PUBLIC	?deallocate@?$allocator@VValue@Json@@@std@@QEAAXQEAVValue@Json@@_K@Z ; std::allocator<Json::Value>::deallocate
PUBLIC	??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ ; std::vector<Json::Value,std::allocator<Json::Value> >::~vector<Json::Value,std::allocator<Json::Value> >
PUBLIC	?size@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBA_KXZ ; std::vector<Json::Value,std::allocator<Json::Value> >::size
PUBLIC	??A?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBAAEBVValue@Json@@_K@Z ; std::vector<Json::Value,std::allocator<Json::Value> >::operator[]
PUBLIC	?_Tidy@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAXXZ ; std::vector<Json::Value,std::allocator<Json::Value> >::_Tidy
PUBLIC	?_Getal@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAAEAV?$allocator@VValue@Json@@@2@XZ ; std::vector<Json::Value,std::allocator<Json::Value> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@VValue@Json@@@std@@V?$_Vector_val@U?$_Simple_types@VValue@Json@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VValue@Json@@@2@XZ ; std::_Compressed_pair<std::allocator<Json::Value>,std::_Vector_val<std::_Simple_types<Json::Value> >,1>::_Get_first
PUBLIC	??_G?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAAPEAXI@Z ; std::vector<Json::Value,std::allocator<Json::Value> >::`scalar deleting destructor'
PUBLIC	??$?0PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@$0A@@?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@XZ ; std::variant<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::variant<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::vector<Json::Value,std::allocator<Json::Value> > *,0>
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >::deallocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >::deallocate
PUBLIC	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Unchecked_end
PUBLIC	?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Tidy
PUBLIC	?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,1>::_Get_first
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::_Unchecked_end
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >::deallocate
PUBLIC	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::capacity
PUBLIC	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::_Tidy
PUBLIC	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >,1>::_Get_first
PUBLIC	??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::~_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >
PUBLIC	??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >
PUBLIC	??_G?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::`scalar deleting destructor'
PUBLIC	??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<4,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<4,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Variant_raw_get@$03AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<4,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>
PUBLIC	??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<5,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<5,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Variant_raw_get@$04AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<5,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>
PUBLIC	??$_Variant_raw_get@$0A@AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<0,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
PUBLIC	??$_Variant_raw_get@$03AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<4,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
PUBLIC	??$_Variant_raw_get@$04AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<5,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator++
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator==
PUBLIC	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAA@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>
PUBLIC	??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAAPEAXI@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>::`scalar deleting destructor'
PUBLIC	??$get@$0A@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z ; std::get<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>
PUBLIC	??$get@$00$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBVValue@Json@@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z ; std::get<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$get@_NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<bool,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Variant_raw_get@$00AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<1,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
PUBLIC	??$get@HPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<int,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@$01PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<2,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Variant_raw_get@$01AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<2,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
PUBLIC	??$get@NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<double,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$get@$02PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<3,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Variant_raw_get@$02AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<3,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
PUBLIC	main
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z		; std::end<char,21>
PUBLIC	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z	; std::_UIntegral_to_buff<char,unsigned int>
PUBLIC	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0$0A@$$V$0A@@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$0A@@1@@Z ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><0,0>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$_Get_proxy_allocator@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_proxy_allocator<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >
PUBLIC	??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >
PUBLIC	??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Get_proxy_allocator@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@0@@Z ; std::_Get_proxy_allocator<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
PUBLIC	??$?0U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >
PUBLIC	??$_Get_proxy_allocator@V?$allocator@VValue@Json@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@VValue@Json@@@0@@Z ; std::_Get_proxy_allocator<std::allocator<Json::Value> >
PUBLIC	??$?0VValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@VValue@Json@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
PUBLIC	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z	; std::_Get_unwrapped<char * &>
PUBLIC	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$?0$$V@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$integral_constant@_K$0A@@1@@Z ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><>
PUBLIC	??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@AEAU10@@Z ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Traits_move_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ; std::_Traits_move_batch<std::char_traits<char>,char>
PUBLIC	??R<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@QEBD_K@Z@SA@QEAD0101@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>,char const *,unsigned __int64>
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >
PUBLIC	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > *>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Value> >
PUBLIC	??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
PUBLIC	??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z ; std::_Allocators_equal<std::allocator<char> >
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Unfancy@VValue@Json@@@std@@YAPEAVValue@Json@@PEAV12@@Z ; std::_Unfancy<Json::Value>
PUBLIC	??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >
PUBLIC	??$_Destroy_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@@Z ; std::_Destroy_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
PUBLIC	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> *>
PUBLIC	??$destroy@VValue@Json@@@?$_Default_allocator_traits@V?$allocator@VValue@Json@@@std@@@std@@SAXAEAV?$allocator@VValue@Json@@@1@QEAVValue@Json@@@Z ; std::_Default_allocator_traits<std::allocator<Json::Value> >::destroy<Json::Value>
PUBLIC	??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$destroy_at@VValue@Json@@@std@@YAXQEAVValue@Json@@@Z ; std::destroy_at<Json::Value>
PUBLIC	__JustMyCode_Default
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_7bad_variant_access@std@@6B@			; std::bad_variant_access::`vftable'
PUBLIC	??_C@_0BD@FGIAGBIG@bad?5variant?5access@	; `string'
PUBLIC	_TI2?AVbad_variant_access@std@@
PUBLIC	_CTA2?AVbad_variant_access@std@@
PUBLIC	??_R0?AVbad_variant_access@std@@@8		; std::bad_variant_access `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_variant_access@std@@@8??0bad_variant_access@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf@				; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Detail::Parser::nullLiteral
PUBLIC	??_C@_04MLLLIHIP@null@				; `string'
PUBLIC	?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Detail::Parser::trueLiteral
PUBLIC	?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Detail::Parser::falseLiteral
PUBLIC	??_C@_02JKLIAPDG@?$FL?6@			; `string'
PUBLIC	??_C@_02MLAGHBOD@?0?6@				; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN@				; `string'
PUBLIC	??_C@_02KCPFEJNG@?$HL?6@			; `string'
PUBLIC	??_C@_03HJDMPJK@?$CC?3?6@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_03GIPIADLC@?$CC?3?5@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN@				; `string'
PUBLIC	_TI2?AVruntime_error@std@@
PUBLIC	_CTA2?AVruntime_error@std@@
PUBLIC	??_C@_0N@DGOCBNGP@Unknown?5type@		; `string'
PUBLIC	??_C@_0BA@DPKMFFGL@tests?1test?4json@		; `string'
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_0GB@HOPEEJK@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@ ; `string'
PUBLIC	??_C@_0GA@IMMHHOBA@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0FP@FHDFLINP@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R4bad_variant_access@std@@6B@		; std::bad_variant_access::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_variant_access@std@@8			; std::bad_variant_access::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_variant_access@std@@8			; std::bad_variant_access::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_variant_access@std@@8		; std::bad_variant_access::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsprintf_s:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?uncaught_exceptions@std@@YAHXZ:PROC		; std::uncaught_exceptions
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_Ebad_variant_access@std@@UEAAPEAXI@Z:PROC	; std::bad_variant_access::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UEAAPEAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	_CxxThrowException:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	strlen:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
_BSS	SEGMENT
?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 028H DUP (?) ; Json::Detail::Parser::nullLiteral
_BSS	ENDS
;	COMDAT ?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
_BSS	SEGMENT
?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 028H DUP (?) ; Json::Detail::Parser::trueLiteral
_BSS	ENDS
;	COMDAT ?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
_BSS	SEGMENT
?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 028H DUP (?) ; Json::Detail::Parser::falseLiteral
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??2@YAPEAX_KPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??2@YAPEAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+152
	DD	imagerel $unwind$_vsprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vscprintf_l DD imagerel $LN5
	DD	imagerel $LN5+145
	DD	imagerel $unwind$_vscprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf_s DD imagerel $LN3
	DD	imagerel $LN3+197
	DD	imagerel $unwind$sprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_scprintf DD imagerel $LN3
	DD	imagerel $LN3+177
	DD	imagerel $unwind$_scprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_constant_evaluated@std@@YA_NXZ DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?is_constant_evaluated@std@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN8
	DD	imagerel $LN8+182
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN17
	DD	imagerel $LN17+345
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z DD imagerel $LN7
	DD	imagerel $LN7+125
	DD	imagerel $unwind$?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ DD imagerel $LN4
	DD	imagerel $LN4+43
	DD	imagerel $unwind$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+120
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$??0exception@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+212
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+125
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+97
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+97
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_variant_access@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??0bad_variant_access@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@bad_variant_access@std@@UEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?what@bad_variant_access@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_variant_access@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??1bad_variant_access@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_variant_access@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$??0bad_variant_access@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_variant_access@std@@UEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_Gbad_variant_access@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_variant_access@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$?_Throw_bad_variant_access@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN8
	DD	imagerel $LN8+336
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Container_base12@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??0_Container_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+82
	DD	imagerel $unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z DD imagerel $LN6
	DD	imagerel $LN6+101
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+135
	DD	imagerel $unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z DD imagerel $LN6
	DD	imagerel $LN6+161
	DD	imagerel $unwind$?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+155
	DD	imagerel $unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z DD imagerel $LN4
	DD	imagerel $LN4+167
	DD	imagerel $unwind$?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+144
	DD	imagerel $unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$allocator@D@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??0?$allocator@D@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+158
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+112
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+105
	DD	imagerel $unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+120
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+131
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN4
	DD	imagerel $LN4+120
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+168
	DD	imagerel $unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+204
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DD imagerel $LN13
	DD	imagerel $LN13+1265
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD imagerel ?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
	DD	imagerel ?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA+39
	DD	imagerel $unwind$?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN9
	DD	imagerel $LN9+532
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+211
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+113
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+155
	DD	imagerel $unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN4
	DD	imagerel $LN4+224
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN6
	DD	imagerel $LN6+272
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+110
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+203
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+84
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN5
	DD	imagerel $LN5+96
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD imagerel $LN7
	DD	imagerel $LN7+287
	DD	imagerel $unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z DD imagerel $LN5
	DD	imagerel $LN5+251
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@PEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1runtime_error@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??1runtime_error@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gruntime_error@std@@UEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_Gruntime_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_size@_K_K@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Convert_size@_K_K@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+556
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA+36
	DD	imagerel $unwind$?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+162
	DD	imagerel $unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+187
	DD	imagerel $unwind$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN7
	DD	imagerel $LN7+215
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@D@std@@YAPEADPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Unfancy@D@std@@YAPEADPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@D$$V@std@@YAPEADQEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+104
	DD	imagerel $unwind$??$construct_at@D$$V@std@@YAPEADQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+141
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+120
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+93
	DD	imagerel $unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__E?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__E?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+71
	DD	imagerel $unwind$??__E?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__F?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__F?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+38
	DD	imagerel $unwind$??__F?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__E?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__E?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+71
	DD	imagerel $unwind$??__E?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__F?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__F?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+38
	DD	imagerel $unwind$??__F?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__E?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__E?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+71
	DD	imagerel $unwind$??__E?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD imagerel ??__F?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
	DD	imagerel ??__F?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ+38
	DD	imagerel $unwind$??__F?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGAAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGAAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGBAAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGBAAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get@?$_Variant_storage_@$00NPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBNXZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get@?$_Variant_storage_@$00NPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBNXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get@?$_Variant_storage_@$00HNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBHXZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get@?$_Variant_storage_@$00HNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get@?$_Variant_storage_@$00_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEB_NXZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get@?$_Variant_storage_@$00_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEB_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Value@Json@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$??0Value@Json@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Value@Json@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+328
	DD	imagerel $unwind$??1Value@Json@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Value@Json@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+147
	DD	imagerel $unwind$??4Value@Json@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD imagerel $LN61
	DD	imagerel $LN61+3196
	DD	imagerel $unwind$?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$0@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$0@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$1@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$1@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+36
	DD	imagerel $unwind$?dtor$1@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$2@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$2@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$2@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$3@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$3@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$3@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$4@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$4@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$4@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$5@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$5@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$5@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$7@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$7@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$7@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$8@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$8@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$8@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$8@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$9@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$9@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$9@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$9@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$10@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$10@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$10@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$10@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$11@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$11@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$11@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$11@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$12@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$12@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$12@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$12@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$13@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$13@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$13@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$14@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$14@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$14@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$14@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$15@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$15@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$15@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$15@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$16@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$16@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$16@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$16@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$17@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$17@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$17@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$17@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$18@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$18@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$18@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$18@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$19@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$19@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$19@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$20@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$20@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$20@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$20@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$21@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$21@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$21@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$21@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$22@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$22@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$22@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$22@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$23@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$23@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$23@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$23@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$24@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$24@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$24@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$24@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$25@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$25@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$25@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$25@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$26@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$26@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$26@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$26@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$27@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$27@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$27@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$27@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$28@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$28@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$28@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$28@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$29@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$29@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$29@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$29@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$30@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$30@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$30@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$30@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$31@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$31@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$31@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$31@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$32@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$32@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$32@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$32@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$33@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD imagerel ?dtor$33@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$33@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA+39
	DD	imagerel $unwind$?dtor$33@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fromFile@Value@Json@@SA?AV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?fromFile@Value@Json@@SA?AV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@Value@Json@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?__autoclassinit2@Value@Json@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GValue@Json@@QEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_GValue@Json@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Variant_raw_get@$0A@AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??$_Variant_raw_get@$0A@AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@VValue@Json@@@std@@QEAAXQEAVValue@Json@@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+162
	DD	imagerel $unwind$?deallocate@?$allocator@VValue@Json@@@std@@QEAAXQEAVValue@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+199
	DD	imagerel $unwind$??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBA_KXZ DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?size@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBAAEBVValue@Json@@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+178
	DD	imagerel $unwind$??A?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBAAEBVValue@Json@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+238
	DD	imagerel $unwind$?_Tidy@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAAEAV?$allocator@VValue@Json@@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Getal@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAAEAV?$allocator@VValue@Json@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@VValue@Json@@@std@@V?$_Vector_val@U?$_Simple_types@VValue@Json@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VValue@Json@@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@VValue@Json@@@std@@V?$_Vector_val@U?$_Simple_types@VValue@Json@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VValue@Json@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_G?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@$0A@@?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$??$?0PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@$0A@@?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+162
	DD	imagerel $unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+117
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+173
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+84
	DD	imagerel $unwind$?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+115
	DD	imagerel $unwind$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+92
	DD	imagerel $unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+92
	DD	imagerel $unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+165
	DD	imagerel $unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD imagerel $LN4
	DD	imagerel $LN4+71
	DD	imagerel $unwind$?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+219
	DD	imagerel $unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+202
	DD	imagerel $unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_G?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Variant_raw_get@$03AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$_Variant_raw_get@$03AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Variant_raw_get@$04AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$_Variant_raw_get@$04AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Variant_raw_get@$0A@AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??$_Variant_raw_get@$0A@AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Variant_raw_get@$03AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$_Variant_raw_get@$03AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Variant_raw_get@$04AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$_Variant_raw_get@$04AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+96
	DD	imagerel $unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@XZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD imagerel $LN6
	DD	imagerel $LN6+98
	DD	imagerel $unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$0A@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$get@$0A@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$00$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBVValue@Json@@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$??$get@$00$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBVValue@Json@@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD imagerel $LN7
	DD	imagerel $LN7+226
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@_NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$get@_NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??$get@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Variant_raw_get@$00AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$_Variant_raw_get@$00AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@HPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$get@HPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$01PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??$get@$01PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Variant_raw_get@$01AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$_Variant_raw_get@$01AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??$get@NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$get@$02PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??$get@$02PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Variant_raw_get@$02AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$_Variant_raw_get@$02AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN13
	DD	imagerel $LN13+394
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$0 DD imagerel main$dtor$0
	DD	imagerel main$dtor$0+36
	DD	imagerel $unwind$main$dtor$0
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$1 DD imagerel main$dtor$1
	DD	imagerel main$dtor$1+39
	DD	imagerel $unwind$main$dtor$1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$3 DD imagerel main$dtor$3
	DD	imagerel main$dtor$3+39
	DD	imagerel $unwind$main$dtor$3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$catch$4 DD imagerel main$catch$4
	DD	imagerel main$catch$4+117
	DD	imagerel $unwind$main$catch$4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN25
	DD	imagerel $LN25+1044
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+36
	DD	imagerel $unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+91
	DD	imagerel $unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z DD imagerel $LN6
	DD	imagerel $LN6+126
	DD	imagerel $unwind$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+224
	DD	imagerel $unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$0A@$$V$0A@@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$0A@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$??$?0$0A@$$V$0A@@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$0A@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel $LN26
	DD	imagerel $LN26+1023
	DD	imagerel $unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+36
	DD	imagerel $unwind$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+91
	DD	imagerel $unwind$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+150
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+121
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN7
	DD	imagerel $LN7+268
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA+39
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+115
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_proxy_allocator@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$??$_Get_proxy_allocator@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_proxy_allocator@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$??$_Get_proxy_allocator@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??$?0U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_proxy_allocator@V?$allocator@VValue@Json@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@VValue@Json@@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$??$_Get_proxy_allocator@V?$allocator@VValue@Json@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@VValue@Json@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0VValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@VValue@Json@@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??$?0VValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@VValue@Json@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+93
	DD	imagerel $unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+121
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+287
	DD	imagerel $unwind$??$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+557
	DD	imagerel $unwind$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z@4HA+36
	DD	imagerel $unwind$?dtor$0@?0???$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+556
	DD	imagerel $unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA DD imagerel ?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA+36
	DD	imagerel $unwind$?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+117
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$integral_constant@_K$0A@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$??$?0$$V@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$integral_constant@_K$0A@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@AEAU10@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@AEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+230
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_move_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$??$_Traits_move_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@QEBD_K@Z@SA@QEAD0101@Z DD imagerel $LN3
	DD	imagerel $LN3+183
	DD	imagerel $unwind$??R<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@QEBD_K@Z@SA@QEAD0101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+539
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@QEAV10@@Z DD imagerel $LN9
	DD	imagerel $LN9+110
	DD	imagerel $unwind$??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN7
	DD	imagerel $LN7+126
	DD	imagerel $unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN4
	DD	imagerel $LN4+109
	DD	imagerel $unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+118
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN6
	DD	imagerel $LN6+141
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unfancy@VValue@Json@@@std@@YAPEAVValue@Json@@PEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Unfancy@VValue@Json@@@std@@YAPEAVValue@Json@@PEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??$_Destroy_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@VValue@Json@@@?$_Default_allocator_traits@V?$allocator@VValue@Json@@@std@@@std@@SAXAEAV?$allocator@VValue@Json@@@1@QEAVValue@Json@@@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??$destroy@VValue@Json@@@?$_Default_allocator_traits@V?$allocator@VValue@Json@@@std@@@std@@SAXAEAV?$allocator@VValue@Json@@@1@QEAVValue@Json@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+127
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy_at@VValue@Json@@@std@@YAXQEAVValue@Json@@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$destroy_at@VValue@Json@@@std@@YAXQEAVValue@Json@@@Z
pdata	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??nullLiteral$initializer$@Parser@Detail@Json@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; ??nullLiteral$initializer$@Parser@Detail@Json@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD imagerel ??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD imagerel ??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 01H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	imagerel ??_R3runtime_error@std@@8
	DD	imagerel ??_R4runtime_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_variant_access@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_variant_access@std@@8 DD imagerel ??_R0?AVbad_variant_access@std@@@8 ; std::bad_variant_access::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_variant_access@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_variant_access@std@@8
rdata$r	SEGMENT
??_R2bad_variant_access@std@@8 DD imagerel ??_R1A@?0A@EA@bad_variant_access@std@@8 ; std::bad_variant_access::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_variant_access@std@@8
rdata$r	SEGMENT
??_R3bad_variant_access@std@@8 DD 00H			; std::bad_variant_access::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_variant_access@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_variant_access@std@@6B@
rdata$r	SEGMENT
??_R4bad_variant_access@std@@6B@ DD 01H			; std::bad_variant_access::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_variant_access@std@@@8
	DD	imagerel ??_R3bad_variant_access@std@@8
	DD	imagerel ??_R4bad_variant_access@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ DB 'string subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@FHDFLINP@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0FP@FHDFLINP@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50'
	DB	'.35717\include\vector', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ DB 'vector subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@IMMHHOBA@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GA@IMMHHOBA@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50'
	DB	'.35717\include\xstring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@
CONST	SEGMENT
??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@ DB 'You cannot c'
	DB	'oncatenate the same moved string to itself. See N4950 [res.on'
	DB	'.arguments]/1.3: If a function argument is bound to an rvalue'
	DB	' reference parameter, the implementation may assume that this'
	DB	' parameter is a unique reference to this argument, except tha'
	DB	't the argument passed to a move-assignment operator may be a '
	DB	'reference to *this ([lib.types.movedfrom]).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@HOPEEJK@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GB@HOPEEJK@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program Fi'
	DB	'les\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.'
	DB	'35717\include\xutility', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPKMFFGL@tests?1test?4json@
CONST	SEGMENT
??_C@_0BA@DPKMFFGL@tests?1test?4json@ DB 'tests/test.json', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DGOCBNGP@Unknown?5type@
CONST	SEGMENT
??_C@_0N@DGOCBNGP@Unknown?5type@ DB 'Unknown type', 00H	; `string'
CONST	ENDS
;	COMDAT _CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
_CTA2?AVruntime_error@std@@ DD 02H
	DD	imagerel _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI2?AVruntime_error@std@@
xdata$x	SEGMENT
_TI2?AVruntime_error@std@@ DD 00H
	DD	imagerel ??1runtime_error@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GIPIADLC@?$CC?3?5@
CONST	SEGMENT
??_C@_03GIPIADLC@?$CC?3?5@ DB '": ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HJDMPJK@?$CC?3?6@
CONST	SEGMENT
??_C@_03HJDMPJK@?$CC?3?6@ DB '":', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCPFEJNG@?$HL?6@
CONST	SEGMENT
??_C@_02KCPFEJNG@?$HL?6@ DB '{', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MLAGHBOD@?0?6@
CONST	SEGMENT
??_C@_02MLAGHBOD@?0?6@ DB ',', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JKLIAPDG@?$FL?6@
CONST	SEGMENT
??_C@_02JKLIAPDG@?$FL?6@ DB '[', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null@
CONST	SEGMENT
??_C@_04MLLLIHIP@null@ DB 'null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0runtime_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DQ FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DQ	FLAT:??_Eruntime_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50'
	DB	'.35717\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA DD 0ccH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_variant_access@std@@@8??0bad_variant_access@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_variant_access@std@@@8??0bad_variant_access@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_variant_access@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_variant_access@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_variant_access@std@@@8
data$r	SEGMENT
??_R0?AVbad_variant_access@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_variant_access `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_variant_access@std@@', 00H
data$r	ENDS
;	COMDAT _CTA2?AVbad_variant_access@std@@
xdata$x	SEGMENT
_CTA2?AVbad_variant_access@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_variant_access@std@@@8??0bad_variant_access@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI2?AVbad_variant_access@std@@
xdata$x	SEGMENT
_TI2?AVbad_variant_access@std@@ DD 00H
	DD	imagerel ??1bad_variant_access@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_variant_access@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@FGIAGBIG@bad?5variant?5access@
CONST	SEGMENT
??_C@_0BD@FGIAGBIG@bad?5variant?5access@ DB 'bad variant access', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_variant_access@std@@6B@
CONST	SEGMENT
??_7bad_variant_access@std@@6B@ DQ FLAT:??_R4bad_variant_access@std@@6B@ ; std::bad_variant_access::`vftable'
	DQ	FLAT:??_Ebad_variant_access@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@bad_variant_access@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@VValue@Json@@@std@@YAXQEAVValue@Json@@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 025051819H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@VValue@Json@@@?$_Default_allocator_traits@V?$allocator@VValue@Json@@@std@@@std@@SAXAEAV?$allocator@VValue@Json@@@1@QEAVValue@Json@@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z DB 060H
	DD	imagerel $ip2state$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z DD 025051819H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@VValue@Json@@@std@@YAPEAVValue@Json@@PEAV12@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z DD 025051c01H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z DD 025051d19H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z DD 025051801H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@QEAV10@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	045H
	DW	0202H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z DD 035054c19H
	DD	011d3322H
	DD	070160043H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0208H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z$rtcName$0 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>,char const *,unsigned __int64>
	DB	04eH
	DB	065H
	DB	077H
	DB	05fH
	DB	063H
	DB	061H
	DB	070H
	DB	061H
	DB	063H
	DB	069H
	DB	074H
	DB	079H
	DB	00H
	ORG $+2
??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z$rtcName$1 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>,char const *,unsigned __int64>
	DB	04eH
	DB	065H
	DB	077H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+7
??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z$rtcVarDesc DD 0f8H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>,char const *,unsigned __int64>
	DD	08H
	DQ	FLAT:??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z$rtcName$1
	DD	0b8H
	DD	08H
	DQ	FLAT:??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z$rtcName$0
	ORG $+96
??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z$rtcFrameData DD 02H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>,char const *,unsigned __int64>
	DD	00H
	DQ	FLAT:??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@QEBD_K@Z@SA@QEAD0101@Z DD 025052201H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_move_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 035051301H
	DD	010e3313H
	DD	07007002bH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@AEAU10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$integral_constant@_K$0A@@1@@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	040H
	DW	0213H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	0a9H, 02H
	DB	02H
	DB	0eaH
	DB	00H
	DB	01eH
	DB	02H
	DB	'-', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
	DD	imagerel $ip2state$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z DD 025054719H
	DD	0118231dH
	DD	07011003fH
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
	DD	01eaH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcName$0 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
	DB	041H
	DB	06cH
	DB	070H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+3
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcName$1 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
	DB	050H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+5
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcName$2 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
	DB	04eH
	DB	065H
	DB	077H
	DB	05fH
	DB	063H
	DB	061H
	DB	070H
	DB	061H
	DB	063H
	DB	069H
	DB	074H
	DB	079H
	DB	00H
	ORG $+2
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcName$3 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
	DB	04eH
	DB	065H
	DB	077H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+15
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcVarDesc DD 0d8H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
	DD	08H
	DQ	FLAT:??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcName$3
	DD	0b8H
	DD	08H
	DQ	FLAT:??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcName$2
	DD	088H
	DD	010H
	DQ	FLAT:??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcName$1
	DD	064H
	DD	01H
	DQ	FLAT:??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcName$0
	ORG $+192
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcFrameData DD 04H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
	DD	00H
	DQ	FLAT:??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03fH
	DW	0214H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	0a5H, 02H
	DB	02H
	DB	0ecH
	DB	00H
	DB	01eH
	DB	02H
	DB	'1', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
	DD	imagerel $ip2state$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD 025054619H
	DD	0117231cH
	DD	07010003fH
	DD	0500fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
	DD	01eaH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcName$0 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
	DB	041H
	DB	06cH
	DB	070H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+3
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcName$1 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
	DB	050H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+5
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcName$2 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
	DB	04eH
	DB	065H
	DB	077H
	DB	05fH
	DB	063H
	DB	061H
	DB	070H
	DB	061H
	DB	063H
	DB	069H
	DB	074H
	DB	079H
	DB	00H
	ORG $+2
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcName$3 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
	DB	04eH
	DB	065H
	DB	077H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+15
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcVarDesc DD 0d8H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
	DD	08H
	DQ	FLAT:??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcName$3
	DD	0b8H
	DD	08H
	DQ	FLAT:??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcName$2
	DD	088H
	DD	010H
	DQ	FLAT:??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcName$1
	DD	064H
	DD	01H
	DQ	FLAT:??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcName$0
	ORG $+192
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcFrameData DD 04H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
	DD	00H
	DQ	FLAT:??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 025051c01H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@QEBD_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011002fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0VValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@VValue@Json@@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_proxy_allocator@V?$allocator@VValue@Json@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@VValue@Json@@@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_proxy_allocator@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_proxy_allocator@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 06H
	DB	00H
	DB	00H
	DB	'r'
	DB	02H
	DB	09H, 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 025051811H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 025051319H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	040H
	DW	03e6H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	0edH, 03H
	DB	02H
	DB	'<'
	DB	04H
	DB	085H, 09H
	DB	02H
	DB	08cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	imagerel $ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 025054719H
	DD	0118231dH
	DD	070110033H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	0183H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$rtcName$0 DB 05fH ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
	DB	04fH
	DB	06bH
	DB	00H
	ORG $+12
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$rtcVarDesc DD 068H ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
	DD	010H
	DQ	FLAT:??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$rtcName$0
	ORG $+48
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$rtcFrameData DD 01H ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
	DD	00H
	DQ	FLAT:??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z DD 025051c01H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$0A@$$V$0A@@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$0A@@1@@Z DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	0b0H
	DB	02H
	DB	0eeH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
	DD	imagerel $ip2state$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD 025052211H
	DD	011d2322H
	DD	070160029H
	DD	05015H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	03fbH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0aH
	DB	00H
	DB	00H
	DB	'E', 04H
	DB	02H
	DB	'<'
	DB	04H
	DB	081H, 09H
	DB	02H
	DB	08cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 025054219H
	DD	01132318H
	DD	0700c0037H
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	01a3H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$rtcName$0 DB 05fH ; std::operator<<<std::char_traits<char> >
	DB	04fH
	DB	06bH
	DB	00H
	ORG $+12
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$rtcVarDesc DD 088H ; std::operator<<<std::char_traits<char> >
	DD	010H
	DQ	FLAT:??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$rtcName$0
	ORG $+48
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$rtcFrameData DD 01H ; std::operator<<<std::char_traits<char> >
	DD	00H
	DQ	FLAT:??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02aH
	DW	0171H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$catch$4 DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$3 DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$1 DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$0 DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DB 010H
	DB	00H
	DB	00H
	DB	0acH
	DB	04H
	DB	'4'
	DB	06H
	DB	'n'
	DB	04H
	DB	086H
	DB	08H
	DB	096H
	DB	04H
	DB	01aH
	DB	02H
	DB	018H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$main DB 02H
	DB	07H
	DB	012H
	DD	imagerel ??_R0?AVexception@std@@@8
	DB	0b0H
	DD	imagerel main$catch$4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$main DB	02H
	DB	02H
	DB	06H
	DB	08H
	DD	imagerel $handlerMap$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DB 0aH
	DB	0eH
	DD	imagerel main$dtor$0
	DB	028H
	DB	0eH
	DD	imagerel main$dtor$1
	DB	036H
	DD	imagerel main$dtor$3
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$main DB 038H
	DD	imagerel $stateUnwindMap$main
	DD	imagerel $tryMap$main
	DD	imagerel $ip2state$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	025053119H
	DD	010a230fH
	DD	070030047H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$main
	DD	022bH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
main$rtcName$0 DB 064H
	DB	06fH
	DB	063H
	DB	00H
main$rtcName$1 DB 065H
	DB	00H
	ORG $+10
main$rtcVarDesc DD 058H
	DD	08H
	DQ	FLAT:main$rtcName$1
	DD	028H
	DD	018H
	DQ	FLAT:main$rtcName$0
	ORG $+96
main$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:main$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Variant_raw_get@$02AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$02PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Variant_raw_get@$01AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$01PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@HPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Variant_raw_get@$00AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@_NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD 035051d01H
	DD	0118331dH
	DD	070110027H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z DD 025051d01H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$00$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBVValue@Json@@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$0A@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z DD 05051601H
	DD	01130316H
	DD	0700c0019H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@1@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Variant_raw_get@$04AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Variant_raw_get@$03AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Variant_raw_get@$0A@AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Variant_raw_get@$04AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Variant_raw_get@$03AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	0b1H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ DD 025053d19H
	DD	010e2313H
	DD	070070025H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ$rtcName$0 DB 05fH ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >
	DB	041H
	DB	06cH
	DB	070H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+7
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ$rtcVarDesc DD 024H ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >
	DD	01H
	DQ	FLAT:??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ$rtcName$0
	ORG $+48
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ$rtcFrameData DD 01H ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >
	DD	00H
	DQ	FLAT:??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@2@_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	094H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ DD 025053d19H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ$rtcName$0 DB 05fH ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >
	DB	041H
	DB	06cH
	DB	070H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+7
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ$rtcVarDesc DD 024H ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >
	DD	01H
	DQ	FLAT:??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ$rtcName$0
	ORG $+48
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ$rtcFrameData DD 01H ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >
	DD	00H
	DQ	FLAT:??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@$0A@@?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@VValue@Json@@@std@@V?$_Vector_val@U?$_Simple_types@VValue@Json@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VValue@Json@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAAEAV?$allocator@VValue@Json@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070031H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBAAEBVValue@Json@@_K@Z DD 035051801H
	DD	01133318H
	DD	0700c0023H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBA_KXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	0aeH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ DD 025053d19H
	DD	010e2313H
	DD	070070025H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ$rtcName$0 DB 05fH ; std::vector<Json::Value,std::allocator<Json::Value> >::~vector<Json::Value,std::allocator<Json::Value> >
	DB	041H
	DB	06cH
	DB	070H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+7
??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ$rtcVarDesc DD 024H ; std::vector<Json::Value,std::allocator<Json::Value> >::~vector<Json::Value,std::allocator<Json::Value> >
	DD	01H
	DQ	FLAT:??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ$rtcName$0
	ORG $+48
??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ$rtcFrameData DD 01H ; std::vector<Json::Value,std::allocator<Json::Value> >::~vector<Json::Value,std::allocator<Json::Value> >
	DD	00H
	DQ	FLAT:??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@VValue@Json@@@std@@QEAAXQEAVValue@Json@@_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Variant_raw_get@$0A@AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GValue@Json@@QEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@Value@Json@@QEAAX_K@Z DD 05051601H
	DD	01130316H
	DD	0700c0019H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fromFile@Value@Json@@SA?AV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	040H
	DW	0c47H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$33@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$32@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$31@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$30@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$29@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$28@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$27@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$26@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$25@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$24@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$23@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$22@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$21@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$20@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$18@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$17@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$16@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$15@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$14@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$12@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$11@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$10@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$9@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$8@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DB 088H
	DB	00H
	DB	00H
	DB	'I', 02H
	DB	02H
	DB	04H
	DB	00H
	DB	'V'
	DB	02H
	DB	'0'
	DB	06H
	DB	'e', 02H
	DB	08H
	DB	'^'
	DB	0aH
	DB	'"'
	DB	08H
	DB	01aH
	DB	06H
	DB	'z'
	DB	0cH
	DB	'^'
	DB	0eH
	DB	'"'
	DB	0cH
	DB	01aH
	DB	06H
	DB	'X'
	DB	00H
	DB	082H
	DB	010H
	DB	'6'
	DB	014H
	DB	0e9H, 04H
	DB	016H
	DB	080H
	DB	018H
	DB	'^'
	DB	01aH
	DB	'^'
	DB	01cH
	DB	'^'
	DB	01eH
	DB	'z'
	DB	' '
	DB	'^'
	DB	'"'
	DB	'('
	DB	' '
	DB	01aH
	DB	01eH
	DB	01aH
	DB	01cH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	018H
	DB	01aH
	DB	016H
	DB	01aH
	DB	014H
	DB	'z'
	DB	'$'
	DB	080H
	DB	'&'
	DB	'^'
	DB	'('
	DB	'^'
	DB	'*'
	DB	'^'
	DB	','
	DB	'z'
	DB	'.'
	DB	'^'
	DB	'0'
	DB	'('
	DB	'.'
	DB	01aH
	DB	','
	DB	01aH
	DB	'*'
	DB	01aH
	DB	'('
	DB	01aH
	DB	'&'
	DB	01aH
	DB	'$'
	DB	01aH
	DB	014H
	DB	'z'
	DB	'2'
	DB	'^'
	DB	'4'
	DB	'('
	DB	'2'
	DB	01aH
	DB	014H
	DB	'^'
	DB	00H
	DB	0c2H
	DB	'6'
	DB	'^'
	DB	'8'
	DB	'z'
	DB	':'
	DB	'R'
	DB	'8'
	DB	01aH
	DB	'6'
	DB	01aH
	DB	00H
	DB	0f8H
	DB	'<'
	DB	'R'
	DB	00H
	DB	09eH
	DB	'>'
	DB	'r'
	DB	'@'
	DB	'n'
	DB	'>'
	DB	01aH
	DB	00H
	DB	0a2H
	DB	'B'
	DB	'r'
	DB	'D'
	DB	'n'
	DB	'B'
	DB	01aH
	DB	00H
	DB	088H
	DB	'F'
	DB	'R'
	DB	00H
	DB	0d8H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DB 046H
	DB	0eH
	DD	imagerel ?dtor$0@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$1@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	07eH
	DD	imagerel ?dtor$4@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	04dH
	DB	02H
	DD	imagerel ?dtor$7@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	036H
	DD	imagerel ?dtor$8@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	0fdH
	DB	02H
	DD	imagerel ?dtor$8@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	036H
	DD	imagerel ?dtor$9@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$10@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$11@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$12@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$13@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$14@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$15@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	09dH
	DB	02H
	DD	imagerel ?dtor$16@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	036H
	DD	imagerel ?dtor$17@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$18@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$19@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$20@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$21@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$22@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	0ddH
	DB	04H
	DD	imagerel ?dtor$23@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	036H
	DD	imagerel ?dtor$24@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	07dH
	DB	08H
	DD	imagerel ?dtor$25@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	036H
	DD	imagerel ?dtor$26@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$27@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	07dH
	DB	09H
	DD	imagerel ?dtor$28@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	0ddH
	DB	09H
	DD	imagerel ?dtor$29@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	036H
	DD	imagerel ?dtor$30@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	08dH
	DB	0aH
	DD	imagerel ?dtor$31@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	036H
	DD	imagerel ?dtor$32@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
	DB	03dH
	DB	0bH
	DD	imagerel ?dtor$33@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
	DD	imagerel $ip2state$?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z DD 025054719H
	DD	0118231dH
	DD	0701101dbH
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
	DD	0ecaH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcName$0 DB 072H ; Json::Value::stringify
	DB	065H
	DB	073H
	DB	075H
	DB	06cH
	DB	074H
	DB	00H
	ORG $+1
?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcName$1 DB 072H ; Json::Value::stringify
	DB	065H
	DB	073H
	DB	075H
	DB	06cH
	DB	074H
	DB	00H
	ORG $+1
?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcName$2 DB 03cH ; Json::Value::stringify
	DB	062H
	DB	065H
	DB	067H
	DB	069H
	DB	06eH
	DB	03eH
	DB	024H
	DB	04cH
	DB	030H
	DB	00H
	ORG $+5
?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcName$3 DB 03cH ; Json::Value::stringify
	DB	065H
	DB	06eH
	DB	064H
	DB	03eH
	DB	024H
	DB	04cH
	DB	030H
	DB	00H
	ORG $+7
?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcVarDesc DD 0148H ; Json::Value::stringify
	DD	08H
	DQ	FLAT:?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcName$3
	DD	0128H
	DD	08H
	DQ	FLAT:?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcName$2
	DD	0a8H
	DD	028H
	DQ	FLAT:?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcName$1
	DD	028H
	DD	028H
	DQ	FLAT:?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcName$0
	ORG $+192
?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcFrameData DD 04H ; Json::Value::stringify
	DD	00H
	DQ	FLAT:?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Value@Json@@QEAAAEAV01@$$QEAV01@@Z DD 025061901H
	DD	01142319H
	DD	0700d001cH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1Value@Json@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1Value@Json@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1Value@Json@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Value@Json@@QEAA@XZ DD 025051319H
	DD	010e2313H
	DD	070070029H
	DD	05006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1Value@Json@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Value@Json@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get@?$_Variant_storage_@$00_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEB_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get@?$_Variant_storage_@$00HNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBHXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get@?$_Variant_storage_@$00NPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBNXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGBAAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGAAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD 025051d01H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@D$$V@std@@YAPEADQEAD@Z DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unfancy@D@std@@YAPEADPEAD@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 025051801H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z DD 025051d01H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	040H
	DW	0213H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	0a9H, 02H
	DB	02H
	DB	0eaH
	DB	00H
	DB	01eH
	DB	02H
	DB	'-', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
	DD	imagerel $ip2state$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 025054719H
	DD	0118231dH
	DD	07011003fH
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
	DD	01eaH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcName$0 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	DB	041H
	DB	06cH
	DB	070H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+3
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcName$1 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	DB	050H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+5
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcName$2 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	DB	04eH
	DB	065H
	DB	077H
	DB	05fH
	DB	063H
	DB	061H
	DB	070H
	DB	061H
	DB	063H
	DB	069H
	DB	074H
	DB	079H
	DB	00H
	ORG $+2
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcName$3 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	DB	04eH
	DB	065H
	DB	077H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+15
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcVarDesc DD 0d8H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	DD	08H
	DQ	FLAT:??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcName$3
	DD	0b8H
	DD	08H
	DQ	FLAT:??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcName$2
	DD	088H
	DD	010H
	DQ	FLAT:??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcName$1
	DD	064H
	DD	01H
	DQ	FLAT:??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcName$0
	ORG $+192
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcFrameData DD 04H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	DD	00H
	DQ	FLAT:??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_size@_K_K@std@@YA_K_K@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 025050f01H
	DD	010a230fH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z DD 035051801H
	DD	01133318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gruntime_error@std@@UEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1runtime_error@std@@UEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@PEBD@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z DD 025053201H
	DD	01142319H
	DD	0700d0031H
	DD	0500cH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z$rtcName$0 DB 05fH ; std::to_string
	DB	053H
	DB	074H
	DB	072H
	DB	00H
	ORG $+3
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z$rtcName$1 DB 05fH ; std::to_string
	DB	05fH
	DB	024H
	DB	041H
	DB	072H
	DB	072H
	DB	061H
	DB	079H
	DB	050H
	DB	061H
	DB	064H
	DB	00H
	ORG $+12
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z$rtcVarDesc DD 088H ; std::to_string
	DD	08H
	DQ	FLAT:?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z$rtcName$1
	DD	048H
	DD	028H
	DQ	FLAT:?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z$rtcName$0
	ORG $+96
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z$rtcFrameData DD 02H ; std::to_string
	DD	00H
	DQ	FLAT:?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03aH
	DW	0106H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD 025054119H
	DD	01122317H
	DD	0700b0037H
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	01a8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z$rtcName$0 DB 05fH ; std::_Integral_to_string<char,int>
	DB	042H
	DB	075H
	DB	066H
	DB	066H
	DB	00H
	ORG $+10
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z$rtcVarDesc DD 028H ; std::_Integral_to_string<char,int>
	DD	015H
	DQ	FLAT:??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z$rtcName$0
	ORG $+48
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z$rtcFrameData DD 01H ; std::_Integral_to_string<char,int>
	DD	00H
	DQ	FLAT:??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	040H
	DB	0f7H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 025054719H
	DD	0118231dH
	DD	070110025H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z$rtcName$0 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	DB	04dH
	DB	061H
	DB	073H
	DB	06bH
	DB	065H
	DB	064H
	DB	00H
	ORG $+8
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z$rtcVarDesc DD 028H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	DD	08H
	DQ	FLAT:?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z$rtcName$0
	ORG $+48
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z$rtcFrameData DD 01H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	DD	00H
	DQ	FLAT:?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	0c7H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 025053d19H
	DD	010e2313H
	DD	070070031H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0178H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ$rtcName$0 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	DB	041H
	DB	06cH
	DB	06cH
	DB	06fH
	DB	063H
	DB	05fH
	DB	06dH
	DB	061H
	DB	078H
	DB	00H
	ORG $+5
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ$rtcVarDesc DD 028H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	DD	08H
	DQ	FLAT:?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ$rtcName$0
	ORG $+48
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ$rtcFrameData DD 01H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	DD	00H
	DQ	FLAT:?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD 035051801H
	DD	01133318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	0baH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 025053d19H
	DD	010e2313H
	DD	070070025H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcName$0 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	DB	041H
	DB	06cH
	DB	070H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+7
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcVarDesc DD 024H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	DD	01H
	DQ	FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcName$0
	ORG $+48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcFrameData DD 01H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	DD	00H
	DQ	FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 025051801H
	DD	01132318H
	DD	0700c0035H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	044H
	DW	04d8H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DB 0aH
	DB	00H
	DB	00H
	DB	085H, 02H
	DB	02H
	DB	0e9H, 0cH
	DB	04H
	DB	'M', 03H
	DB	02H
	DB	01aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z DD 025054b19H
	DD	011c2321H
	DD	070150091H
	DD	05014H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
	DD	047aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcName$0 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	DB	04eH
	DB	065H
	DB	077H
	DB	05fH
	DB	063H
	DB	061H
	DB	070H
	DB	061H
	DB	063H
	DB	069H
	DB	074H
	DB	079H
	DB	00H
	ORG $+2
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcName$1 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	DB	041H
	DB	06cH
	DB	070H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcName$2 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	DB	050H
	DB	072H
	DB	06fH
	DB	078H
	DB	079H
	DB	00H
	ORG $+5
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcName$3 DB 05fH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	DB	046H
	DB	061H
	DB	06eH
	DB	063H
	DB	079H
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+14
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcVarDesc DD 0238H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	DD	08H
	DQ	FLAT:??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcName$3
	DD	0208H
	DD	010H
	DQ	FLAT:??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcName$2
	DD	01e4H
	DD	01H
	DQ	FLAT:??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcName$1
	DD	01c8H
	DD	08H
	DQ	FLAT:??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcName$0
	ORG $+192
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcFrameData DD 04H ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	DD	00H
	DQ	FLAT:??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DB 060H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 025051819H
	DD	01132318H
	DD	0700c002bH
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DB 06H
	DB	00H
	DB	00H
	DB	098H
	DB	02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 025051d11H
	DD	0118231dH
	DD	070110021H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
	DB	05H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 031001H
	DD	0700c4210H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	08eH
	DB	02H
	DB	'V'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 025051811H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 035051d01H
	DD	0118331dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$allocator@D@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Basic_container_proxy_ptr12@std@@IEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03bH
	DB	08eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z DD 025054219H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z$rtcName$0 DB 05fH ; std::_Container_base12::_Swap_proxy_and_iterators_locked
	DB	04cH
	DB	06fH
	DB	063H
	DB	06bH
	DB	00H
	ORG $+10
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z$rtcVarDesc DD 024H ; std::_Container_base12::_Swap_proxy_and_iterators_locked
	DD	04H
	DQ	FLAT:?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z$rtcName$0
	ORG $+48
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z$rtcFrameData DD 01H ; std::_Container_base12::_Swap_proxy_and_iterators_locked
	DD	00H
	DQ	FLAT:?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	082H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD 025053d19H
	DD	010e2313H
	DD	070070021H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcName$0 DB 05fH ; std::_Container_base12::_Orphan_all_locked_v3
	DB	04cH
	DB	06fH
	DB	063H
	DB	06bH
	DB	00H
	ORG $+10
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcVarDesc DD 024H ; std::_Container_base12::_Orphan_all_locked_v3
	DD	04H
	DQ	FLAT:?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcName$0
	ORG $+48
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcFrameData DD 01H ; std::_Container_base12::_Orphan_all_locked_v3
	DD	00H
	DQ	FLAT:?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD 025051301H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_base12@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 035051801H
	DD	01133318H
	DD	0700c002fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	070030023H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_variant_access@std@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	070030023H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_variant_access@std@@UEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_variant_access@std@@QEAA@AEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_variant_access@std@@UEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@bad_variant_access@std@@UEBAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_variant_access@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03bH
	DB	0bbH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBD@Z DD 025054219H
	DD	01132318H
	DD	0700c0023H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0108H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
??0exception@std@@QEAA@QEBD@Z$rtcName$0 DB 05fH		; std::exception::exception
	DB	049H
	DB	06eH
	DB	069H
	DB	074H
	DB	044H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+6
??0exception@std@@QEAA@QEBD@Z$rtcVarDesc DD 028H	; std::exception::exception
	DD	010H
	DQ	FLAT:??0exception@std@@QEAA@QEBD@Z$rtcName$0
	ORG $+48
??0exception@std@@QEAA@QEBD@Z$rtcFrameData DD 01H	; std::exception::exception
	DD	00H
	DQ	FLAT:??0exception@std@@QEAA@QEBD@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@XZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eof@?$_Narrow_char_traits@DH@std@@SAHXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z DD 025051601H
	DD	01112316H
	DD	0700a001fH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z DD 025051d01H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 025051d01H
	DD	0118231dH
	DD	07011002dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 025051d01H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_constant_evaluated@std@@YA_NXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	098H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_scprintf DD 025054c19H
	DD	011d2322H
	DD	070160029H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0138H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_scprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
_scprintf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:_scprintf$rtcName$0
	ORG $+48
_scprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_scprintf$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0acH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf_s DD 035054c19H
	DD	011d3322H
	DD	07016002bH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0148H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf_s$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf_s$rtcVarDesc DD 058H
	DD	08H
	DQ	FLAT:sprintf_s$rtcName$0
	ORG $+48
sprintf_s$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf_s$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vscprintf_l DD 035051d01H
	DD	0118331dH
	DD	070110023H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_s_l DD 035052201H
	DD	011d3322H
	DD	070160023H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??2@YAPEAX_KPEAX@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX_K@Z DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__empty_global_delete@@YAXPEAX@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??trueLiteral$initializer$@Parser@Detail@Json@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; ??trueLiteral$initializer$@Parser@Detail@Json@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??falseLiteral$initializer$@Parser@Detail@Json@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; ??falseLiteral$initializer$@Parser@Detail@Json@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$destroy_at@VValue@Json@@@std@@YAXQEAVValue@Json@@@Z
_TEXT	SEGMENT
_Location$ = 224
??$destroy_at@VValue@Json@@@std@@YAXQEAVValue@Json@@@Z PROC ; std::destroy_at<Json::Value>, COMDAT

; 334  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 335  : #if _HAS_CXX20
; 336  :     if constexpr (is_array_v<_Ty>) {
; 337  :         _STD _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 338  :     } else
; 339  : #endif // _HAS_CXX20
; 340  :     {
; 341  :         _Location->~_Ty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Location$[rbp]
	call	??_GValue@Json@@QEAAPEAXI@Z
	npad	1

; 342  :     }
; 343  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$destroy_at@VValue@Json@@@std@@YAXQEAVValue@Json@@@Z ENDP ; std::destroy_at<Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 324  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 325  :     if constexpr (is_array_v<_Ty>) {
; 326  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 327  :     } else {
; 328  :         _Obj.~_Ty();
; 329  :     }
; 330  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 224
_Bytes$ = 232
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 265  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 266  :     // deallocate storage allocated by _Allocate
; 267  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 268  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Deallocate

; 269  :         ::operator delete(_Ptr);

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??3@YAXPEAX@Z				; operator delete
	npad	1

; 270  :         return;

	jmp	SHORT $LN1@Deallocate
$LN2@Deallocate:

; 271  :     }
; 272  : #endif // _HAS_CXX20
; 273  : 
; 274  : #ifdef __cpp_aligned_new
; 275  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 276  :         size_t _Passed_align = _Align;
; 277  : #if defined(_M_IX86) || defined(_M_X64)
; 278  :         if (_Bytes >= _Big_allocation_threshold) {
; 279  :             // boost the alignment of big allocations to help autovectorization
; 280  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 281  :         }
; 282  : #endif // defined(_M_IX86) || defined(_M_X64)
; 283  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 284  :     } else
; 285  : #endif // defined(__cpp_aligned_new)
; 286  :     {
; 287  : #if defined(_M_IX86) || defined(_M_X64)
; 288  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rbp], 4096		; 00001000H
	jb	SHORT $LN3@Deallocate

; 289  :             // boost the alignment of big allocations to help autovectorization
; 290  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rbp]
	lea	rcx, QWORD PTR _Ptr$[rbp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN3@Deallocate:

; 291  :         }
; 292  : #endif // defined(_M_IX86) || defined(_M_X64)
; 293  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rbp]
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN1@Deallocate:

; 294  :     }
; 295  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z
_TEXT	SEGMENT
$T1 = 200
_Location$ = 256
<_Args_0>$ = 264
??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z PROC ; std::construct_at<char *,char * &>, COMDAT

; 508  :     noexcept(noexcept(::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 509  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rbp]
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR $T1[rbp]

; 510  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z ENDP ; std::construct_at<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$destroy@VValue@Json@@@?$_Default_allocator_traits@V?$allocator@VValue@Json@@@std@@@std@@SAXAEAV?$allocator@VValue@Json@@@1@QEAVValue@Json@@@Z
_TEXT	SEGMENT
__formal$ = 224
_Ptr$ = 232
??$destroy@VValue@Json@@@?$_Default_allocator_traits@V?$allocator@VValue@Json@@@std@@@std@@SAXAEAV?$allocator@VValue@Json@@@1@QEAVValue@Json@@@Z PROC ; std::_Default_allocator_traits<std::allocator<Json::Value> >::destroy<Json::Value>, COMDAT

; 741  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 742  : #if _HAS_CXX20
; 743  :         _STD destroy_at(_Ptr);

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$destroy_at@VValue@Json@@@std@@YAXQEAVValue@Json@@@Z ; std::destroy_at<Json::Value>
	npad	1

; 744  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 745  :         _Ptr->~_Uty();
; 746  : #endif // ^^^ !_HAS_CXX20 ^^^
; 747  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$destroy@VValue@Json@@@?$_Default_allocator_traits@V?$allocator@VValue@Json@@@std@@@std@@SAXAEAV?$allocator@VValue@Json@@@1@QEAVValue@Json@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Json::Value> >::destroy<Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> *>, COMDAT

; 324  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 325  :     if constexpr (is_array_v<_Ty>) {
; 326  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 327  :     } else {
; 328  :         _Obj.~_Ty();
; 329  :     }
; 330  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	mov	rax, QWORD PTR _Ptr$[rbp]
	add	rax, 16
	mov	rcx, rax
	call	??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@AEAU10@@Z ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >
	npad	1

; 318  :         _Freenode0(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
	npad	1

; 319  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Destroy_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Destroy_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@@Z PROC ; std::_Destroy_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >, COMDAT

; 324  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 325  :     if constexpr (is_array_v<_Ty>) {
; 326  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 327  :     } else {
; 328  :         _Obj.~_Ty();
; 329  :     }
; 330  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Destroy_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z
_TEXT	SEGMENT
_Location$ = 224
??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z PROC ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >, COMDAT

; 334  : _CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 335  : #if _HAS_CXX20
; 336  :     if constexpr (is_array_v<_Ty>) {
; 337  :         _STD _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 338  :     } else
; 339  : #endif // _HAS_CXX20
; 340  :     {
; 341  :         _Location->~_Ty();

	xor	edx, edx
	mov	rcx, QWORD PTR _Location$[rbp]
	call	??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAAPEAXI@Z
	npad	1

; 342  :     }
; 343  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z ENDP ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Unfancy@VValue@Json@@@std@@YAPEAVValue@Json@@PEAV12@@Z
_TEXT	SEGMENT
_Ptr$ = 224
??$_Unfancy@VValue@Json@@@std@@YAPEAVValue@Json@@PEAV12@@Z PROC ; std::_Unfancy<Json::Value>, COMDAT

; 72   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 73   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rbp]

; 74   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Unfancy@VValue@Json@@@std@@YAPEAVValue@Json@@PEAV12@@Z ENDP ; std::_Unfancy<Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 4
_Count$ = 256
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 116  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 117  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rbp], 0

; 118  : 
; 119  :     if constexpr (_Overflow_is_possible) {
; 120  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 121  :         if (_Count > _Max_possible) {
; 122  :             _Throw_bad_array_new_length(); // multiply overflow
; 123  :         }
; 124  :     }
; 125  : 
; 126  :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rbp]

; 127  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Lhs$ = 224
_Rhs$ = 232
??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z PROC ; std::_Allocators_equal<std::allocator<char> >, COMDAT

; 2291 : _NODISCARD constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2292 :     if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
; 2293 :         return true;

	mov	al, 1

; 2294 :     } else {
; 2295 :         return _Lhs == _Rhs;
; 2296 :     }
; 2297 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z ENDP ; std::_Allocators_equal<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
_Val1$ = 240
??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>, COMDAT

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
$T1 = 200
_Obj$ = 256
<_Args_0>$ = 264
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 515  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 516  : #if _HAS_CXX20
; 517  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Construct_

; 518  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, rax
	call	??$construct_at@PEADAEAPEAD@std@@YAPEAPEADQEAPEADAEAPEAD@Z ; std::construct_at<char *,char * &>
	npad	1

; 519  :     } else

	jmp	SHORT $LN3@Construct_
$LN2@Construct_:

; 520  : #endif // _HAS_CXX20
; 521  :     {
; 522  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN3@Construct_:

; 523  :     }
; 524  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1532 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__680F61A7_type_traits
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1534 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >, COMDAT

; 1532 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__680F61A7_type_traits
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1534 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z
_TEXT	SEGMENT
_First$ = 224
_Last$ = 232
_Al$ = 240
??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Value> >, COMDAT

; 1102 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1103 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1104 :     using _Ty = typename _Alloc::value_type;
; 1105 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1106 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
	mov	rax, QWORD PTR _First$[rbp]
	add	rax, 24
	mov	QWORD PTR _First$[rbp], rax
$LN4@Destroy_ra:
	mov	rax, QWORD PTR _Last$[rbp]
	cmp	QWORD PTR _First$[rbp], rax
	je	SHORT $LN3@Destroy_ra

; 1107 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));

	mov	rcx, QWORD PTR _First$[rbp]
	call	??$_Unfancy@VValue@Json@@@std@@YAPEAVValue@Json@@PEAV12@@Z ; std::_Unfancy<Json::Value>
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$destroy@VValue@Json@@@?$_Default_allocator_traits@V?$allocator@VValue@Json@@@std@@@std@@SAXAEAV?$allocator@VValue@Json@@@1@QEAVValue@Json@@@Z ; std::_Default_allocator_traits<std::allocator<Json::Value> >::destroy<Json::Value>
	npad	1

; 1108 :         }

	jmp	SHORT $LN2@Destroy_ra
$LN3@Destroy_ra:

; 1109 :     }
; 1110 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> *>
	npad	1

; 311  :         _Destroy_in_place(_Ptr->_Prev);

	mov	rax, QWORD PTR _Ptr$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> *>
	npad	1

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >::deallocate
	npad	1

; 313  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Pnode$ = 8
_Pnext$1 = 40
_Al$ = 288
_Head$ = 296
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 324  :         _Head->_Prev->_Next = nullptr;

	mov	rax, QWORD PTR _Head$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

	mov	rax, QWORD PTR _Head$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnode$[rbp], rax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

	jmp	SHORT $LN4@Free_non_h
$LN2@Free_non_h:
	mov	rax, QWORD PTR _Pnext$1[rbp]
	mov	QWORD PTR _Pnode$[rbp], rax
$LN4@Free_non_h:
	cmp	QWORD PTR _Pnode$[rbp], 0
	je	SHORT $LN3@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

	mov	rax, QWORD PTR _Pnode$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Pnext$1[rbp], rax

; 329  :             _Freenode(_Al, _Pnode);

	mov	rdx, QWORD PTR _Pnode$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Freenode@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Freenode<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
	npad	1

; 330  :         }

	jmp	SHORT $LN2@Free_non_h
$LN3@Free_non_h:

; 331  :     }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@QEAV10@@Z
_TEXT	SEGMENT
_First$ = 224
_Last$ = 232
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@QEAV10@@Z PROC ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > *>, COMDAT

; 1113 : _CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1114 : #if _HAS_CXX20
; 1115 :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Destroy_ra

; 1116 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
	mov	rax, QWORD PTR _First$[rbp]
	add	rax, 8
	mov	QWORD PTR _First$[rbp], rax
$LN4@Destroy_ra:
	mov	rax, QWORD PTR _Last$[rbp]
	cmp	QWORD PTR _First$[rbp], rax
	je	SHORT $LN5@Destroy_ra

; 1117 :             _STD _Destroy_in_place(*_First);

	mov	rcx, QWORD PTR _First$[rbp]
	call	??$_Destroy_in_place@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@YAXAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@@Z ; std::_Destroy_in_place<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >
	npad	1

; 1118 :         }

	jmp	SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 1119 :     } else
; 1120 : #endif // _HAS_CXX20
; 1121 :     { // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1122 :         if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1123 :             for (; _First != _Last; ++_First) {
; 1124 :                 _STD _Destroy_in_place(*_First);
; 1125 :             }
; 1126 :         }
; 1127 :     }
; 1128 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@QEAV10@@Z ENDP ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@@Z
_TEXT	SEGMENT
__formal$ = 224
_Ptr$ = 232
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >, COMDAT

; 741  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 742  : #if _HAS_CXX20
; 743  :         _STD destroy_at(_Ptr);

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$destroy_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAXQEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z ; std::destroy_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >
	npad	1

; 744  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 745  :         _Ptr->~_Uty();
; 746  : #endif // ^^^ !_HAS_CXX20 ^^^
; 747  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 8
_Old_size$ = 40
_New_size$ = 72
_Old_capacity$ = 104
_New_capacity$ = 136
_Al$ = 168
_New_ptr$ = 200
_Raw_new$ = 232
_Old_ptr$5 = 264
__$ArrayPad$ = 472
this$ = 512
_Size_increase$ = 520
_Fn$ = 528
<_Args_0>$ = 536
<_Args_1>$ = 544
??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>,char const *,unsigned __int64>, COMDAT

; 2931 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 536				; 00000218H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rdi, QWORD PTR [rsp+48]
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+568]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2932 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2933 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2934 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 2935 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_size$[rbp], rax

; 2936 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rbp]
	cmp	rax, QWORD PTR _Size_increase$[rbp]
	jae	SHORT $LN2@Reallocate

; 2937 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 2938 :         }
; 2939 : 
; 2940 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rbp]
	mov	rcx, QWORD PTR _Old_size$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rbp], rax

; 2941 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR _Old_capacity$[rbp], rax

; 2942 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rbp], rax

; 2943 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rbp], rax

; 2944 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rbp], rax

; 2945 : 
; 2946 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2947 :         _ASAN_STRING_REMOVE(*this);
; 2948 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_size$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 2949 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_capacity$[rbp]
	mov	QWORD PTR [rax+32], rcx

; 2950 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rbp], rax

; 2951 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rbp], 15
	jbe	SHORT $LN3@Reallocate

; 2952 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Old_ptr$5[rbp], rax

; 2953 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$5[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR <_Args_1>$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR <_Args_0>$[rbp]
	mov	r8, QWORD PTR _Old_size$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Raw_new$[rbp]
	call	??R<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@QEBD_K@Z@SA@QEAD0101@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>::operator()
	npad	1

; 2954 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rbp]
	mov	rdx, QWORD PTR _Old_ptr$5[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	npad	1

; 2955 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_ptr$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 2956 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 2957 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	mov	rcx, QWORD PTR <_Args_1>$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR <_Args_0>$[rbp]
	mov	r8, QWORD PTR _Old_size$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Raw_new$[rbp]
	call	??R<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@QEBD_K@Z@SA@QEAD0101@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>::operator()
	npad	1

; 2958 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	lea	rdx, QWORD PTR _New_ptr$[rbp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 2959 :         }
; 2960 : 
; 2961 :         _ASAN_STRING_CREATE(*this);
; 2962 :         return *this;

	mov	rax, QWORD PTR this$[rbp]
$LN5@Reallocate:

; 2963 :     }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+488]
	pop	rdi
	pop	rbp
	ret	0
??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??R<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@QEBD_K@Z@SA@QEAD0101@Z
_TEXT	SEGMENT
$T1 = 196
_New_ptr$ = 256
_Old_ptr$ = 264
_Old_size$ = 272
_Ptr$ = 280
_Count$ = 288
??R<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@QEBD_K@Z@SA@QEAD0101@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>::operator(), COMDAT

; 3006 :                 const size_type _Count) _STATIC_LAMBDA {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 3007 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rbp]
	mov	rdx, QWORD PTR _Old_ptr$[rbp]
	mov	rcx, QWORD PTR _New_ptr$[rbp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 3008 :                 _STD _Traits_copy_batch<_Traits>(_New_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rbp]
	mov	rcx, QWORD PTR _New_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, rax
	call	??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ; std::_Traits_copy_batch<std::char_traits<char>,char>
	npad	1

; 3009 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rbp], 0
	mov	rax, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR _Old_size$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _New_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3010 :             },

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??R<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV12@QEBD_K@Z@SA@QEAD0101@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Traits_move_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 224
_First2$ = 232
_Count$ = 240
??$_Traits_move_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z PROC ; std::_Traits_move_batch<std::char_traits<char>,char>, COMDAT

; 546  :     _In_reads_(_Count) const _UElem* const _First2, const size_t _Count) noexcept {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 547  :     _STL_INTERNAL_STATIC_ASSERT(_Is_any_of_v<_UElem, _Traits_ch_t<_Traits>, volatile _Traits_ch_t<_Traits>>);
; 548  : 
; 549  :     if constexpr (is_volatile_v<_UElem>) {
; 550  :         bool _Loop_forward = true;
; 551  : 
; 552  :         for (const _UElem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 553  :             if (_First1 == _Src) {
; 554  :                 _Loop_forward = false;
; 555  :                 break;
; 556  :             }
; 557  :         }
; 558  : 
; 559  :         if (_Loop_forward) {
; 560  :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 561  :                 _Traits::assign(_First1[_Idx], _Traits_ch_t<_Traits>{_First2[_Idx]});
; 562  :             }
; 563  :         } else {
; 564  :             for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 565  :                 _Traits::assign(_First1[_Idx - 1], _Traits_ch_t<_Traits>{_First2[_Idx - 1]});
; 566  :             }
; 567  :         }
; 568  :     } else {
; 569  :         (void) _Traits::move(_First1, _First2, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _First2$[rbp]
	mov	rcx, QWORD PTR _First1$[rbp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move
	npad	1

; 570  :     }
; 571  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Traits_move_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ENDP ; std::_Traits_move_batch<std::char_traits<char>,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Block_size$ = 8
_Ptr_container$ = 40
_Ptr$ = 72
_Bytes$ = 320
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 186  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 344				; 00000158H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 187  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 188  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rbp]
	add	rax, 47					; 0000002fH
	mov	QWORD PTR _Block_size$[rbp], rax

; 189  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rbp]
	cmp	QWORD PTR _Block_size$[rbp], rax
	ja	SHORT $LN2@Allocate_m

; 190  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Allocate_m:

; 191  :     }
; 192  : 
; 193  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rbp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rbp], rax

; 194  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rbp], 0
	jne	SHORT $LN3@Allocate_m
	lea	rax, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 194				; 000000c2H
	lea	rdx, OFFSET FLAT:??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN5@Allocate_m
	int	3
	xor	eax, eax
$LN5@Allocate_m:
	mov	ecx, 5
	int	41					; 00000029H
$LN3@Allocate_m:

; 195  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rbp]
	add	rax, 47					; 0000002fH
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rbp], rax

; 196  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rbp]
	mov	rdx, QWORD PTR _Ptr_container$[rbp]
	mov	QWORD PTR [rcx+rax], rdx

; 197  : 
; 198  : #ifdef _DEBUG
; 199  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

	mov	eax, 8
	imul	rax, rax, -2
	mov	rcx, QWORD PTR _Ptr$[rbp]
	mov	rdx, -361700864190383366		; fafafafafafafafaH
	mov	QWORD PTR [rcx+rax], rdx

; 200  : #endif // defined(_DEBUG)
; 201  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rbp]
$LN4@Allocate_m:

; 202  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >, COMDAT

; 1532 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__680F61A7_type_traits
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1534 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$?0$$V@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$integral_constant@_K$0A@@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0$$V@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$integral_constant@_K$0A@@1@@Z PROC ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><>, COMDAT

; 351  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0$$V@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$integral_constant@_K$0A@@1@@Z ENDP ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 718  :     /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 719  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 720  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 721  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@deallocate

; 722  :             _Al.deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
	npad	1

; 723  :         } else

	jmp	SHORT $LN3@deallocate
$LN2@deallocate:

; 724  : #endif // _HAS_CXX20
; 725  :         {
; 726  :             (void) _Al;
; 727  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rbp], 16
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1
$LN3@deallocate:

; 728  :         }
; 729  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z
_TEXT	SEGMENT
_My_data$ = 8
_Al$ = 40
_Alproxy$ = 68
_Proxy$ = 104
_New_capacity$ = 152
_New_ptr$ = 184
$T7 = 404
$T8 = 436
__$ArrayPad$ = 456
this$ = 496
_Arg$ = 504
_Count$ = 512
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>, COMDAT

; 921  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 504				; 000001f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+536]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 922  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 923  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 924  : 
; 925  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 926  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 927  :         } else {
; 928  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cvptr<_Char_or_ptr>::value);
; 929  :         }
; 930  : 
; 931  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rbp], rax
	jbe	SHORT $LN2@Construct

; 932  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 933  :         }
; 934  : 
; 935  :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rbp], rax

; 936  :         auto _Alproxy = _STD _Get_proxy_allocator(_Al);

	mov	rdx, QWORD PTR _Al$[rbp]
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
	npad	1

; 937  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rbp]
	lea	rdx, QWORD PTR _Alproxy$[rbp]
	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1

; 938  : 
; 939  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rbp], 15
	ja	SHORT $LN3@Construct

; 940  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 941  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	QWORD PTR [rax+32], 15

; 942  : 
; 943  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 944  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 945  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 946  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 947  :                 _STD _Traits_copy_batch<_Traits>(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Arg$[rbp]
	mov	rcx, rax
	call	??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ; std::_Traits_copy_batch<std::char_traits<char>,char>
	npad	1

; 948  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T7[rbp], 0
	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	lea	rax, QWORD PTR [rax+rcx+8]
	lea	rdx, QWORD PTR $T7[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 949  :             } else { // _Strat == _Construct_strategy::_From_string
; 950  : #ifdef _INSERT_STRING_ANNOTATION
; 951  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 952  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 953  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 954  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 955  :             }
; 956  : 
; 957  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 958  :             return;

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
	jmp	$LN4@Construct
$LN3@Construct:

; 959  :         }
; 960  : 
; 961  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rbp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rbp], rax

; 962  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rbp], rax

; 963  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	lea	rdx, QWORD PTR _New_ptr$[rbp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1

; 964  : 
; 965  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 966  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_capacity$[rbp]
	mov	QWORD PTR [rax+32], rcx

; 967  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 968  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 969  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 970  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 971  :             _STD _Traits_copy_batch<_Traits>(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Arg$[rbp]
	mov	rcx, rax
	call	??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ; std::_Traits_copy_batch<std::char_traits<char>,char>
	npad	1

; 972  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T8[rbp], 0
	mov	rcx, QWORD PTR _New_ptr$[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rbp]
	lea	rdx, QWORD PTR $T8[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 973  :         } else { // _Strat == _Construct_strategy::_From_string
; 974  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 975  :         }
; 976  : 
; 977  :         _ASAN_STRING_CREATE(*this);
; 978  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 979  :     }

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN4@Construct:
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+472]
	pop	rdi
	pop	rbp
	ret	0
$LN6@Construct:
??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 8
_Al$ = 40
_Alproxy$ = 68
_Proxy$ = 104
_New_capacity$ = 152
_New_ptr$ = 184
$T7 = 404
$T8 = 436
__$ArrayPad$ = 456
this$ = 496
_Arg$ = 504
_Count$ = 512
?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z
_TEXT	SEGMENT
_It$ = 224
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z PROC	; std::_Get_unwrapped<char * &>, COMDAT

; 1445 :     noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1446 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1447 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1448 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rbp]
	mov	rax, QWORD PTR [rax]

; 1449 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1450 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1451 :     } else {
; 1452 :         return static_cast<_Iter&&>(_It);
; 1453 :     }
; 1454 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ENDP	; std::_Get_unwrapped<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
_TEXT	SEGMENT
_My_data$ = 8
_Al$ = 40
_Alproxy$ = 68
_Proxy$ = 104
_New_capacity$ = 152
_New_ptr$ = 184
$T7 = 404
$T8 = 436
__$ArrayPad$ = 456
this$ = 496
_Arg$ = 504
_Count$ = 512
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>, COMDAT

; 921  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 504				; 000001f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+536]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 922  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 923  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 924  : 
; 925  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 926  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 927  :         } else {
; 928  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cvptr<_Char_or_ptr>::value);
; 929  :         }
; 930  : 
; 931  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rbp], rax
	jbe	SHORT $LN2@Construct

; 932  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 933  :         }
; 934  : 
; 935  :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rbp], rax

; 936  :         auto _Alproxy = _STD _Get_proxy_allocator(_Al);

	mov	rdx, QWORD PTR _Al$[rbp]
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
	npad	1

; 937  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rbp]
	lea	rdx, QWORD PTR _Alproxy$[rbp]
	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1

; 938  : 
; 939  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rbp], 15
	ja	SHORT $LN3@Construct

; 940  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 941  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	QWORD PTR [rax+32], 15

; 942  : 
; 943  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 944  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	movzx	r8d, BYTE PTR _Arg$[rbp]
	mov	rdx, QWORD PTR _Count$[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 945  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T7[rbp], 0
	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	lea	rax, QWORD PTR [rax+rcx+8]
	lea	rdx, QWORD PTR $T7[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 946  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 947  :                 _STD _Traits_copy_batch<_Traits>(_My_data._Bx._Buf, _Arg, _Count);
; 948  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 949  :             } else { // _Strat == _Construct_strategy::_From_string
; 950  : #ifdef _INSERT_STRING_ANNOTATION
; 951  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 952  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 953  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 954  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 955  :             }
; 956  : 
; 957  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 958  :             return;

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
	jmp	$LN4@Construct
$LN3@Construct:

; 959  :         }
; 960  : 
; 961  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rbp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rbp], rax

; 962  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rbp], rax

; 963  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	lea	rdx, QWORD PTR _New_ptr$[rbp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1

; 964  : 
; 965  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 966  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_capacity$[rbp]
	mov	QWORD PTR [rax+32], rcx

; 967  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 968  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);

	mov	rcx, QWORD PTR _New_ptr$[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	movzx	r8d, BYTE PTR _Arg$[rbp]
	mov	rdx, QWORD PTR _Count$[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 969  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T8[rbp], 0
	mov	rcx, QWORD PTR _New_ptr$[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rbp]
	lea	rdx, QWORD PTR $T8[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 970  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 971  :             _STD _Traits_copy_batch<_Traits>(_Unfancy(_New_ptr), _Arg, _Count);
; 972  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 973  :         } else { // _Strat == _Construct_strategy::_From_string
; 974  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 975  :         }
; 976  : 
; 977  :         _ASAN_STRING_CREATE(*this);
; 978  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 979  :     }

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN4@Construct:
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+472]
	pop	rdi
	pop	rbp
	ret	0
$LN6@Construct:
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 8
_Al$ = 40
_Alproxy$ = 68
_Proxy$ = 104
_New_capacity$ = 152
_New_ptr$ = 184
$T7 = 404
$T8 = 436
__$ArrayPad$ = 456
this$ = 496
_Arg$ = 504
_Count$ = 512
?dtor$0@?0???$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
_Val1$ = 240
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@QEBD_K@Z
_TEXT	SEGMENT
_Old_size$ = 8
_Old_ptr$1 = 40
$T2 = 260
$T3 = 292
this$ = 352
_Ptr$ = 360
_Count$ = 368
??$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>, COMDAT

; 2989 :         _In_reads_(_Count) const _UElem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2990 :         // append [_Ptr, _Ptr + _Count), handling volatile-qualified _Elem
; 2991 :         _STL_INTERNAL_STATIC_ASSERT(_Is_any_of_v<_UElem, _Elem, volatile _Elem>);
; 2992 : 
; 2993 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_size$[rbp], rax

; 2994 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Old_size$[rbp]
	mov	rax, QWORD PTR [rax+32]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rbp], rax
	ja	$LN2@Append

; 2995 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 2996 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR _Old_size$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx+24], rax

; 2997 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$1[rbp], rax

; 2998 :             _STD _Traits_move_batch<_Traits>(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rbp]
	mov	rcx, QWORD PTR _Old_ptr$1[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, rax
	call	??$_Traits_move_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ; std::_Traits_move_batch<std::char_traits<char>,char>
	npad	1

; 2999 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T2[rbp], 0
	mov	rax, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR _Old_size$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_ptr$1[rbp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T2[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3000 :             return *this;

	mov	rax, QWORD PTR this$[rbp]
	jmp	SHORT $LN1@Append
$LN2@Append:

; 3001 :         }
; 3002 : 
; 3003 :         return _Reallocate_grow_by(

	mov	rax, QWORD PTR _Count$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rbp]
	movzx	r8d, BYTE PTR $T3[rbp]
	mov	rdx, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1???$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV23@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1???$_Append@D@01@AEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN1@Append:

; 3004 :             _Count,
; 3005 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _UElem* const _Ptr,
; 3006 :                 const size_type _Count) _STATIC_LAMBDA {
; 3007 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3008 :                 _STD _Traits_copy_batch<_Traits>(_New_ptr + _Old_size, _Ptr, _Count);
; 3009 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3010 :             },
; 3011 :             _Ptr, _Count);
; 3012 :     }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
??$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
_New_proxy$ = 8
$T1 = 232
this$ = 288
_Al$ = 296
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT

; 1231 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1232 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	rcx, rax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	mov	QWORD PTR _New_proxy$[rbp], rax

; 1233 :         _Construct_in_place(*_New_proxy, this);

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR $T1[rbp], rax
	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR _New_proxy$[rbp]
	call	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	npad	1

; 1234 :         _Myproxy            = _New_proxy;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _New_proxy$[rbp]
	mov	QWORD PTR [rax], rcx

; 1235 :         _New_proxy->_Mycont = this;

	mov	rax, QWORD PTR _New_proxy$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax], rcx

; 1236 :     }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 224
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 229  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 230  :     // allocate _Bytes
; 231  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rbp], 0
	jne	SHORT $LN2@Allocate

; 232  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 233  :     }
; 234  : 
; 235  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 236  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Allocate

; 237  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rbp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 238  :     }
; 239  : #endif // _HAS_CXX20
; 240  : 
; 241  : #ifdef __cpp_aligned_new
; 242  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 243  :         size_t _Passed_align = _Align;
; 244  : #if defined(_M_IX86) || defined(_M_X64)
; 245  :         if (_Bytes >= _Big_allocation_threshold) {
; 246  :             // boost the alignment of big allocations to help autovectorization
; 247  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 248  :         }
; 249  : #endif // defined(_M_IX86) || defined(_M_X64)
; 250  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 251  :     } else
; 252  : #endif // defined(__cpp_aligned_new)
; 253  :     {
; 254  : #if defined(_M_IX86) || defined(_M_X64)
; 255  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rbp], 4096		; 00001000H
	jb	SHORT $LN4@Allocate

; 256  :             // boost the alignment of big allocations to help autovectorization
; 257  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rbp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN4@Allocate:

; 258  :         }
; 259  : #endif // defined(_M_IX86) || defined(_M_X64)
; 260  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rbp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 261  :     }
; 262  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 4
_Max_possible$1 = 40
_Count$ = 288
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 116  : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 117  :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rbp], 1

; 118  : 
; 119  :     if constexpr (_Overflow_is_possible) {
; 120  :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rbp], rax

; 121  :         if (_Count > _Max_possible) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	QWORD PTR _Count$[rbp], rax
	jbe	SHORT $LN2@Get_size_o

; 122  :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 123  :         }
; 124  :     }
; 125  : 
; 126  :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rbp], 16
$LN3@Get_size_o:

; 127  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0VValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@VValue@Json@@@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0VValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@VValue@Json@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value>, COMDAT

; 982  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0VValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@VValue@Json@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_proxy_allocator@V?$allocator@VValue@Json@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@VValue@Json@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 224
_Al$ = 232
??$_Get_proxy_allocator@V?$allocator@VValue@Json@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@VValue@Json@@@0@@Z PROC ; std::_Get_proxy_allocator<std::allocator<Json::Value> >, COMDAT

; 1525 :     noexcept(noexcept(static_cast<_Rebind_alloc_t<_Alloc, _Container_proxy>>(_Al))) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1526 :     return static_cast<_Rebind_alloc_t<_Alloc, _Container_proxy>>(_Al);

	mov	rdx, QWORD PTR _Al$[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?0VValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@VValue@Json@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 1527 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_proxy_allocator@V?$allocator@VValue@Json@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@VValue@Json@@@0@@Z ENDP ; std::_Get_proxy_allocator<std::allocator<Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >, COMDAT

; 982  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_proxy_allocator@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 224
_Al$ = 232
??$_Get_proxy_allocator@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@0@@Z PROC ; std::_Get_proxy_allocator<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >, COMDAT

; 1525 :     noexcept(noexcept(static_cast<_Rebind_alloc_t<_Alloc, _Container_proxy>>(_Al))) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1526 :     return static_cast<_Rebind_alloc_t<_Alloc, _Container_proxy>>(_Al);

	mov	rdx, QWORD PTR _Al$[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?0U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 1527 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_proxy_allocator@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@0@@Z ENDP ; std::_Get_proxy_allocator<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 8
_Val$ = 256
_New_val$ = 264
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__DE82222C_utility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rbp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR _New_val$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rbp]

; 776  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >, COMDAT

; 982  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_proxy_allocator@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 224
_Al$ = 232
??$_Get_proxy_allocator@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_proxy_allocator<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >, COMDAT

; 1525 :     noexcept(noexcept(static_cast<_Rebind_alloc_t<_Alloc, _Container_proxy>>(_Al))) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1526 :     return static_cast<_Rebind_alloc_t<_Alloc, _Container_proxy>>(_Al);

	mov	rdx, QWORD PTR _Al$[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?0V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 1527 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_proxy_allocator@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_proxy_allocator<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 122  :         explicit __CLR_OR_THIS_CALL operator bool() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1D8A815F___msvc_ostream@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 123  :             return _Ok;

	mov	rax, QWORD PTR this$[rbp]
	movzx	eax, BYTE PTR [rax+8]

; 124  :         }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Zero_uncaught_exceptions$ = 4
tv71 = 212
this$ = 256
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 107  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1D8A815F___msvc_ostream@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 108  : #if !_HAS_EXCEPTIONS
; 109  :             const bool _Zero_uncaught_exceptions = true;
; 110  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 111  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 112  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 113  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

	call	?uncaught_exceptions@std@@YAHXZ		; std::uncaught_exceptions
	test	eax, eax
	jne	SHORT $LN4@sentry
	mov	BYTE PTR tv71[rbp], 1
	jmp	SHORT $LN5@sentry
$LN4@sentry:
	mov	BYTE PTR tv71[rbp], 0
$LN5@sentry:
	movzx	eax, BYTE PTR tv71[rbp]
	mov	BYTE PTR _Zero_uncaught_exceptions$[rbp], al

; 114  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 115  : 
; 116  :             if (_Zero_uncaught_exceptions) {

	movzx	eax, BYTE PTR _Zero_uncaught_exceptions$[rbp]
	test	eax, eax
	je	SHORT $LN2@sentry

; 117  :                 this->_Myostr._Osfx();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN2@sentry:

; 118  :             }
; 119  :         }

	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	npad	1
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Tied$ = 8
this$ = 256
_Ostr$ = 264
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1D8A815F___msvc_ostream@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	npad	1

; 91   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 92   :                 _Ok = false;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+8], 0

; 93   :                 return;

	jmp	$LN1@sentry
$LN2@sentry:

; 94   :             }
; 95   : 
; 96   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	mov	QWORD PTR _Tied$[rbp], rax

; 97   :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

	cmp	QWORD PTR _Tied$[rbp], 0
	je	SHORT $LN4@sentry
	mov	rcx, QWORD PTR _Ostr$[rbp]
	call	??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
	cmp	QWORD PTR _Tied$[rbp], rax
	jne	SHORT $LN3@sentry
$LN4@sentry:

; 98   :                 _Ok = true;

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+8], 1

; 99   :                 return;

	jmp	SHORT $LN1@sentry
$LN3@sentry:

; 100  :             }
; 101  : 
; 102  :             _Tied->flush();

	mov	rcx, QWORD PTR _Tied$[rbp]
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
	npad	1

; 103  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	mov	rcx, QWORD PTR this$[rbp]
	mov	BYTE PTR [rcx+8], al
$LN1@sentry:

; 104  :         }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_Tied$ = 8
this$ = 256
_Ostr$ = 264
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 8
tv72 = 216
this$ = 256
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1D8A815F___msvc_ostream@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rbp], rax
	mov	rax, QWORD PTR tv72[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv72[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	QWORD PTR _Rdbuf$[rbp], rax

; 78   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rbp], 0
	je	SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR _Rdbuf$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rbp]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 8
tv73 = 216
this$ = 256
_Ostr$ = 264
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1D8A815F___msvc_ostream@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	mov	QWORD PTR [rax], rcx

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rbp], rax
	mov	rax, QWORD PTR tv73[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv73[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	QWORD PTR _Rdbuf$[rbp], rax

; 71   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rbp], 0
	je	SHORT $LN2@Sentry_bas

; 72   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR _Rdbuf$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rbp]
	call	QWORD PTR [rax+8]
	npad	1
$LN2@Sentry_bas:

; 73   :             }
; 74   :         }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
_TEXT	SEGMENT
_State$ = 4
_Pad$ = 40
_Ok$ = 72
$T4 = 312
tv191 = 328
tv220 = 328
tv256 = 328
tv281 = 328
tv295 = 328
tv310 = 328
tv189 = 336
tv254 = 336
tv315 = 336
tv136 = 340
tv316 = 340
tv198 = 344
tv263 = 344
tv196 = 348
tv261 = 348
__$ArrayPad$ = 352
_Ostr$ = 400
_Data$ = 408
_Size$ = 416
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>, COMDAT

; 616  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 408				; 00000198H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 46					; 0000002eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+440]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__FEA281E8___msvc_string_view@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 617  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 618  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 619  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

	mov	DWORD PTR _State$[rbp], 0

; 620  : 
; 621  :     _SizeT _Pad;
; 622  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
	test	rax, rax
	jle	SHORT $LN10@Insert_str
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
	cmp	rax, QWORD PTR _Size$[rbp]
	ja	SHORT $LN8@Insert_str
$LN10@Insert_str:

; 623  :         _Pad = 0;

	mov	QWORD PTR _Pad$[rbp], 0

; 624  :     } else {

	jmp	SHORT $LN9@Insert_str
$LN8@Insert_str:

; 625  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
	sub	rax, QWORD PTR _Size$[rbp]
	mov	QWORD PTR _Pad$[rbp], rax
$LN9@Insert_str:

; 626  :     }
; 627  : 
; 628  :     const typename _Ostr_t::sentry _Ok(_Ostr);

	mov	rdx, QWORD PTR _Ostr$[rbp]
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 629  : 
; 630  :     if (!_Ok) {

	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@Insert_str

; 631  :         _State |= _Ostr_t::badbit;

	mov	eax, DWORD PTR _State$[rbp]
	or	eax, 4
	mov	DWORD PTR _State$[rbp], eax

; 632  :     } else { // state okay, insert characters

	jmp	$LN12@Insert_str
$LN11@Insert_str:

; 633  :         _TRY_IO_BEGIN
; 634  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?flags@ios_base@std@@QEBAHXZ
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN14@Insert_str

; 635  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@Insert_str
$LN2@Insert_str:
	mov	rax, QWORD PTR _Pad$[rbp]
	dec	rax
	mov	QWORD PTR _Pad$[rbp], rax
$LN4@Insert_str:
	cmp	QWORD PTR _Pad$[rbp], 0
	jbe	$LN14@Insert_str

; 636  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	QWORD PTR tv191[rbp], rax
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
	mov	BYTE PTR tv189[rbp], al
	movzx	edx, BYTE PTR tv189[rbp]
	mov	rcx, QWORD PTR tv191[rbp]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	mov	DWORD PTR tv136[rbp], eax
	mov	eax, DWORD PTR tv136[rbp]
	mov	DWORD PTR tv198[rbp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv196[rbp], eax
	mov	edx, DWORD PTR tv198[rbp]
	mov	ecx, DWORD PTR tv196[rbp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@Insert_str

; 637  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rbp]
	or	eax, 4
	mov	DWORD PTR _State$[rbp], eax

; 638  :                     break;

	jmp	SHORT $LN14@Insert_str
$LN15@Insert_str:

; 639  :                 }
; 640  :             }

	jmp	$LN2@Insert_str
$LN14@Insert_str:

; 641  :         }
; 642  : 
; 643  :         if (_State == _Ostr_t::goodbit
; 644  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	cmp	DWORD PTR _State$[rbp], 0
	jne	SHORT $LN16@Insert_str
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	QWORD PTR tv220[rbp], rax
	mov	r8, QWORD PTR _Size$[rbp]
	mov	rdx, QWORD PTR _Data$[rbp]
	mov	rcx, QWORD PTR tv220[rbp]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	mov	QWORD PTR tv315[rbp], rax
	mov	rax, QWORD PTR _Size$[rbp]
	cmp	QWORD PTR tv315[rbp], rax
	je	SHORT $LN16@Insert_str

; 645  :             _State |= _Ostr_t::badbit;

	mov	eax, DWORD PTR _State$[rbp]
	or	eax, 4
	mov	DWORD PTR _State$[rbp], eax

; 646  :         } else {

	jmp	$LN17@Insert_str
$LN16@Insert_str:

; 647  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@Insert_str
$LN5@Insert_str:
	mov	rax, QWORD PTR _Pad$[rbp]
	dec	rax
	mov	QWORD PTR _Pad$[rbp], rax
$LN7@Insert_str:
	cmp	QWORD PTR _Pad$[rbp], 0
	jbe	$LN17@Insert_str

; 648  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	QWORD PTR tv256[rbp], rax
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
	mov	BYTE PTR tv254[rbp], al
	movzx	edx, BYTE PTR tv254[rbp]
	mov	rcx, QWORD PTR tv256[rbp]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	mov	DWORD PTR tv316[rbp], eax
	mov	eax, DWORD PTR tv316[rbp]
	mov	DWORD PTR tv263[rbp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv261[rbp], eax
	mov	edx, DWORD PTR tv263[rbp]
	mov	ecx, DWORD PTR tv261[rbp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@Insert_str

; 649  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rbp]
	or	eax, 4
	mov	DWORD PTR _State$[rbp], eax

; 650  :                     break;

	jmp	SHORT $LN17@Insert_str
$LN18@Insert_str:

; 651  :                 }
; 652  :             }

	jmp	$LN5@Insert_str
$LN17@Insert_str:

; 653  :         }
; 654  : 
; 655  :         _Ostr.width(0);

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv281[rbp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv281[rbp]
	call	QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
	npad	1
	jmp	SHORT $LN12@Insert_str
$LN24@Insert_str:
$LN12@Insert_str:

; 656  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 657  :     }
; 658  : 
; 659  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv310[rbp], rax
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rbp]
	mov	rcx, QWORD PTR tv310[rbp]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1

; 660  :     return _Ostr;

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	QWORD PTR $T4[rbp], rax
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	rax, QWORD PTR $T4[rbp]

; 661  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+376]
	pop	rdi
	pop	rbp
	ret	0
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 4
_Pad$ = 40
_Ok$ = 72
$T4 = 312
tv191 = 328
tv220 = 328
tv256 = 328
tv281 = 328
tv295 = 328
tv310 = 328
tv189 = 336
tv254 = 336
tv315 = 336
tv136 = 340
tv316 = 340
tv198 = 344
tv263 = 344
tv196 = 348
tv261 = 348
__$ArrayPad$ = 352
_Ostr$ = 400
_Data$ = 408
_Size$ = 416
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 4
_Pad$ = 40
_Ok$ = 72
$T4 = 312
tv191 = 328
tv220 = 328
tv256 = 328
tv281 = 328
tv295 = 328
tv310 = 328
tv189 = 336
tv254 = 336
tv315 = 336
tv136 = 340
tv316 = 340
tv198 = 344
tv263 = 344
tv196 = 348
tv261 = 348
__$ArrayPad$ = 352
_Ostr$ = 400
_Data$ = 408
_Size$ = 416
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1

; 656  :         _CATCH_IO_(_Ostr_t, _Ostr)

	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv295[rbp], rax
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, QWORD PTR tv295[rbp]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	lea	rax, $LN24@catch$1
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
	int	3
?catch$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1532 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__680F61A7_type_traits
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1534 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
_Val1$ = 240
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT

; 1556 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$?0$0A@$$V$0A@@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$0A@@1@@Z
_TEXT	SEGMENT
$T1 = 196
this$ = 256
__formal$ = 264
??$?0$0A@$$V$0A@@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$0A@@1@@Z PROC ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><0,0>, COMDAT

; 755  :         : _Storage_t(integral_constant<size_t, _Idx>{}, static_cast<_UTypes&&>(_Args)...),

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rax, QWORD PTR $T1[rbp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$?0$$V@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$integral_constant@_K$0A@@1@@Z ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><>
	npad	1

; 756  :           _Which{static_cast<_Index_t>(_Idx)} { // initialize alternative _Idx from _Args...

	mov	rax, QWORD PTR this$[rbp]
	mov	BYTE PTR [rax+8], 0

; 757  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$?0$0A@$$V$0A@@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$0A@@1@@Z ENDP ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><0,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1147 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1148 :     // deallocate a plain pointer using an allocator
; 1149 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1150 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1151 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	npad	1

; 1152 :     } else {
; 1153 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1154 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1155 :     }
; 1156 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 200
_Location$ = 256
<_Args_0>$ = 264
??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &>, COMDAT

; 508  :     noexcept(noexcept(::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 509  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rbp]
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR $T1[rbp]

; 510  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1532 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__680F61A7_type_traits
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1534 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
_UFirst$ = 8
_ULast$ = 40
$T1 = 260
tv70 = 280
this$ = 320
_First$ = 328
_Last$ = 336
_Al$ = 344
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>, COMDAT

; 849  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv70[rbp], rax
	mov	r8, QWORD PTR _Al$[rbp]
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR tv70[rbp]
	call	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
	npad	1

; 850  :         _STD _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rbp]
	lea	rcx, QWORD PTR _First$[rbp]
	call	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
	npad	1

; 851  :         auto _UFirst = _STD _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rbp]
	call	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ; std::_Get_unwrapped<char * &>
	mov	QWORD PTR _UFirst$[rbp], rax

; 852  :         auto _ULast  = _STD _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rbp]
	call	??$_Get_unwrapped@AEAPEAD@std@@YA?A_TAEAPEAD@Z ; std::_Get_unwrapped<char * &>
	mov	QWORD PTR _ULast$[rbp], rax

; 853  :         if (_UFirst == _ULast) {

	mov	rax, QWORD PTR _ULast$[rbp]
	cmp	QWORD PTR _UFirst$[rbp], rax
	jne	SHORT $LN2@allocator

; 854  :             _Construct_empty();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
	npad	1

; 855  :         } else {

	jmp	SHORT $LN3@allocator
$LN2@allocator:

; 856  :             if constexpr (_Is_elem_cvptr<decltype(_UFirst)>::value) {
; 857  :                 _Construct<_Construct_strategy::_From_ptr>(

	mov	rax, QWORD PTR _UFirst$[rbp]
	mov	rcx, QWORD PTR _ULast$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _UFirst$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Construct@$00PEAD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char *>
	npad	1
$LN3@allocator:

; 858  :                     _UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 859  :             } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
; 860  :                 const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 861  :                 const auto _Count  = _STD _Convert_size<size_type>(_Length);
; 862  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);
; 863  :             } else {
; 864  :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
; 865  :             }
; 866  :         }
; 867  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 8
_ULast$ = 40
$T1 = 260
tv70 = 280
this$ = 320
_First$ = 328
_Last$ = 336
_Al$ = 344
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
_TEXT	SEGMENT
_UVal_trunc$ = 4
_RNext$ = 256
_UVal$ = 264
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z PROC	; std::_UIntegral_to_buff<char,unsigned int>, COMDAT

; 2765 : _NODISCARD _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { // used by both to_string and thread::id output

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2766 :     // format _UVal into buffer *ending at* _RNext
; 2767 :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 2768 : 
; 2769 : #ifdef _WIN64
; 2770 :     auto _UVal_trunc = _UVal;

	mov	eax, DWORD PTR _UVal$[rbp]
	mov	DWORD PTR _UVal_trunc$[rbp], eax
$LN4@UIntegral_:

; 2771 : #else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv
; 2772 : 
; 2773 :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 2774 :     if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 2775 :         while (_UVal > 0xFFFFFFFFU) {
; 2776 :             auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 2777 :             _UVal /= 1000000000;
; 2778 : 
; 2779 :             for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 2780 :                 *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 2781 :                 _UVal_chunk /= 10;
; 2782 :             }
; 2783 :         }
; 2784 :     }
; 2785 : 
; 2786 :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 2787 : #endif // ^^^ !defined(_WIN64) ^^^
; 2788 : 
; 2789 :     do {
; 2790 :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	mov	rax, QWORD PTR _RNext$[rbp]
	dec	rax
	mov	QWORD PTR _RNext$[rbp], rax
	xor	edx, edx
	mov	eax, DWORD PTR _UVal_trunc$[rbp]
	mov	ecx, 10
	div	ecx
	mov	eax, edx
	add	eax, 48					; 00000030H
	mov	rcx, QWORD PTR _RNext$[rbp]
	mov	BYTE PTR [rcx], al

; 2791 :         _UVal_trunc /= 10;

	xor	edx, edx
	mov	eax, DWORD PTR _UVal_trunc$[rbp]
	mov	ecx, 10
	div	ecx
	mov	DWORD PTR _UVal_trunc$[rbp], eax

; 2792 :     } while (_UVal_trunc != 0);

	cmp	DWORD PTR _UVal_trunc$[rbp], 0
	jne	SHORT $LN4@UIntegral_

; 2793 :     return _RNext;

	mov	rax, QWORD PTR _RNext$[rbp]

; 2794 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ENDP	; std::_UIntegral_to_buff<char,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z
_TEXT	SEGMENT
_Array$ = 224
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z PROC		; std::end<char,21>, COMDAT

; 2097 : _NODISCARD constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2098 :     return _Array + _Size;

	mov	rax, QWORD PTR _Array$[rbp]
	add	rax, 21

; 2099 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ENDP		; std::end<char,21>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_State$ = 4
_Count$ = 40
_Pad$ = 72
_Ok$ = 104
$T4 = 344
tv137 = 360
tv194 = 360
tv223 = 360
tv260 = 360
tv285 = 360
tv299 = 360
tv314 = 360
tv192 = 368
tv258 = 368
tv319 = 368
tv139 = 372
tv320 = 372
tv201 = 376
tv267 = 376
tv199 = 380
tv265 = 380
__$ArrayPad$ = 384
_Ostr$ = 432
_Val$ = 440
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 768  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

$LN25:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 440				; 000001b8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+472]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__1D8A815F___msvc_ostream@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 769  :     // insert NTBS into char stream
; 770  :     using _Elem = char;
; 771  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 772  : 
; 773  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$[rbp], 0

; 774  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

	mov	rcx, QWORD PTR _Val$[rbp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	QWORD PTR _Count$[rbp], rax

; 775  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
	test	rax, rax
	jle	SHORT $LN17@operator
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
	cmp	rax, QWORD PTR _Count$[rbp]
	jle	SHORT $LN17@operator
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?width@ios_base@std@@QEBA_JXZ
	sub	rax, QWORD PTR _Count$[rbp]
	mov	QWORD PTR tv137[rbp], rax
	jmp	SHORT $LN18@operator
$LN17@operator:
	mov	QWORD PTR tv137[rbp], 0
$LN18@operator:
	mov	rax, QWORD PTR tv137[rbp]
	mov	QWORD PTR _Pad$[rbp], rax

; 776  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	rdx, QWORD PTR _Ostr$[rbp]
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 777  : 
; 778  :     if (!_Ok) {

	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@operator

; 779  :         _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rbp]
	or	eax, 4
	mov	DWORD PTR _State$[rbp], eax

; 780  :     } else { // state okay, insert

	jmp	$LN9@operator
$LN8@operator:

; 781  :         _TRY_IO_BEGIN
; 782  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?flags@ios_base@std@@QEBAHXZ
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator

; 783  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	rax, QWORD PTR _Pad$[rbp]
	dec	rax
	mov	QWORD PTR _Pad$[rbp], rax
$LN4@operator:
	cmp	QWORD PTR _Pad$[rbp], 0
	jle	$LN11@operator

; 784  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	QWORD PTR tv194[rbp], rax
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
	mov	BYTE PTR tv192[rbp], al
	movzx	edx, BYTE PTR tv192[rbp]
	mov	rcx, QWORD PTR tv194[rbp]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	mov	DWORD PTR tv139[rbp], eax
	mov	eax, DWORD PTR tv139[rbp]
	mov	DWORD PTR tv201[rbp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv199[rbp], eax
	mov	edx, DWORD PTR tv201[rbp]
	mov	ecx, DWORD PTR tv199[rbp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@operator

; 785  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rbp]
	or	eax, 4
	mov	DWORD PTR _State$[rbp], eax

; 786  :                     break;

	jmp	SHORT $LN11@operator
$LN12@operator:

; 787  :                 }
; 788  :             }

	jmp	$LN2@operator
$LN11@operator:

; 789  :         }
; 790  : 
; 791  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	cmp	DWORD PTR _State$[rbp], 0
	jne	SHORT $LN13@operator
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	QWORD PTR tv223[rbp], rax
	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR tv223[rbp]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	mov	QWORD PTR tv319[rbp], rax
	mov	rax, QWORD PTR _Count$[rbp]
	cmp	QWORD PTR tv319[rbp], rax
	je	SHORT $LN13@operator

; 792  :             _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rbp]
	or	eax, 4
	mov	DWORD PTR _State$[rbp], eax
$LN13@operator:

; 793  :         }
; 794  : 
; 795  :         if (_State == ios_base::goodbit) {

	cmp	DWORD PTR _State$[rbp], 0
	jne	$LN14@operator

; 796  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	rax, QWORD PTR _Pad$[rbp]
	dec	rax
	mov	QWORD PTR _Pad$[rbp], rax
$LN7@operator:
	cmp	QWORD PTR _Pad$[rbp], 0
	jle	$LN14@operator

; 797  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	QWORD PTR tv260[rbp], rax
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
	mov	BYTE PTR tv258[rbp], al
	movzx	edx, BYTE PTR tv258[rbp]
	mov	rcx, QWORD PTR tv260[rbp]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	mov	DWORD PTR tv320[rbp], eax
	mov	eax, DWORD PTR tv320[rbp]
	mov	DWORD PTR tv267[rbp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR tv265[rbp], eax
	mov	edx, DWORD PTR tv267[rbp]
	mov	ecx, DWORD PTR tv265[rbp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@operator

; 798  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rbp]
	or	eax, 4
	mov	DWORD PTR _State$[rbp], eax

; 799  :                     break;

	jmp	SHORT $LN14@operator
$LN15@operator:

; 800  :                 }
; 801  :             }

	jmp	$LN5@operator
$LN14@operator:

; 802  :         }
; 803  : 
; 804  :         _Ostr.width(0);

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv285[rbp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv285[rbp]
	call	QWORD PTR __imp_?width@ios_base@std@@QEAA_J_J@Z
	npad	1
	jmp	SHORT $LN9@operator
$LN23@operator:
$LN9@operator:

; 805  :         _CATCH_IO_(ios_base, _Ostr)
; 806  :     }
; 807  : 
; 808  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv314[rbp], rax
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rbp]
	mov	rcx, QWORD PTR tv314[rbp]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1

; 809  :     return _Ostr;

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	QWORD PTR $T4[rbp], rax
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	rax, QWORD PTR $T4[rbp]

; 810  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+408]
	pop	rdi
	pop	rbp
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 4
_Count$ = 40
_Pad$ = 72
_Ok$ = 104
$T4 = 344
tv137 = 360
tv194 = 360
tv223 = 360
tv260 = 360
tv285 = 360
tv299 = 360
tv314 = 360
tv192 = 368
tv258 = 368
tv319 = 368
tv139 = 372
tv320 = 372
tv201 = 376
tv267 = 376
tv199 = 380
tv265 = 380
__$ArrayPad$ = 384
_Ostr$ = 432
_Val$ = 440
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_State$ = 4
_Count$ = 40
_Pad$ = 72
_Ok$ = 104
$T4 = 344
tv137 = 360
tv194 = 360
tv223 = 360
tv260 = 360
tv285 = 360
tv299 = 360
tv314 = 360
tv192 = 368
tv258 = 368
tv319 = 368
tv139 = 372
tv320 = 372
tv201 = 376
tv267 = 376
tv199 = 380
tv265 = 380
__$ArrayPad$ = 384
_Ostr$ = 432
_Val$ = 440
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1

; 805  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv299[rbp], rax
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, QWORD PTR tv299[rbp]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	lea	rax, $LN23@catch$1
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
	int	3
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_ostream.hpp
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
tv80 = 192
_Ostr$ = 240
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1012 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1D8A815F___msvc_ostream@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1013 :     _Ostr.put(_Ostr.widen('\n'));

	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv80[rbp], rax
	mov	dl, 10
	mov	rcx, QWORD PTR tv80[rbp]
	call	QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
	movzx	edx, al
	mov	rcx, QWORD PTR _Ostr$[rbp]
	call	QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
	npad	1

; 1014 :     _Ostr.flush();

	mov	rcx, QWORD PTR _Ostr$[rbp]
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
	npad	1

; 1015 :     return _Ostr;

	mov	rax, QWORD PTR _Ostr$[rbp]

; 1016 : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv75 = 192
tv73 = 200
_Ostr$ = 240
_Str$ = 248
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3533 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 3534 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	rcx, QWORD PTR _Str$[rbp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR tv75[rbp], rax
	mov	rcx, QWORD PTR _Str$[rbp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	mov	QWORD PTR tv73[rbp], rax
	mov	r8, QWORD PTR tv75[rbp]
	mov	rdx, QWORD PTR tv73[rbp]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	call	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>

; 3535 : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp
;	COMDAT main
_TEXT	SEGMENT
doc$ = 8
e$5 = 56
$T6 = 280
$T7 = 344
$T8 = 392
$T9 = 452
tv67 = 472
tv90 = 472
tv137 = 472
tv139 = 480
tv148 = 480
tv153 = 480
tv144 = 488
tv150 = 488
tv92 = 496
tv154 = 504
tv129 = 512
__$ArrayPad$ = 520
main	PROC						; COMDAT

; 9    : int main() {

$LN13:
	push	rbp
	push	rdi
	sub	rsp, 568				; 00000238H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 86					; 00000056H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3FD16450_Main@cpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 10   : 
; 11   : 	//{
; 12   : 	//	Json::Value val = {
; 13   : 	//			  {"pi", 3.141},
; 14   : 	//			  {"happy", true},
; 15   : 	//			  {"name", "Niels"},
; 16   : 	//			  {"nothing", nullptr},
; 17   : 	//			  {"answer", {
; 18   : 	//				{"everything", 42}
; 19   : 	//			  }},
; 20   : 	//			  {"list", {1, 0, 2}},
; 21   : 	//			  {"object", {
; 22   : 	//				{"currency", "USD"},
; 23   : 	//				{"value", 42.99}
; 24   : 	//				}
; 25   : 	//			  },
; 26   : 	//			  {"different", Json::Value::array({"abc", 1, true})},
; 27   : 	//	};
; 28   : 	//	std::cout << val.stringify();
; 29   : 	//}
; 30   : 
; 31   : 
; 32   : 
; 33   : 
; 34   : 	//func({ { "a", false },  { "b", 1 } });
; 35   : 
; 36   : 	Json::Value doc;

	mov	edx, 24
	lea	rcx, QWORD PTR doc$[rbp]
	call	?__autoclassinit2@Value@Json@@QEAAX_K@Z
	lea	rcx, QWORD PTR doc$[rbp]
	call	??0Value@Json@@QEAA@XZ			; Json::Value::Value
	npad	1

; 37   : 	try
; 38   : 	{
; 39   : 		doc = Json::Value::fromFile("tests/test.json");

	lea	rdx, OFFSET FLAT:??_C@_0BA@DPKMFFGL@tests?1test?4json@
	lea	rcx, QWORD PTR $T6[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv67[rbp], rax
	lea	rdx, QWORD PTR $T6[rbp]
	lea	rcx, QWORD PTR $T7[rbp]
	call	?fromFile@Value@Json@@SA?AV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::fromFile
	mov	QWORD PTR tv148[rbp], rax
	mov	rdx, QWORD PTR tv148[rbp]
	lea	rcx, QWORD PTR doc$[rbp]
	call	??4Value@Json@@QEAAAEAV01@$$QEAV01@@Z	; Json::Value::operator=
	lea	rcx, QWORD PTR $T7[rbp]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 40   : 		std::cout << doc.stringify() << std::endl;

	mov	rax, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	QWORD PTR tv90[rbp], rax
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T8[rbp]
	lea	rcx, QWORD PTR doc$[rbp]
	call	?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Value::stringify
	mov	QWORD PTR tv153[rbp], rax
	mov	rax, QWORD PTR tv153[rbp]
	mov	QWORD PTR tv150[rbp], rax
	mov	rax, QWORD PTR tv150[rbp]
	mov	QWORD PTR tv92[rbp], rax
	mov	rdx, QWORD PTR tv92[rbp]
	mov	rcx, QWORD PTR tv90[rbp]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv154[rbp], rax
	mov	rax, QWORD PTR tv154[rbp]
	mov	QWORD PTR tv129[rbp], rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, QWORD PTR tv129[rbp]
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	npad	1
	lea	rcx, QWORD PTR $T8[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	SHORT $LN10@main
$LN11@main:
$LN10@main:

; 41   : 	}
; 42   : 	catch (const std::exception& e)
; 43   : 	{
; 44   : 		std::cerr << e.what() << std::endl;
; 45   : 	}
; 46   : 
; 47   : 
; 48   : 	return 0;

	mov	DWORD PTR $T9[rbp], 0
	lea	rcx, QWORD PTR doc$[rbp]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	mov	eax, DWORD PTR $T9[rbp]

; 49   : }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:main$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+536]
	pop	rdi
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
doc$ = 8
e$5 = 56
$T6 = 280
$T7 = 344
$T8 = 392
$T9 = 452
tv67 = 472
tv90 = 472
tv137 = 472
tv139 = 480
tv148 = 480
tv153 = 480
tv144 = 488
tv150 = 488
tv92 = 496
tv154 = 504
tv129 = 512
__$ArrayPad$ = 520
main$dtor$0 PROC
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR doc$[rbp]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
doc$ = 8
e$5 = 56
$T6 = 280
$T7 = 344
$T8 = 392
$T9 = 452
tv67 = 472
tv90 = 472
tv137 = 472
tv139 = 480
tv148 = 480
tv153 = 480
tv144 = 488
tv150 = 488
tv92 = 496
tv154 = 504
tv129 = 512
__$ArrayPad$ = 520
main$dtor$1 PROC
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
doc$ = 8
e$5 = 56
$T6 = 280
$T7 = 344
$T8 = 392
$T9 = 452
tv67 = 472
tv90 = 472
tv137 = 472
tv139 = 480
tv148 = 480
tv153 = 480
tv144 = 488
tv150 = 488
tv92 = 496
tv154 = 504
tv129 = 512
__$ArrayPad$ = 520
main$dtor$3 PROC
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T8[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
main$dtor$3 ENDP
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
doc$ = 8
e$5 = 56
$T6 = 280
$T7 = 344
$T8 = 392
$T9 = 452
tv67 = 472
tv90 = 472
tv137 = 472
tv139 = 480
tv148 = 480
tv153 = 480
tv144 = 488
tv150 = 488
tv92 = 496
tv154 = 504
tv129 = 512
__$ArrayPad$ = 520
main$catch$4 PROC

; 43   : 	{

	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
__catch$main$0:

; 44   : 		std::cerr << e.what() << std::endl;

	mov	rax, QWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	QWORD PTR tv137[rbp], rax
	mov	rax, QWORD PTR e$5[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR e$5[rbp]
	call	QWORD PTR [rax+8]
	mov	QWORD PTR tv139[rbp], rax
	mov	rdx, QWORD PTR tv139[rbp]
	mov	rcx, QWORD PTR tv137[rbp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	QWORD PTR tv144[rbp], rax
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, QWORD PTR tv144[rbp]
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	npad	1

; 45   : 	}

	lea	rax, $LN11@main$catch
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
	int	3
main$catch$4 ENDP
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$_Variant_raw_get@$02AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Variant_raw_get@$02AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::_Variant_raw_get<3,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>, COMDAT

; 480  : _NODISCARD constexpr decltype(auto) _Variant_raw_get(_Storage&& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 481  :     // access the _Idx-th element of a _Variant_storage
; 482  :     if constexpr (_Idx == 0) {
; 483  :         return static_cast<_Storage&&>(_Obj)._Get();
; 484  :     } else if constexpr (_Idx == 1) {
; 485  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 486  :     } else if constexpr (_Idx == 2) {
; 487  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 488  :     } else if constexpr (_Idx == 3) {
; 489  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();

	mov	rax, QWORD PTR _Obj$[rbp]
	mov	rcx, rax
	call	?_Get@?$_Variant_storage_@$00NPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBNXZ ; std::_Variant_storage_<1,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get

; 490  :     } else if constexpr (_Idx == 4) {
; 491  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 492  :     } else if constexpr (_Idx == 5) {
; 493  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 494  :     } else if constexpr (_Idx == 6) {
; 495  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 496  :     } else if constexpr (_Idx == 7) {
; 497  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 498  :     } else if constexpr (_Idx < 16) {
; 499  :         return _STD _Variant_raw_get<_Idx - 8>(
; 500  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 501  :     } else if constexpr (_Idx < 32) {
; 502  :         return _STD _Variant_raw_get<_Idx - 16>(static_cast<_Storage&&>(_Obj)
; 503  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 504  :     } else if constexpr (_Idx < 64) {
; 505  :         return _STD _Variant_raw_get<_Idx - 32>(static_cast<_Storage&&>(_Obj)
; 506  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 507  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 508  :     } else { // _Idx >= 64
; 509  :         return _STD _Variant_raw_get<_Idx - 64>(static_cast<_Storage&&>(_Obj)
; 510  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 511  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 512  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 513  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 514  :     }
; 515  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Variant_raw_get@$02AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::_Variant_raw_get<3,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@$02PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Var$ = 224
??$get@$02PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<3,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1180 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1181 :     // access the contained value of _Var if its _Idx-th alternative is active
; 1182 :     static_assert(_Idx < sizeof...(_Types), "variant index out of bounds");
; 1183 :     if (_Var.index() == _Idx) {

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
	cmp	rax, 3
	jne	SHORT $LN2@get

; 1184 :         return _STD _Variant_raw_get<_Idx>(_Var._Storage());

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
	mov	rcx, rax
	call	??$_Variant_raw_get@$02AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<3,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
	jmp	SHORT $LN1@get
$LN2@get:

; 1185 :     }
; 1186 : 
; 1187 :     _STD _Throw_bad_variant_access();

	call	?_Throw_bad_variant_access@std@@YAXXZ	; std::_Throw_bad_variant_access
	npad	1
$LN1@get:
$LN3@get:

; 1188 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$02PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<3,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Var$ = 256
??$get@NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<double,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1223 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1224 :     // access the contained value of _Var if its alternative _Ty is active
; 1225 :     constexpr size_t _Idx = _Meta_find_unique_index<variant<_Types...>, _Ty>::value;

	mov	QWORD PTR _Idx$[rbp], 3

; 1226 :     if constexpr (_Idx < sizeof...(_Types)) {
; 1227 :         return _STD get<_Idx>(_Var);

	mov	rcx, QWORD PTR _Var$[rbp]
	call	??$get@$02PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<3,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1228 :     } else {
; 1229 :         static_assert(false, "get<T>(const variant<Types...>&) "
; 1230 :                              "requires T to occur exactly once in Types. (N4971 [variant.get]/8)");
; 1231 :     }
; 1232 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$get@NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<double,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$_Variant_raw_get@$01AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Variant_raw_get@$01AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::_Variant_raw_get<2,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>, COMDAT

; 480  : _NODISCARD constexpr decltype(auto) _Variant_raw_get(_Storage&& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 481  :     // access the _Idx-th element of a _Variant_storage
; 482  :     if constexpr (_Idx == 0) {
; 483  :         return static_cast<_Storage&&>(_Obj)._Get();
; 484  :     } else if constexpr (_Idx == 1) {
; 485  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 486  :     } else if constexpr (_Idx == 2) {
; 487  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();

	mov	rax, QWORD PTR _Obj$[rbp]
	mov	rcx, rax
	call	?_Get@?$_Variant_storage_@$00HNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBHXZ ; std::_Variant_storage_<1,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get

; 488  :     } else if constexpr (_Idx == 3) {
; 489  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 490  :     } else if constexpr (_Idx == 4) {
; 491  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 492  :     } else if constexpr (_Idx == 5) {
; 493  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 494  :     } else if constexpr (_Idx == 6) {
; 495  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 496  :     } else if constexpr (_Idx == 7) {
; 497  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 498  :     } else if constexpr (_Idx < 16) {
; 499  :         return _STD _Variant_raw_get<_Idx - 8>(
; 500  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 501  :     } else if constexpr (_Idx < 32) {
; 502  :         return _STD _Variant_raw_get<_Idx - 16>(static_cast<_Storage&&>(_Obj)
; 503  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 504  :     } else if constexpr (_Idx < 64) {
; 505  :         return _STD _Variant_raw_get<_Idx - 32>(static_cast<_Storage&&>(_Obj)
; 506  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 507  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 508  :     } else { // _Idx >= 64
; 509  :         return _STD _Variant_raw_get<_Idx - 64>(static_cast<_Storage&&>(_Obj)
; 510  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 511  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 512  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 513  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 514  :     }
; 515  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Variant_raw_get@$01AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::_Variant_raw_get<2,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@$01PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Var$ = 224
??$get@$01PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<2,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1180 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1181 :     // access the contained value of _Var if its _Idx-th alternative is active
; 1182 :     static_assert(_Idx < sizeof...(_Types), "variant index out of bounds");
; 1183 :     if (_Var.index() == _Idx) {

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
	cmp	rax, 2
	jne	SHORT $LN2@get

; 1184 :         return _STD _Variant_raw_get<_Idx>(_Var._Storage());

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
	mov	rcx, rax
	call	??$_Variant_raw_get@$01AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<2,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
	jmp	SHORT $LN1@get
$LN2@get:

; 1185 :     }
; 1186 : 
; 1187 :     _STD _Throw_bad_variant_access();

	call	?_Throw_bad_variant_access@std@@YAXXZ	; std::_Throw_bad_variant_access
	npad	1
$LN1@get:
$LN3@get:

; 1188 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$01PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<2,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@HPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Var$ = 256
??$get@HPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<int,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1223 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1224 :     // access the contained value of _Var if its alternative _Ty is active
; 1225 :     constexpr size_t _Idx = _Meta_find_unique_index<variant<_Types...>, _Ty>::value;

	mov	QWORD PTR _Idx$[rbp], 2

; 1226 :     if constexpr (_Idx < sizeof...(_Types)) {
; 1227 :         return _STD get<_Idx>(_Var);

	mov	rcx, QWORD PTR _Var$[rbp]
	call	??$get@$01PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<2,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1228 :     } else {
; 1229 :         static_assert(false, "get<T>(const variant<Types...>&) "
; 1230 :                              "requires T to occur exactly once in Types. (N4971 [variant.get]/8)");
; 1231 :     }
; 1232 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$get@HPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<int,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$_Variant_raw_get@$00AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Variant_raw_get@$00AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::_Variant_raw_get<1,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>, COMDAT

; 480  : _NODISCARD constexpr decltype(auto) _Variant_raw_get(_Storage&& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 481  :     // access the _Idx-th element of a _Variant_storage
; 482  :     if constexpr (_Idx == 0) {
; 483  :         return static_cast<_Storage&&>(_Obj)._Get();
; 484  :     } else if constexpr (_Idx == 1) {
; 485  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();

	mov	rax, QWORD PTR _Obj$[rbp]
	mov	rcx, rax
	call	?_Get@?$_Variant_storage_@$00_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEB_NXZ ; std::_Variant_storage_<1,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get

; 486  :     } else if constexpr (_Idx == 2) {
; 487  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 488  :     } else if constexpr (_Idx == 3) {
; 489  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 490  :     } else if constexpr (_Idx == 4) {
; 491  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 492  :     } else if constexpr (_Idx == 5) {
; 493  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 494  :     } else if constexpr (_Idx == 6) {
; 495  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 496  :     } else if constexpr (_Idx == 7) {
; 497  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 498  :     } else if constexpr (_Idx < 16) {
; 499  :         return _STD _Variant_raw_get<_Idx - 8>(
; 500  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 501  :     } else if constexpr (_Idx < 32) {
; 502  :         return _STD _Variant_raw_get<_Idx - 16>(static_cast<_Storage&&>(_Obj)
; 503  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 504  :     } else if constexpr (_Idx < 64) {
; 505  :         return _STD _Variant_raw_get<_Idx - 32>(static_cast<_Storage&&>(_Obj)
; 506  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 507  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 508  :     } else { // _Idx >= 64
; 509  :         return _STD _Variant_raw_get<_Idx - 64>(static_cast<_Storage&&>(_Obj)
; 510  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 511  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 512  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 513  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 514  :     }
; 515  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Variant_raw_get@$00AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::_Variant_raw_get<1,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Var$ = 224
??$get@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1180 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1181 :     // access the contained value of _Var if its _Idx-th alternative is active
; 1182 :     static_assert(_Idx < sizeof...(_Types), "variant index out of bounds");
; 1183 :     if (_Var.index() == _Idx) {

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
	cmp	rax, 1
	jne	SHORT $LN2@get

; 1184 :         return _STD _Variant_raw_get<_Idx>(_Var._Storage());

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
	mov	rcx, rax
	call	??$_Variant_raw_get@$00AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<1,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
	jmp	SHORT $LN1@get
$LN2@get:

; 1185 :     }
; 1186 : 
; 1187 :     _STD _Throw_bad_variant_access();

	call	?_Throw_bad_variant_access@std@@YAXXZ	; std::_Throw_bad_variant_access
	npad	1
$LN1@get:
$LN3@get:

; 1188 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@_NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Var$ = 256
??$get@_NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<bool,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1223 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1224 :     // access the contained value of _Var if its alternative _Ty is active
; 1225 :     constexpr size_t _Idx = _Meta_find_unique_index<variant<_Types...>, _Ty>::value;

	mov	QWORD PTR _Idx$[rbp], 1

; 1226 :     if constexpr (_Idx < sizeof...(_Types)) {
; 1227 :         return _STD get<_Idx>(_Var);

	mov	rcx, QWORD PTR _Var$[rbp]
	call	??$get@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1228 :     } else {
; 1229 :         static_assert(false, "get<T>(const variant<Types...>&) "
; 1230 :                              "requires T to occur exactly once in Types. (N4971 [variant.get]/8)");
; 1231 :     }
; 1232 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$get@_NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<bool,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
_TEXT	SEGMENT
$T1 = 196
$T2 = 228
tv64 = 248
__$ReturnUdt$ = 288
_Left$ = 296
_Right$ = 304
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3308 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 312				; 00000138H
	lea	rbp, QWORD PTR [rsp+48]
	mov	DWORD PTR $T2[rbp], 0
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 3309 : #if _ITERATOR_DEBUG_LEVEL == 2
; 3310 :     _STL_VERIFY(_STD addressof(_Left) != _STD addressof(_Right),

	mov	rcx, QWORD PTR _Left$[rbp]
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	QWORD PTR tv64[rbp], rax
	mov	rcx, QWORD PTR _Right$[rbp]
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	rcx, QWORD PTR tv64[rbp]
	cmp	rcx, rax
	jne	SHORT $LN2@operator
	lea	rax, OFFSET FLAT:??_C@_0BGJ@OHAFKLGF@You?5cannot?5concatenate?5the?5same@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 3314				; 00000cf2H
	lea	rdx, OFFSET FLAT:??_C@_0GA@IMMHHOBA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN4@operator
	int	3
	xor	eax, eax
$LN4@operator:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@operator:

; 3311 :         "You cannot concatenate the same moved string to itself. See N4950 [res.on.arguments]/1.3: "
; 3312 :         "If a function argument is bound to an rvalue reference parameter, the implementation may assume that "
; 3313 :         "this parameter is a unique reference to this argument, except that the argument passed to "
; 3314 :         "a move-assignment operator may be a reference to *this ([lib.types.movedfrom]).");
; 3315 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 3316 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, QWORD PTR _Right$[rbp]
	mov	r8, QWORD PTR _Left$[rbp]
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T2[rbp]
	or	eax, 1
	mov	DWORD PTR $T2[rbp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 3317 : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z
_TEXT	SEGMENT
$T1 = 196
__$ReturnUdt$ = 256
_Left$ = 264
_Right$ = 272
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3302 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	DWORD PTR $T1[rbp], 0
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 3303 :     return _STD move(_Left.append(_Right));

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR _Left$[rbp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rbp]
	or	eax, 1
	mov	DWORD PTR $T1[rbp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 3304 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$get@$00$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBVValue@Json@@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z
_TEXT	SEGMENT
_Pr$ = 224
??$get@$00$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBVValue@Json@@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z PROC ; std::get<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>, COMDAT

; 704  : _NODISCARD constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__DE82222C_utility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 705  :     // get const reference to element at _Idx in pair _Pr
; 706  :     if constexpr (_Idx == 0) {
; 707  :         return _Pr.first;
; 708  :     } else {
; 709  :         return _Pr.second;

	mov	rax, QWORD PTR _Pr$[rbp]
	add	rax, 40					; 00000028H

; 710  :     }
; 711  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$00$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBVValue@Json@@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z ENDP ; std::get<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$get@$0A@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z
_TEXT	SEGMENT
_Pr$ = 224
??$get@$0A@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z PROC ; std::get<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>, COMDAT

; 704  : _NODISCARD constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__DE82222C_utility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 705  :     // get const reference to element at _Idx in pair _Pr
; 706  :     if constexpr (_Idx == 0) {
; 707  :         return _Pr.first;

	mov	rax, QWORD PTR _Pr$[rbp]

; 708  :     } else {
; 709  :         return _Pr.second;
; 710  :     }
; 711  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$0A@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z ENDP ; std::get<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAAPEAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAA@XZ
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAAPEAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAA@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@QEAA@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 224
classSize$ = 232
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rbp, rsp
	mov	rdi, QWORD PTR this$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR classSize$[rbp]
	rep stosb
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 192
this$ = 240
_Right$ = 248
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator==, COMDAT

; 71   :     _NODISCARD bool operator==(const _List_unchecked_const_iterator& _Right) const noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 72   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[rbp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[rbp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv67[rbp]

; 73   :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 224
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator++, COMDAT

; 49   :     _List_unchecked_const_iterator& operator++() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 50   :         _Ptr = _Ptr->_Next;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 51   :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 52   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@XZ
_TEXT	SEGMENT
this$ = 224
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator*, COMDAT

; 41   :     _NODISCARD reference operator*() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 42   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 16

; 43   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 224
_Pnode$ = 232
_Plist$ = 240
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>, COMDAT

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Pnode$[rbp]
	mov	QWORD PTR [rax], rcx

; 38   :         this->_Adopt(_Plist);

	mov	rdx, QWORD PTR _Plist$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt
	npad	1

; 39   :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$_Variant_raw_get@$04AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Variant_raw_get@$04AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::_Variant_raw_get<5,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>, COMDAT

; 480  : _NODISCARD constexpr decltype(auto) _Variant_raw_get(_Storage&& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 481  :     // access the _Idx-th element of a _Variant_storage
; 482  :     if constexpr (_Idx == 0) {
; 483  :         return static_cast<_Storage&&>(_Obj)._Get();
; 484  :     } else if constexpr (_Idx == 1) {
; 485  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 486  :     } else if constexpr (_Idx == 2) {
; 487  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 488  :     } else if constexpr (_Idx == 3) {
; 489  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 490  :     } else if constexpr (_Idx == 4) {
; 491  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 492  :     } else if constexpr (_Idx == 5) {
; 493  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();

	mov	rax, QWORD PTR _Obj$[rbp]
	mov	rcx, rax
	call	?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGBAAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Variant_storage_<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get

; 494  :     } else if constexpr (_Idx == 6) {
; 495  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 496  :     } else if constexpr (_Idx == 7) {
; 497  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 498  :     } else if constexpr (_Idx < 16) {
; 499  :         return _STD _Variant_raw_get<_Idx - 8>(
; 500  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 501  :     } else if constexpr (_Idx < 32) {
; 502  :         return _STD _Variant_raw_get<_Idx - 16>(static_cast<_Storage&&>(_Obj)
; 503  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 504  :     } else if constexpr (_Idx < 64) {
; 505  :         return _STD _Variant_raw_get<_Idx - 32>(static_cast<_Storage&&>(_Obj)
; 506  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 507  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 508  :     } else { // _Idx >= 64
; 509  :         return _STD _Variant_raw_get<_Idx - 64>(static_cast<_Storage&&>(_Obj)
; 510  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 511  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 512  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 513  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 514  :     }
; 515  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Variant_raw_get@$04AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::_Variant_raw_get<5,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$_Variant_raw_get@$03AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Variant_raw_get@$03AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::_Variant_raw_get<4,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>, COMDAT

; 480  : _NODISCARD constexpr decltype(auto) _Variant_raw_get(_Storage&& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 481  :     // access the _Idx-th element of a _Variant_storage
; 482  :     if constexpr (_Idx == 0) {
; 483  :         return static_cast<_Storage&&>(_Obj)._Get();
; 484  :     } else if constexpr (_Idx == 1) {
; 485  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 486  :     } else if constexpr (_Idx == 2) {
; 487  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 488  :     } else if constexpr (_Idx == 3) {
; 489  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 490  :     } else if constexpr (_Idx == 4) {
; 491  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();

	mov	rax, QWORD PTR _Obj$[rbp]
	mov	rcx, rax
	call	?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ ; std::_Variant_storage_<1,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get

; 492  :     } else if constexpr (_Idx == 5) {
; 493  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 494  :     } else if constexpr (_Idx == 6) {
; 495  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 496  :     } else if constexpr (_Idx == 7) {
; 497  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 498  :     } else if constexpr (_Idx < 16) {
; 499  :         return _STD _Variant_raw_get<_Idx - 8>(
; 500  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 501  :     } else if constexpr (_Idx < 32) {
; 502  :         return _STD _Variant_raw_get<_Idx - 16>(static_cast<_Storage&&>(_Obj)
; 503  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 504  :     } else if constexpr (_Idx < 64) {
; 505  :         return _STD _Variant_raw_get<_Idx - 32>(static_cast<_Storage&&>(_Obj)
; 506  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 507  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 508  :     } else { // _Idx >= 64
; 509  :         return _STD _Variant_raw_get<_Idx - 64>(static_cast<_Storage&&>(_Obj)
; 510  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 511  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 512  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 513  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 514  :     }
; 515  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Variant_raw_get@$03AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::_Variant_raw_get<4,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$_Variant_raw_get@$0A@AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Variant_raw_get@$0A@AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::_Variant_raw_get<0,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>, COMDAT

; 480  : _NODISCARD constexpr decltype(auto) _Variant_raw_get(_Storage&& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 481  :     // access the _Idx-th element of a _Variant_storage
; 482  :     if constexpr (_Idx == 0) {
; 483  :         return static_cast<_Storage&&>(_Obj)._Get();

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get

; 484  :     } else if constexpr (_Idx == 1) {
; 485  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 486  :     } else if constexpr (_Idx == 2) {
; 487  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 488  :     } else if constexpr (_Idx == 3) {
; 489  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 490  :     } else if constexpr (_Idx == 4) {
; 491  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 492  :     } else if constexpr (_Idx == 5) {
; 493  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 494  :     } else if constexpr (_Idx == 6) {
; 495  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 496  :     } else if constexpr (_Idx == 7) {
; 497  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 498  :     } else if constexpr (_Idx < 16) {
; 499  :         return _STD _Variant_raw_get<_Idx - 8>(
; 500  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 501  :     } else if constexpr (_Idx < 32) {
; 502  :         return _STD _Variant_raw_get<_Idx - 16>(static_cast<_Storage&&>(_Obj)
; 503  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 504  :     } else if constexpr (_Idx < 64) {
; 505  :         return _STD _Variant_raw_get<_Idx - 32>(static_cast<_Storage&&>(_Obj)
; 506  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 507  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 508  :     } else { // _Idx >= 64
; 509  :         return _STD _Variant_raw_get<_Idx - 64>(static_cast<_Storage&&>(_Obj)
; 510  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 511  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 512  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 513  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 514  :     }
; 515  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Variant_raw_get@$0A@AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::_Variant_raw_get<0,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$_Variant_raw_get@$04AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Variant_raw_get@$04AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::_Variant_raw_get<5,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>, COMDAT

; 480  : _NODISCARD constexpr decltype(auto) _Variant_raw_get(_Storage&& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 481  :     // access the _Idx-th element of a _Variant_storage
; 482  :     if constexpr (_Idx == 0) {
; 483  :         return static_cast<_Storage&&>(_Obj)._Get();
; 484  :     } else if constexpr (_Idx == 1) {
; 485  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 486  :     } else if constexpr (_Idx == 2) {
; 487  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 488  :     } else if constexpr (_Idx == 3) {
; 489  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 490  :     } else if constexpr (_Idx == 4) {
; 491  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 492  :     } else if constexpr (_Idx == 5) {
; 493  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();

	mov	rax, QWORD PTR _Obj$[rbp]
	mov	rcx, rax
	call	?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGAAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Variant_storage_<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get

; 494  :     } else if constexpr (_Idx == 6) {
; 495  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 496  :     } else if constexpr (_Idx == 7) {
; 497  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 498  :     } else if constexpr (_Idx < 16) {
; 499  :         return _STD _Variant_raw_get<_Idx - 8>(
; 500  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 501  :     } else if constexpr (_Idx < 32) {
; 502  :         return _STD _Variant_raw_get<_Idx - 16>(static_cast<_Storage&&>(_Obj)
; 503  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 504  :     } else if constexpr (_Idx < 64) {
; 505  :         return _STD _Variant_raw_get<_Idx - 32>(static_cast<_Storage&&>(_Obj)
; 506  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 507  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 508  :     } else { // _Idx >= 64
; 509  :         return _STD _Variant_raw_get<_Idx - 64>(static_cast<_Storage&&>(_Obj)
; 510  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 511  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 512  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 513  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 514  :     }
; 515  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Variant_raw_get@$04AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::_Variant_raw_get<5,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Var$ = 224
??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<5,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1160 : _NODISCARD constexpr decltype(auto) get(variant<_Types...>& _Var) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1161 :     // access the contained value of _Var if its _Idx-th alternative is active
; 1162 :     static_assert(_Idx < sizeof...(_Types), "variant index out of bounds");
; 1163 :     if (_Var.index() == _Idx) {

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
	cmp	rax, 5
	jne	SHORT $LN2@get

; 1164 :         return _STD _Variant_raw_get<_Idx>(_Var._Storage());

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
	mov	rcx, rax
	call	??$_Variant_raw_get@$04AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<5,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>
	jmp	SHORT $LN1@get
$LN2@get:

; 1165 :     }
; 1166 : 
; 1167 :     _STD _Throw_bad_variant_access();

	call	?_Throw_bad_variant_access@std@@YAXXZ	; std::_Throw_bad_variant_access
	npad	1
$LN1@get:
$LN3@get:

; 1168 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<5,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Var$ = 224
??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<5,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1180 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1181 :     // access the contained value of _Var if its _Idx-th alternative is active
; 1182 :     static_assert(_Idx < sizeof...(_Types), "variant index out of bounds");
; 1183 :     if (_Var.index() == _Idx) {

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
	cmp	rax, 5
	jne	SHORT $LN2@get

; 1184 :         return _STD _Variant_raw_get<_Idx>(_Var._Storage());

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
	mov	rcx, rax
	call	??$_Variant_raw_get@$04AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<5,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
	jmp	SHORT $LN1@get
$LN2@get:

; 1185 :     }
; 1186 : 
; 1187 :     _STD _Throw_bad_variant_access();

	call	?_Throw_bad_variant_access@std@@YAXXZ	; std::_Throw_bad_variant_access
	npad	1
$LN1@get:
$LN3@get:

; 1188 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<5,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Var$ = 256
??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1201 : _NODISCARD constexpr decltype(auto) get(variant<_Types...>& _Var) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1202 :     // access the contained value of _Var if its alternative _Ty is active
; 1203 :     constexpr size_t _Idx = _Meta_find_unique_index<variant<_Types...>, _Ty>::value;

	mov	QWORD PTR _Idx$[rbp], 5

; 1204 :     if constexpr (_Idx < sizeof...(_Types)) {
; 1205 :         return _STD get<_Idx>(_Var);

	mov	rcx, QWORD PTR _Var$[rbp]
	call	??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<5,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1206 :     } else {
; 1207 :         static_assert(false, "get<T>(variant<Types...>&) "
; 1208 :                              "requires T to occur exactly once in Types. (N4971 [variant.get]/8)");
; 1209 :     }
; 1210 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Var$ = 256
??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1223 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1224 :     // access the contained value of _Var if its alternative _Ty is active
; 1225 :     constexpr size_t _Idx = _Meta_find_unique_index<variant<_Types...>, _Ty>::value;

	mov	QWORD PTR _Idx$[rbp], 5

; 1226 :     if constexpr (_Idx < sizeof...(_Types)) {
; 1227 :         return _STD get<_Idx>(_Var);

	mov	rcx, QWORD PTR _Var$[rbp]
	call	??$get@$04PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<5,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1228 :     } else {
; 1229 :         static_assert(false, "get<T>(const variant<Types...>&) "
; 1230 :                              "requires T to occur exactly once in Types. (N4971 [variant.get]/8)");
; 1231 :     }
; 1232 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$_Variant_raw_get@$03AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Variant_raw_get@$03AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::_Variant_raw_get<4,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>, COMDAT

; 480  : _NODISCARD constexpr decltype(auto) _Variant_raw_get(_Storage&& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 481  :     // access the _Idx-th element of a _Variant_storage
; 482  :     if constexpr (_Idx == 0) {
; 483  :         return static_cast<_Storage&&>(_Obj)._Get();
; 484  :     } else if constexpr (_Idx == 1) {
; 485  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 486  :     } else if constexpr (_Idx == 2) {
; 487  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 488  :     } else if constexpr (_Idx == 3) {
; 489  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 490  :     } else if constexpr (_Idx == 4) {
; 491  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();

	mov	rax, QWORD PTR _Obj$[rbp]
	mov	rcx, rax
	call	?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ ; std::_Variant_storage_<1,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get

; 492  :     } else if constexpr (_Idx == 5) {
; 493  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 494  :     } else if constexpr (_Idx == 6) {
; 495  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 496  :     } else if constexpr (_Idx == 7) {
; 497  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 498  :     } else if constexpr (_Idx < 16) {
; 499  :         return _STD _Variant_raw_get<_Idx - 8>(
; 500  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 501  :     } else if constexpr (_Idx < 32) {
; 502  :         return _STD _Variant_raw_get<_Idx - 16>(static_cast<_Storage&&>(_Obj)
; 503  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 504  :     } else if constexpr (_Idx < 64) {
; 505  :         return _STD _Variant_raw_get<_Idx - 32>(static_cast<_Storage&&>(_Obj)
; 506  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 507  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 508  :     } else { // _Idx >= 64
; 509  :         return _STD _Variant_raw_get<_Idx - 64>(static_cast<_Storage&&>(_Obj)
; 510  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 511  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 512  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 513  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 514  :     }
; 515  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Variant_raw_get@$03AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::_Variant_raw_get<4,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Var$ = 224
??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<4,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1160 : _NODISCARD constexpr decltype(auto) get(variant<_Types...>& _Var) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1161 :     // access the contained value of _Var if its _Idx-th alternative is active
; 1162 :     static_assert(_Idx < sizeof...(_Types), "variant index out of bounds");
; 1163 :     if (_Var.index() == _Idx) {

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
	cmp	rax, 4
	jne	SHORT $LN2@get

; 1164 :         return _STD _Variant_raw_get<_Idx>(_Var._Storage());

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
	mov	rcx, rax
	call	??$_Variant_raw_get@$03AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<4,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>
	jmp	SHORT $LN1@get
$LN2@get:

; 1165 :     }
; 1166 : 
; 1167 :     _STD _Throw_bad_variant_access();

	call	?_Throw_bad_variant_access@std@@YAXXZ	; std::_Throw_bad_variant_access
	npad	1
$LN1@get:
$LN3@get:

; 1168 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<4,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Var$ = 224
??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<4,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1180 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1181 :     // access the contained value of _Var if its _Idx-th alternative is active
; 1182 :     static_assert(_Idx < sizeof...(_Types), "variant index out of bounds");
; 1183 :     if (_Var.index() == _Idx) {

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
	cmp	rax, 4
	jne	SHORT $LN2@get

; 1184 :         return _STD _Variant_raw_get<_Idx>(_Var._Storage());

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
	mov	rcx, rax
	call	??$_Variant_raw_get@$03AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<4,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
	jmp	SHORT $LN1@get
$LN2@get:

; 1185 :     }
; 1186 : 
; 1187 :     _STD _Throw_bad_variant_access();

	call	?_Throw_bad_variant_access@std@@YAXXZ	; std::_Throw_bad_variant_access
	npad	1
$LN1@get:
$LN3@get:

; 1188 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<4,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Var$ = 256
??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1201 : _NODISCARD constexpr decltype(auto) get(variant<_Types...>& _Var) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1202 :     // access the contained value of _Var if its alternative _Ty is active
; 1203 :     constexpr size_t _Idx = _Meta_find_unique_index<variant<_Types...>, _Ty>::value;

	mov	QWORD PTR _Idx$[rbp], 4

; 1204 :     if constexpr (_Idx < sizeof...(_Types)) {
; 1205 :         return _STD get<_Idx>(_Var);

	mov	rcx, QWORD PTR _Var$[rbp]
	call	??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<4,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1206 :     } else {
; 1207 :         static_assert(false, "get<T>(variant<Types...>&) "
; 1208 :                              "requires T to occur exactly once in Types. (N4971 [variant.get]/8)");
; 1209 :     }
; 1210 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Var$ = 256
??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1223 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1224 :     // access the contained value of _Var if its alternative _Ty is active
; 1225 :     constexpr size_t _Idx = _Meta_find_unique_index<variant<_Types...>, _Ty>::value;

	mov	QWORD PTR _Idx$[rbp], 4

; 1226 :     if constexpr (_Idx < sizeof...(_Types)) {
; 1227 :         return _STD get<_Idx>(_Var);

	mov	rcx, QWORD PTR _Var$[rbp]
	call	??$get@$03PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<4,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1228 :     } else {
; 1229 :         static_assert(false, "get<T>(const variant<Types...>&) "
; 1230 :                              "requires T to occur exactly once in Types. (N4971 [variant.get]/8)");
; 1231 :     }
; 1232 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_G?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z PROC ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 80					; 00000050H
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_G?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z ENDP ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ PROC ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ ENDP ; std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::~_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 32					; 00000020H
	mov	rcx, rax
	call	??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::~_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >,1>::_Get_first, COMDAT

; 1558 :     constexpr _Ty1& _Get_first() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1559 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1560 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xhash
;	COMDAT ??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 4
$T4 = 228
__$ArrayPad$ = 248
this$ = 288
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >, COMDAT

; 315  :     ~_Hash_vec() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__E94B15B1_xhash
	call	__CheckForDebuggerJustMyCode
	npad	1

; 316  :         _Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::_Tidy
	npad	1

; 317  : #if _ITERATOR_DEBUG_LEVEL != 0
; 318  :         auto _Alproxy = _STD _Get_proxy_allocator(_Mypair._Get_first());

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >,1>::_Get_first
	mov	rdx, rax
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_proxy_allocator<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >
	npad	1

; 319  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	QWORD PTR $T4[rbp], 0
	mov	rax, QWORD PTR this$[rbp]
	lea	rdx, QWORD PTR $T4[rbp]
	mov	rcx, rax
	call	??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	npad	1

; 320  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 321  :     }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??1?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::~_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xhash
;	COMDAT ?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv92 = 192
tv90 = 200
tv88 = 208
this$ = 256
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::_Tidy, COMDAT

; 305  :     void _Tidy() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E94B15B1_xhash
	call	__CheckForDebuggerJustMyCode
	npad	1

; 306  :         if (_Mypair._Myval2._Myfirst != nullptr) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax+8], 0
	je	$LN2@Tidy

; 307  :             _Destroy_range(_Mypair._Myval2._Myfirst, _Mypair._Myval2._Mylast);

	mov	rax, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Destroy_range@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@0@QEAV10@@Z ; std::_Destroy_range<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > *>
	npad	1

; 308  :             _Mypair._Get_first().deallocate(_Mypair._Myval2._Myfirst, capacity());

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >,1>::_Get_first
	mov	QWORD PTR tv92[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::capacity
	mov	QWORD PTR tv90[rbp], rax
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv88[rbp], rax
	mov	r8, QWORD PTR tv90[rbp]
	mov	rdx, QWORD PTR tv88[rbp]
	mov	rcx, QWORD PTR tv92[rbp]
	call	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >::deallocate
	npad	1

; 309  :             _Mypair._Myval2._Myfirst = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+8], 0

; 310  :             _Mypair._Myval2._Mylast  = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+16], 0

; 311  :             _Mypair._Myval2._Myend   = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+24], 0
$LN2@Tidy:

; 312  :         }
; 313  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Tidy@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xhash
;	COMDAT ?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 224
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::capacity, COMDAT

; 275  :     _NODISCARD size_type capacity() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E94B15B1_xhash
	call	__CheckForDebuggerJustMyCode
	npad	1

; 276  :         // This implementation never has capacity() differ from size(), but the previous implementation could.
; 277  :         // We need to handle that situation gracefully since we may link to old code (See GH-2774).
; 278  :         return static_cast<size_type>(_Mypair._Myval2._Myend - _Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	sar	rax, 3

; 279  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?capacity@?$_Hash_vec@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash_vec<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >::deallocate, COMDAT

; 986  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 987  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rbp], 0
	jne	SHORT $LN2@deallocate
	cmp	QWORD PTR _Count$[rbp], 0
	je	SHORT $LN2@deallocate
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 987				; 000003dbH
	lea	rdx, OFFSET FLAT:??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN4@deallocate
	int	3
	xor	eax, eax
$LN4@deallocate:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@deallocate:

; 988  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rbp]
	shl	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 990  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@std@@@std@@QEAAXQEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
tv69 = 192
this$ = 240
__$ReturnUdt$ = 248
?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::_Unchecked_end, COMDAT

; 818  :     _Unchecked_const_iterator _Unchecked_end() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E94B15B1_xhash
	call	__CheckForDebuggerJustMyCode
	npad	1

; 819  :         return _List._Unchecked_end();

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	QWORD PTR tv69[rbp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rbp]
	mov	rcx, QWORD PTR tv69[rbp]
	call	?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Unchecked_end
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 820  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
tv69 = 192
this$ = 240
__$ReturnUdt$ = 248
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::_Unchecked_begin, COMDAT

; 810  :     _Unchecked_const_iterator _Unchecked_begin() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E94B15B1_xhash
	call	__CheckForDebuggerJustMyCode
	npad	1

; 811  :         return _List._Unchecked_begin();

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	QWORD PTR tv69[rbp], rax
	mov	rdx, QWORD PTR __$ReturnUdt$[rbp]
	mov	rcx, QWORD PTR tv69[rbp]
	call	?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Unchecked_begin
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 812  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,1>::_Get_first, COMDAT

; 1558 :     constexpr _Ty1& _Get_first() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1559 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1560 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Getal, COMDAT

; 1862 :     _Alnode& _Getal() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1863 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >,std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,1>::_Get_first

; 1864 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_Al$ = 8
_My_data$ = 40
this$ = 288
?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAXXZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Tidy, COMDAT

; 1514 :     void _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1515 :         auto& _Al      = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Getal
	mov	QWORD PTR _Al$[rbp], rax

; 1516 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 1517 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 1518 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Free_non_head@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Free_non_head<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
	npad	1

; 1519 :         _Node::_Freenode0(_Al, _My_data._Myhead);

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Freenode0@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *>::_Freenode0<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
	npad	1

; 1520 :     }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAXXZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
this$ = 224
__$ReturnUdt$ = 232
?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Unchecked_end, COMDAT

; 1132 :     _Unchecked_const_iterator _Unchecked_end() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1133 :         return _Unchecked_const_iterator(_Mypair._Myval2._Myhead, nullptr);

	xor	r8d, r8d
	mov	rax, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 1134 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Unchecked_end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
this$ = 224
__$ReturnUdt$ = 232
?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Unchecked_begin, COMDAT

; 1124 :     _Unchecked_const_iterator _Unchecked_begin() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1125 :         return _Unchecked_const_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 1126 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Unchecked_begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\list
;	COMDAT ??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 4
__$ArrayPad$ = 216
this$ = 256
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >, COMDAT

; 1060 :     ~list() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 10
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__1099CBE1_list
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1061 :         _Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAXXZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Tidy
	npad	1

; 1062 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1063 :         auto _Alproxy = _STD _Get_proxy_allocator(_Getal());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@AEAAAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@0@@Z ; std::_Get_proxy_allocator<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >
	npad	1

; 1064 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);

	mov	rax, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	npad	1

; 1065 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1066 :     }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??1?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >::~list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >::deallocate, COMDAT

; 718  :     /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 719  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 720  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 721  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@deallocate

; 722  :             _Al.deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >::deallocate
	npad	1

; 723  :         } else

	jmp	SHORT $LN3@deallocate
$LN2@deallocate:

; 724  : #endif // _HAS_CXX20
; 725  :         {
; 726  :             (void) _Al;
; 727  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rbp], 80		; 00000050H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1
$LN3@deallocate:

; 728  :         }
; 729  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@2@QEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >::deallocate, COMDAT

; 986  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 987  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rbp], 0
	jne	SHORT $LN2@deallocate
	cmp	QWORD PTR _Count$[rbp], 0
	je	SHORT $LN2@deallocate
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 987				; 000003dbH
	lea	rdx, OFFSET FLAT:??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN4@deallocate
	int	3
	xor	eax, eax
$LN4@deallocate:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@deallocate:

; 988  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rbp], 80		; 00000050H
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 990  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$?0PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@$0A@@?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??$?0PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@$0A@@?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@XZ PROC ; std::variant<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::variant<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::vector<Json::Value,std::allocator<Json::Value> > *,0>, COMDAT

; 942  :         : _Mybase(in_place_index<0>) {} // value-initialize alternative 0

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1
	movzx	edx, BYTE PTR ??$in_place_index@$0A@@std@@3U?$in_place_index_t@$0A@@1@B ; std::in_place_index<0>
	mov	rcx, QWORD PTR this$[rbp]
	call	??$?0$0A@$$V$0A@@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@U?$in_place_index_t@$0A@@1@@Z ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><0,0>
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@$0A@@?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@XZ ENDP ; std::variant<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::variant<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::vector<Json::Value,std::allocator<Json::Value> > *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_G?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAAPEAXI@Z PROC ; std::vector<Json::Value,std::allocator<Json::Value> >::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ ; std::vector<Json::Value,std::allocator<Json::Value> >::~vector<Json::Value,std::allocator<Json::Value> >
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_G?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAAPEAXI@Z ENDP ; std::vector<Json::Value,std::allocator<Json::Value> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@VValue@Json@@@std@@V?$_Vector_val@U?$_Simple_types@VValue@Json@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VValue@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@VValue@Json@@@std@@V?$_Vector_val@U?$_Simple_types@VValue@Json@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VValue@Json@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Json::Value>,std::_Vector_val<std::_Simple_types<Json::Value> >,1>::_Get_first, COMDAT

; 1558 :     constexpr _Ty1& _Get_first() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1559 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1560 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@VValue@Json@@@std@@V?$_Vector_val@U?$_Simple_types@VValue@Json@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VValue@Json@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Json::Value>,std::_Vector_val<std::_Simple_types<Json::Value> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?_Getal@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAAEAV?$allocator@VValue@Json@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getal@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAAEAV?$allocator@VValue@Json@@@2@XZ PROC ; std::vector<Json::Value,std::allocator<Json::Value> >::_Getal, COMDAT

; 2226 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__20193517_vector
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2227 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@VValue@Json@@@std@@V?$_Vector_val@U?$_Simple_types@VValue@Json@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VValue@Json@@@2@XZ ; std::_Compressed_pair<std::allocator<Json::Value>,std::_Vector_val<std::_Simple_types<Json::Value> >,1>::_Get_first

; 2228 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getal@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAAEAV?$allocator@VValue@Json@@@2@XZ ENDP ; std::vector<Json::Value,std::allocator<Json::Value> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?_Tidy@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Al$ = 8
_My_data$ = 40
_Myfirst$ = 72
_Mylast$ = 104
_Myend$ = 136
this$ = 384
?_Tidy@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAXXZ PROC ; std::vector<Json::Value,std::allocator<Json::Value> >::_Tidy, COMDAT

; 2081 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__20193517_vector
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2082 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAAEAV?$allocator@VValue@Json@@@2@XZ ; std::vector<Json::Value,std::allocator<Json::Value> >::_Getal
	mov	QWORD PTR _Al$[rbp], rax

; 2083 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 2084 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	mov	QWORD PTR _Myfirst$[rbp], rax

; 2085 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 16
	mov	QWORD PTR _Mylast$[rbp], rax

; 2086 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 24
	mov	QWORD PTR _Myend$[rbp], rax

; 2087 : 
; 2088 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 2089 : 
; 2090 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 2091 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rbp]
	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@VValue@Json@@@std@@@std@@YAXPEAVValue@Json@@QEAV12@AEAV?$allocator@VValue@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Value> >
	npad	1

; 2092 :             _ASAN_VECTOR_REMOVE;
; 2093 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rbp]
	mov	rcx, QWORD PTR _Myfirst$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@VValue@Json@@@std@@QEAAXQEAVValue@Json@@_K@Z ; std::allocator<Json::Value>::deallocate
	npad	1

; 2094 : 
; 2095 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rbp]
	mov	QWORD PTR [rax], 0

; 2096 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rbp]
	mov	QWORD PTR [rax], 0

; 2097 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rbp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 2098 :         }
; 2099 :     }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
?_Tidy@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAXXZ ENDP ; std::vector<Json::Value,std::allocator<Json::Value> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??A?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBAAEBVValue@Json@@_K@Z
_TEXT	SEGMENT
_My_data$ = 8
this$ = 256
_Pos$ = 264
??A?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBAAEBVValue@Json@@_K@Z PROC ; std::vector<Json::Value,std::allocator<Json::Value> >::operator[], COMDAT

; 1937 :     _NODISCARD _CONSTEXPR20 const _Ty& operator[](const size_type _Pos) const noexcept /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__20193517_vector
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1938 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 1939 : #if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
; 1940 :         _STL_VERIFY(

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx
	cmp	QWORD PTR _Pos$[rbp], rax
	jb	SHORT $LN2@operator
	lea	rax, OFFSET FLAT:??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1941				; 00000795H
	lea	rdx, OFFSET FLAT:??_C@_0FP@FHDFLINP@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN4@operator
	int	3
	xor	eax, eax
$LN4@operator:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@operator:

; 1941 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1942 : #endif
; 1943 : 
; 1944 :         return _My_data._Myfirst[_Pos];

	imul	rax, QWORD PTR _Pos$[rbp], 24
	mov	rcx, QWORD PTR _My_data$[rbp]
	add	rax, QWORD PTR [rcx+8]

; 1945 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??A?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBAAEBVValue@Json@@_K@Z ENDP ; std::vector<Json::Value,std::allocator<Json::Value> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ?size@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 8
this$ = 256
?size@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBA_KXZ PROC ; std::vector<Json::Value,std::allocator<Json::Value> >::size, COMDAT

; 1913 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__20193517_vector
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1914 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 1915 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	cdq
	mov	ecx, 24
	idiv	rcx

; 1916 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?size@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<Json::Value,std::allocator<Json::Value> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vector
;	COMDAT ??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 4
$T4 = 228
__$ArrayPad$ = 248
this$ = 288
??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ PROC ; std::vector<Json::Value,std::allocator<Json::Value> >::~vector<Json::Value,std::allocator<Json::Value> >, COMDAT

; 829  :     _CONSTEXPR20 ~vector() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__20193517_vector
	call	__CheckForDebuggerJustMyCode
	npad	1

; 830  :         _Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAXXZ ; std::vector<Json::Value,std::allocator<Json::Value> >::_Tidy
	npad	1

; 831  : #if _ITERATOR_DEBUG_LEVEL != 0
; 832  :         auto _Alproxy = _STD _Get_proxy_allocator(_Getal());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@AEAAAEAV?$allocator@VValue@Json@@@2@XZ ; std::vector<Json::Value,std::allocator<Json::Value> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@VValue@Json@@@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@VValue@Json@@@0@@Z ; std::_Get_proxy_allocator<std::allocator<Json::Value> >
	npad	1

; 833  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	QWORD PTR $T4[rbp], 0
	mov	rax, QWORD PTR this$[rbp]
	lea	rdx, QWORD PTR $T4[rbp]
	mov	rcx, rax
	call	??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	npad	1

; 834  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 835  :     }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??1?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAA@XZ ENDP ; std::vector<Json::Value,std::allocator<Json::Value> >::~vector<Json::Value,std::allocator<Json::Value> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?deallocate@?$allocator@VValue@Json@@@std@@QEAAXQEAVValue@Json@@_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@VValue@Json@@@std@@QEAAXQEAVValue@Json@@_K@Z PROC ; std::allocator<Json::Value>::deallocate, COMDAT

; 986  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 987  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rbp], 0
	jne	SHORT $LN2@deallocate
	cmp	QWORD PTR _Count$[rbp], 0
	je	SHORT $LN2@deallocate
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 987				; 000003dbH
	lea	rdx, OFFSET FLAT:??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN4@deallocate
	int	3
	xor	eax, eax
$LN4@deallocate:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@deallocate:

; 988  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rbp], 24
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 990  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$allocator@VValue@Json@@@std@@QEAAXQEAVValue@Json@@_K@Z ENDP ; std::allocator<Json::Value>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$_Variant_raw_get@$0A@AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Obj$ = 224
??$_Variant_raw_get@$0A@AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::_Variant_raw_get<0,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>, COMDAT

; 480  : _NODISCARD constexpr decltype(auto) _Variant_raw_get(_Storage&& _Obj) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 481  :     // access the _Idx-th element of a _Variant_storage
; 482  :     if constexpr (_Idx == 0) {
; 483  :         return static_cast<_Storage&&>(_Obj)._Get();

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get

; 484  :     } else if constexpr (_Idx == 1) {
; 485  :         return static_cast<_Storage&&>(_Obj)._Tail._Get();
; 486  :     } else if constexpr (_Idx == 2) {
; 487  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Get();
; 488  :     } else if constexpr (_Idx == 3) {
; 489  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Get();
; 490  :     } else if constexpr (_Idx == 4) {
; 491  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Get();
; 492  :     } else if constexpr (_Idx == 5) {
; 493  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Get();
; 494  :     } else if constexpr (_Idx == 6) {
; 495  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 496  :     } else if constexpr (_Idx == 7) {
; 497  :         return static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Get();
; 498  :     } else if constexpr (_Idx < 16) {
; 499  :         return _STD _Variant_raw_get<_Idx - 8>(
; 500  :             static_cast<_Storage&&>(_Obj)._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 501  :     } else if constexpr (_Idx < 32) {
; 502  :         return _STD _Variant_raw_get<_Idx - 16>(static_cast<_Storage&&>(_Obj)
; 503  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 504  :     } else if constexpr (_Idx < 64) {
; 505  :         return _STD _Variant_raw_get<_Idx - 32>(static_cast<_Storage&&>(_Obj)
; 506  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 507  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 508  :     } else { // _Idx >= 64
; 509  :         return _STD _Variant_raw_get<_Idx - 64>(static_cast<_Storage&&>(_Obj)
; 510  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 511  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 512  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail
; 513  :                 ._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail);
; 514  :     }
; 515  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Variant_raw_get@$0A@AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::_Variant_raw_get<0,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Var$ = 224
??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<0,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1160 : _NODISCARD constexpr decltype(auto) get(variant<_Types...>& _Var) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1161 :     // access the contained value of _Var if its _Idx-th alternative is active
; 1162 :     static_assert(_Idx < sizeof...(_Types), "variant index out of bounds");
; 1163 :     if (_Var.index() == _Idx) {

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
	test	rax, rax
	jne	SHORT $LN2@get

; 1164 :         return _STD _Variant_raw_get<_Idx>(_Var._Storage());

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
	mov	rcx, rax
	call	??$_Variant_raw_get@$0A@AEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<0,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> &>
	jmp	SHORT $LN1@get
$LN2@get:

; 1165 :     }
; 1166 : 
; 1167 :     _STD _Throw_bad_variant_access();

	call	?_Throw_bad_variant_access@std@@YAXXZ	; std::_Throw_bad_variant_access
	npad	1
$LN1@get:
$LN3@get:

; 1168 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<0,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Var$ = 224
??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<0,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1180 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1181 :     // access the contained value of _Var if its _Idx-th alternative is active
; 1182 :     static_assert(_Idx < sizeof...(_Types), "variant index out of bounds");
; 1183 :     if (_Var.index() == _Idx) {

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
	test	rax, rax
	jne	SHORT $LN2@get

; 1184 :         return _STD _Variant_raw_get<_Idx>(_Var._Storage());

	mov	rcx, QWORD PTR _Var$[rbp]
	call	?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
	mov	rcx, rax
	call	??$_Variant_raw_get@$0A@AEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@@std@@YA?A_TAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::_Variant_raw_get<0,std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> const &>
	jmp	SHORT $LN1@get
$LN2@get:

; 1185 :     }
; 1186 : 
; 1187 :     _STD _Throw_bad_variant_access();

	call	?_Throw_bad_variant_access@std@@YAXXZ	; std::_Throw_bad_variant_access
	npad	1
$LN1@get:
$LN3@get:

; 1188 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<0,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Var$ = 256
??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<std::vector<Json::Value,std::allocator<Json::Value> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1201 : _NODISCARD constexpr decltype(auto) get(variant<_Types...>& _Var) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1202 :     // access the contained value of _Var if its alternative _Ty is active
; 1203 :     constexpr size_t _Idx = _Meta_find_unique_index<variant<_Types...>, _Ty>::value;

	mov	QWORD PTR _Idx$[rbp], 0

; 1204 :     if constexpr (_Idx < sizeof...(_Types)) {
; 1205 :         return _STD get<_Idx>(_Var);

	mov	rcx, QWORD PTR _Var$[rbp]
	call	??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<0,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1206 :     } else {
; 1207 :         static_assert(false, "get<T>(variant<Types...>&) "
; 1208 :                              "requires T to occur exactly once in Types. (N4971 [variant.get]/8)");
; 1209 :     }
; 1210 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<std::vector<Json::Value,std::allocator<Json::Value> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z
_TEXT	SEGMENT
_Idx$ = 8
_Var$ = 256
??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z PROC ; std::get<std::vector<Json::Value,std::allocator<Json::Value> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1223 : _NODISCARD constexpr decltype(auto) get(const variant<_Types...>& _Var) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1224 :     // access the contained value of _Var if its alternative _Ty is active
; 1225 :     constexpr size_t _Idx = _Meta_find_unique_index<variant<_Types...>, _Ty>::value;

	mov	QWORD PTR _Idx$[rbp], 0

; 1226 :     if constexpr (_Idx < sizeof...(_Types)) {
; 1227 :         return _STD get<_Idx>(_Var);

	mov	rcx, QWORD PTR _Var$[rbp]
	call	??$get@$0A@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<0,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1228 :     } else {
; 1229 :         static_assert(false, "get<T>(const variant<Types...>&) "
; 1230 :                              "requires T to occur exactly once in Types. (N4971 [variant.get]/8)");
; 1231 :     }
; 1232 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ENDP ; std::get<std::vector<Json::Value,std::allocator<Json::Value> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GValue@Json@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_GValue@Json@@QEAAPEAXI@Z PROC			; Json::Value::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1Value@Json@@QEAA@XZ			; Json::Value::~Value
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_GValue@Json@@QEAAPEAXI@Z ENDP			; Json::Value::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@Value@Json@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 224
classSize$ = 232
?__autoclassinit2@Value@Json@@QEAAX_K@Z PROC		; Json::Value::__autoclassinit2, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rbp, rsp
	mov	rdi, QWORD PTR this$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR classSize$[rbp]
	rep stosb
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__autoclassinit2@Value@Json@@QEAAX_K@Z ENDP		; Json::Value::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Value.h
;	COMDAT ?fromFile@Value@Json@@SA?AV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 224
filename$ = 232
?fromFile@Value@Json@@SA?AV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::fromFile, COMDAT

; 327  : 		static Value fromFile(const std::string& filename) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__6DE13511_Value@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 328  : 			//return Detail::Parser::parseFile(filename);
; 329  : 		}

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?fromFile@Value@Json@@SA?AV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::fromFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Value.h
;	COMDAT ?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
_TEXT	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z PROC ; Json::Value::stringify, COMDAT

; 187  : 		std::string stringify(size_t indent = 0) const {

$LN61:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 3800				; 00000ed8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 654				; 0000028eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+3832]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	mov	DWORD PTR $T50[rbp], 0
	lea	rcx, OFFSET FLAT:__6DE13511_Value@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 188  : 			switch (m_type) {

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 6
	ja	$LN20@stringify
	movsxd	rax, DWORD PTR tv65[rbp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN59@stringify[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN10@stringify:

; 189  : 			case Type::Array: {
; 190  : 				std::string result = std::string(indent, ' ') + "[\n";

	mov	r8b, 32					; 00000020H
	mov	rdx, QWORD PTR indent$[rbp]
	lea	rcx, QWORD PTR $T18[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv442[rbp], rax
	mov	rax, QWORD PTR tv442[rbp]
	mov	QWORD PTR tv460[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_02JKLIAPDG@?$FL?6@
	mov	rdx, QWORD PTR tv460[rbp]
	lea	rcx, QWORD PTR result$7[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T18[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 191  : 				const auto& arr = *std::get<std::vector<Value>*>(m_value);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::vector<Json::Value,std::allocator<Json::Value> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR arr$8[rbp], rax

; 192  : 				for (size_t i = 0; i < arr.size(); ++i) {

	mov	QWORD PTR i$9[rbp], 0
	jmp	SHORT $LN6@stringify
$LN4@stringify:
	mov	rax, QWORD PTR i$9[rbp]
	inc	rax
	mov	QWORD PTR i$9[rbp], rax
$LN6@stringify:
	mov	rcx, QWORD PTR arr$8[rbp]
	call	?size@?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBA_KXZ ; std::vector<Json::Value,std::allocator<Json::Value> >::size
	cmp	QWORD PTR i$9[rbp], rax
	jae	$LN5@stringify

; 193  : 					result += arr[i].stringify(indent + 2) + ",\n";

	mov	rdx, QWORD PTR i$9[rbp]
	mov	rcx, QWORD PTR arr$8[rbp]
	call	??A?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEBAAEBVValue@Json@@_K@Z ; std::vector<Json::Value,std::allocator<Json::Value> >::operator[]
	mov	QWORD PTR tv129[rbp], rax
	mov	rax, QWORD PTR indent$[rbp]
	add	rax, 2
	mov	r8, rax
	lea	rdx, QWORD PTR $T19[rbp]
	mov	rcx, QWORD PTR tv129[rbp]
	call	?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Value::stringify
	mov	QWORD PTR tv66[rbp], rax
	mov	rax, QWORD PTR tv66[rbp]
	mov	QWORD PTR tv463[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_02MLAGHBOD@?0?6@
	mov	rdx, QWORD PTR tv463[rbp]
	lea	rcx, QWORD PTR $T20[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv419[rbp], rax
	mov	rax, QWORD PTR tv419[rbp]
	mov	QWORD PTR tv465[rbp], rax
	mov	rdx, QWORD PTR tv465[rbp]
	lea	rcx, QWORD PTR result$7[rbp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
	lea	rcx, QWORD PTR $T20[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T19[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 194  : 				}

	jmp	$LN4@stringify
$LN5@stringify:

; 195  : 				result += std::string(indent, ' ') + "]";

	mov	r8b, 32					; 00000020H
	mov	rdx, QWORD PTR indent$[rbp]
	lea	rcx, QWORD PTR $T21[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv396[rbp], rax
	mov	rax, QWORD PTR tv396[rbp]
	mov	QWORD PTR tv467[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN@
	mov	rdx, QWORD PTR tv467[rbp]
	lea	rcx, QWORD PTR $T22[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv379[rbp], rax
	mov	rax, QWORD PTR tv379[rbp]
	mov	QWORD PTR tv469[rbp], rax
	mov	rdx, QWORD PTR tv469[rbp]
	lea	rcx, QWORD PTR result$7[rbp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
	lea	rcx, QWORD PTR $T22[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T21[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 196  : 				return result;

	lea	rdx, QWORD PTR result$7[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T50[rbp]
	or	eax, 1
	mov	DWORD PTR $T50[rbp], eax
	lea	rcx, QWORD PTR result$7[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]
	jmp	$LN21@stringify
$LN11@stringify:

; 197  : 			}
; 198  : 			case Type::Object: {
; 199  : 				std::string result = std::string(indent, ' ') + "{\n";

	mov	r8b, 32					; 00000020H
	mov	rdx, QWORD PTR indent$[rbp]
	lea	rcx, QWORD PTR $T23[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv349[rbp], rax
	mov	rax, QWORD PTR tv349[rbp]
	mov	QWORD PTR tv476[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_02KCPFEJNG@?$HL?6@
	mov	rdx, QWORD PTR tv476[rbp]
	lea	rcx, QWORD PTR result$10[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T23[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 200  : 				const auto& map = *std::get<std::unordered_map<std::string, Value>*>(m_value);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR map$11[rbp], rax

; 201  : 				for (const auto& [key, val] : map) {

	mov	rax, QWORD PTR map$11[rbp]
	mov	QWORD PTR <range>$L0$12[rbp], rax
	mov	edx, 8
	lea	rcx, QWORD PTR <begin>$L0$13[rbp]
	call	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
	lea	rdx, QWORD PTR <begin>$L0$13[rbp]
	mov	rcx, QWORD PTR <range>$L0$12[rbp]
	call	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::_Unchecked_begin
	npad	1
	mov	edx, 8
	lea	rcx, QWORD PTR <end>$L0$14[rbp]
	call	?__autoclassinit2@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
	lea	rdx, QWORD PTR <end>$L0$14[rbp]
	mov	rcx, QWORD PTR <range>$L0$12[rbp]
	call	?_Unchecked_end@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@$0A@@std@@@std@@QEBA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> >,0> >::_Unchecked_end
	npad	1
	jmp	SHORT $LN9@stringify
$LN7@stringify:
	lea	rcx, QWORD PTR <begin>$L0$13[rbp]
	call	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator++
	npad	1
$LN9@stringify:
	lea	rdx, QWORD PTR <end>$L0$14[rbp]
	lea	rcx, QWORD PTR <begin>$L0$13[rbp]
	call	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator==
	movzx	eax, al
	test	eax, eax
	jne	$LN8@stringify
	lea	rcx, QWORD PTR <begin>$L0$13[rbp]
	call	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > >,std::_Iterator_base0>::operator*
	mov	QWORD PTR $S1$15[rbp], rax
	mov	rcx, QWORD PTR $S1$15[rbp]
	call	??$get@$0A@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z ; std::get<0,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>
	mov	QWORD PTR key$16[rbp], rax
	mov	rcx, QWORD PTR $S1$15[rbp]
	call	??$get@$00$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@YAAEBVValue@Json@@AEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@0@@Z ; std::get<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value>
	mov	QWORD PTR val$17[rbp], rax

; 202  : 					if (val.m_type == Type::Array || val.m_type == Type::Object)

	mov	rax, QWORD PTR val$17[rbp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN14@stringify
	mov	rax, QWORD PTR val$17[rbp]
	cmp	DWORD PTR [rax], 4
	jne	$LN12@stringify
$LN14@stringify:

; 203  : 						result += std::string(indent + 2, ' ') + "\"" + key + "\":\n"

	mov	rax, QWORD PTR indent$[rbp]
	add	rax, 2
	mov	r8, rax
	lea	rdx, QWORD PTR $T24[rbp]
	mov	rcx, QWORD PTR val$17[rbp]
	call	?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Value::stringify
	mov	QWORD PTR tv154[rbp], rax
	mov	rax, QWORD PTR tv154[rbp]
	mov	QWORD PTR tv479[rbp], rax
	mov	rax, QWORD PTR tv479[rbp]
	mov	QWORD PTR tv243[rbp], rax
	mov	rax, QWORD PTR indent$[rbp]
	add	rax, 2
	mov	r8b, 32					; 00000020H
	mov	rdx, rax
	lea	rcx, QWORD PTR $T25[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv346[rbp], rax
	mov	rax, QWORD PTR tv346[rbp]
	mov	QWORD PTR tv481[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC@
	mov	rdx, QWORD PTR tv481[rbp]
	lea	rcx, QWORD PTR $T26[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv151[rbp], rax
	mov	rax, QWORD PTR tv151[rbp]
	mov	QWORD PTR tv483[rbp], rax
	mov	r8, QWORD PTR key$16[rbp]
	mov	rdx, QWORD PTR tv483[rbp]
	lea	rcx, QWORD PTR $T27[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv535[rbp], rax
	mov	rax, QWORD PTR tv535[rbp]
	mov	QWORD PTR tv485[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_03HJDMPJK@?$CC?3?6@
	mov	rdx, QWORD PTR tv485[rbp]
	lea	rcx, QWORD PTR $T28[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv536[rbp], rax
	mov	rax, QWORD PTR tv536[rbp]
	mov	QWORD PTR tv487[rbp], rax
	mov	rax, QWORD PTR tv487[rbp]
	mov	QWORD PTR tv241[rbp], rax
	mov	r8, QWORD PTR tv243[rbp]
	mov	rdx, QWORD PTR tv241[rbp]
	lea	rcx, QWORD PTR $T29[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv537[rbp], rax
	mov	rax, QWORD PTR tv537[rbp]
	mov	QWORD PTR tv489[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_02MLAGHBOD@?0?6@
	mov	rdx, QWORD PTR tv489[rbp]
	lea	rcx, QWORD PTR $T30[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv538[rbp], rax
	mov	rax, QWORD PTR tv538[rbp]
	mov	QWORD PTR tv491[rbp], rax
	mov	rdx, QWORD PTR tv491[rbp]
	lea	rcx, QWORD PTR result$10[rbp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
	lea	rcx, QWORD PTR $T30[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T29[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T28[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T27[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T26[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T25[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T24[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	jmp	$LN13@stringify
$LN12@stringify:

; 204  : 						+ val.stringify(indent + 2) + ",\n";
; 205  : 					else result += std::string(indent + 2, ' ') + "\"" + key + "\": "

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T31[rbp]
	mov	rcx, QWORD PTR val$17[rbp]
	call	?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::Value::stringify
	mov	QWORD PTR tv539[rbp], rax
	mov	rax, QWORD PTR tv539[rbp]
	mov	QWORD PTR tv493[rbp], rax
	mov	rax, QWORD PTR tv493[rbp]
	mov	QWORD PTR tv324[rbp], rax
	mov	rax, QWORD PTR indent$[rbp]
	add	rax, 2
	mov	r8b, 32					; 00000020H
	mov	rdx, rax
	lea	rcx, QWORD PTR $T32[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv540[rbp], rax
	mov	rax, QWORD PTR tv540[rbp]
	mov	QWORD PTR tv495[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC@
	mov	rdx, QWORD PTR tv495[rbp]
	lea	rcx, QWORD PTR $T33[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv541[rbp], rax
	mov	rax, QWORD PTR tv541[rbp]
	mov	QWORD PTR tv497[rbp], rax
	mov	r8, QWORD PTR key$16[rbp]
	mov	rdx, QWORD PTR tv497[rbp]
	lea	rcx, QWORD PTR $T34[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv542[rbp], rax
	mov	rax, QWORD PTR tv542[rbp]
	mov	QWORD PTR tv499[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_03GIPIADLC@?$CC?3?5@
	mov	rdx, QWORD PTR tv499[rbp]
	lea	rcx, QWORD PTR $T35[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv543[rbp], rax
	mov	rax, QWORD PTR tv543[rbp]
	mov	QWORD PTR tv501[rbp], rax
	mov	rax, QWORD PTR tv501[rbp]
	mov	QWORD PTR tv322[rbp], rax
	mov	r8, QWORD PTR tv324[rbp]
	mov	rdx, QWORD PTR tv322[rbp]
	lea	rcx, QWORD PTR $T36[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv544[rbp], rax
	mov	rax, QWORD PTR tv544[rbp]
	mov	QWORD PTR tv503[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_02MLAGHBOD@?0?6@
	mov	rdx, QWORD PTR tv503[rbp]
	lea	rcx, QWORD PTR $T37[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv545[rbp], rax
	mov	rax, QWORD PTR tv545[rbp]
	mov	QWORD PTR tv505[rbp], rax
	mov	rdx, QWORD PTR tv505[rbp]
	lea	rcx, QWORD PTR result$10[rbp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
	lea	rcx, QWORD PTR $T37[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T36[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T35[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T34[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T33[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T32[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T31[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN13@stringify:

; 206  : 						+ val.stringify() + ",\n";
; 207  : 				}

	jmp	$LN7@stringify
$LN8@stringify:

; 208  : 				result += std::string(indent, ' ') + "}";

	mov	r8b, 32					; 00000020H
	mov	rdx, QWORD PTR indent$[rbp]
	lea	rcx, QWORD PTR $T38[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv546[rbp], rax
	mov	rax, QWORD PTR tv546[rbp]
	mov	QWORD PTR tv507[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_01CELHOKLL@?$HN@
	mov	rdx, QWORD PTR tv507[rbp]
	lea	rcx, QWORD PTR $T39[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv547[rbp], rax
	mov	rax, QWORD PTR tv547[rbp]
	mov	QWORD PTR tv509[rbp], rax
	mov	rdx, QWORD PTR tv509[rbp]
	lea	rcx, QWORD PTR result$10[rbp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	npad	1
	lea	rcx, QWORD PTR $T39[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T38[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 209  : 				return result;

	lea	rdx, QWORD PTR result$10[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T50[rbp]
	or	eax, 1
	mov	DWORD PTR $T50[rbp], eax
	lea	rcx, QWORD PTR result$10[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]
	jmp	$LN21@stringify
$LN15@stringify:

; 210  : 			}				
; 211  : 			case Type::String:
; 212  : 				return std::string(indent, ' ') + "\"" + *std::get<std::string*>(m_value) + "\"";

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv373[rbp], rax
	mov	r8b, 32					; 00000020H
	mov	rdx, QWORD PTR indent$[rbp]
	lea	rcx, QWORD PTR $T40[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv548[rbp], rax
	mov	rax, QWORD PTR tv548[rbp]
	mov	QWORD PTR tv513[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC@
	mov	rdx, QWORD PTR tv513[rbp]
	lea	rcx, QWORD PTR $T41[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv549[rbp], rax
	mov	rax, QWORD PTR tv549[rbp]
	mov	QWORD PTR tv515[rbp], rax
	mov	rax, QWORD PTR tv515[rbp]
	mov	QWORD PTR tv371[rbp], rax
	mov	r8, QWORD PTR tv373[rbp]
	mov	rdx, QWORD PTR tv371[rbp]
	lea	rcx, QWORD PTR $T42[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv550[rbp], rax
	mov	rax, QWORD PTR tv550[rbp]
	mov	QWORD PTR tv517[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC@
	mov	rdx, QWORD PTR tv517[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T50[rbp]
	or	eax, 1
	mov	DWORD PTR $T50[rbp], eax
	lea	rcx, QWORD PTR $T42[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T41[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T40[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]
	jmp	$LN21@stringify
$LN16@stringify:

; 213  : 			case Type::Bool:
; 214  : 				return std::string(indent, ' ') + (std::get<bool>(m_value) ? "true" : "false");

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$get@_NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<bool,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN22@stringify
	lea	rax, OFFSET FLAT:??_C@_04LOAJBDKD@true@
	mov	QWORD PTR tv385[rbp], rax
	jmp	SHORT $LN23@stringify
$LN22@stringify:
	lea	rax, OFFSET FLAT:??_C@_05LAPONLG@false@
	mov	QWORD PTR tv385[rbp], rax
$LN23@stringify:
	mov	r8b, 32					; 00000020H
	mov	rdx, QWORD PTR indent$[rbp]
	lea	rcx, QWORD PTR $T43[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv551[rbp], rax
	mov	rax, QWORD PTR tv551[rbp]
	mov	QWORD PTR tv520[rbp], rax
	mov	r8, QWORD PTR tv385[rbp]
	mov	rdx, QWORD PTR tv520[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T50[rbp]
	or	eax, 1
	mov	DWORD PTR $T50[rbp], eax
	lea	rcx, QWORD PTR $T43[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]
	jmp	$LN21@stringify
$LN17@stringify:

; 215  : 			case Type::Integer:
; 216  : 				return std::string(indent, ' ') + std::to_string(std::get<int>(m_value));

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$get@HPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<int,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	edx, DWORD PTR [rax]
	lea	rcx, QWORD PTR $T44[rbp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
	mov	QWORD PTR tv552[rbp], rax
	mov	rax, QWORD PTR tv552[rbp]
	mov	QWORD PTR tv523[rbp], rax
	mov	rax, QWORD PTR tv523[rbp]
	mov	QWORD PTR tv417[rbp], rax
	mov	r8b, 32					; 00000020H
	mov	rdx, QWORD PTR indent$[rbp]
	lea	rcx, QWORD PTR $T45[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv553[rbp], rax
	mov	rax, QWORD PTR tv553[rbp]
	mov	QWORD PTR tv525[rbp], rax
	mov	rax, QWORD PTR tv525[rbp]
	mov	QWORD PTR tv415[rbp], rax
	mov	r8, QWORD PTR tv417[rbp]
	mov	rdx, QWORD PTR tv415[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T50[rbp]
	or	eax, 1
	mov	DWORD PTR $T50[rbp], eax
	lea	rcx, QWORD PTR $T45[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T44[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]
	jmp	$LN21@stringify
$LN18@stringify:

; 217  : 			case Type::Number:
; 218  : 				return std::string(indent, ' ') + std::to_string(std::get<double>(m_value));

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$get@NPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEBV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<double,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	vmovsd	xmm1, QWORD PTR [rax]
	lea	rcx, QWORD PTR $T46[rbp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z ; std::to_string
	mov	QWORD PTR tv554[rbp], rax
	mov	rax, QWORD PTR tv554[rbp]
	mov	QWORD PTR tv528[rbp], rax
	mov	rax, QWORD PTR tv528[rbp]
	mov	QWORD PTR tv440[rbp], rax
	mov	r8b, 32					; 00000020H
	mov	rdx, QWORD PTR indent$[rbp]
	lea	rcx, QWORD PTR $T47[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv555[rbp], rax
	mov	rax, QWORD PTR tv555[rbp]
	mov	QWORD PTR tv530[rbp], rax
	mov	rax, QWORD PTR tv530[rbp]
	mov	QWORD PTR tv438[rbp], rax
	mov	r8, QWORD PTR tv440[rbp]
	mov	rdx, QWORD PTR tv438[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T50[rbp]
	or	eax, 1
	mov	DWORD PTR $T50[rbp], eax
	lea	rcx, QWORD PTR $T47[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR $T46[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]
	jmp	$LN21@stringify
$LN19@stringify:

; 219  : 			case Type::Null:
; 220  : 				return std::string(indent, ' ') + "null";

	mov	r8b, 32					; 00000020H
	mov	rdx, QWORD PTR indent$[rbp]
	lea	rcx, QWORD PTR $T48[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv556[rbp], rax
	mov	rax, QWORD PTR tv556[rbp]
	mov	QWORD PTR tv533[rbp], rax
	lea	r8, OFFSET FLAT:??_C@_04MLLLIHIP@null@
	mov	rdx, QWORD PTR tv533[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T50[rbp]
	or	eax, 1
	mov	DWORD PTR $T50[rbp], eax
	lea	rcx, QWORD PTR $T48[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]
	jmp	SHORT $LN21@stringify
$LN20@stringify:

; 221  : 			default:
; 222  : 				throw std::runtime_error("Unknown type");

	lea	rdx, OFFSET FLAT:??_C@_0N@DGOCBNGP@Unknown?5type@
	lea	rcx, QWORD PTR $T49[rbp]
	call	??0runtime_error@std@@QEAA@PEBD@Z	; std::runtime_error::runtime_error
	lea	rdx, OFFSET FLAT:_TI2?AVruntime_error@std@@
	lea	rcx, QWORD PTR $T49[rbp]
	call	_CxxThrowException
	npad	1
$LN21@stringify:

; 223  : 			}
; 224  : 		}

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+3768]
	pop	rdi
	pop	rbp
	ret	0
$LN60@stringify:
$LN59@stringify:
	DD	$LN10@stringify
	DD	$LN16@stringify
	DD	$LN17@stringify
	DD	$LN18@stringify
	DD	$LN11@stringify
	DD	$LN15@stringify
	DD	$LN19@stringify
?stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ENDP ; Json::Value::stringify
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$0@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T18[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$1@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$1
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR result$7[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$1@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$2@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$2
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T19[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$2@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$3@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$3
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T20[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$3@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$4@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$4
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T21[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$4@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$5@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$5
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T22[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$5@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$7@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$7
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T23[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$7@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$8@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$8
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR result$10[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$8@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$9@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$9
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T24[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$9@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$10@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$10
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T25[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$10@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$11@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$11
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T26[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$11@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$12@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$12
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T27[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$12@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$13@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$13
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T28[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$13@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$14@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$14
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T29[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$14@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$15@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$15
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T30[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$15@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$16@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$16
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T31[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$16@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$17@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$17
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T32[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$17@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$18@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$18
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T33[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$18@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$19@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$19
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T34[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$19@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$20@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$20
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T35[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$20@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$21@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$21
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T36[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$21@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$22@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$22
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T37[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$22@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$23@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$23
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T38[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$23@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$24@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$24
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T39[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$24@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$25@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$25
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T40[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$25@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$26@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$26
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T41[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$26@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$27@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$27
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T42[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$27@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$28@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$28
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T43[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$28@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$29@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$29
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T44[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$29@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$29
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$30@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$30
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T45[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$30@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$31@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$31
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T46[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$31@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$31
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$32@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$32
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T47[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$32@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
result$7 = 8
arr$8 = 72
i$9 = 104
result$10 = 136
map$11 = 200
<range>$L0$12 = 232
<begin>$L0$13 = 264
<end>$L0$14 = 296
$S1$15 = 328
key$16 = 360
val$17 = 392
$T18 = 1576
$T19 = 1640
$T20 = 1704
$T21 = 1768
$T22 = 1832
$T23 = 1896
$T24 = 1960
$T25 = 2024
$T26 = 2088
$T27 = 2152
$T28 = 2216
$T29 = 2280
$T30 = 2344
$T31 = 2408
$T32 = 2472
$T33 = 2536
$T34 = 2600
$T35 = 2664
$T36 = 2728
$T37 = 2792
$T38 = 2856
$T39 = 2920
$T40 = 2984
$T41 = 3048
$T42 = 3112
$T43 = 3176
$T44 = 3240
$T45 = 3304
$T46 = 3368
$T47 = 3432
$T48 = 3496
$T49 = 3560
$T50 = 3604
tv65 = 3620
tv396 = 3624
tv349 = 3624
tv385 = 3624
tv554 = 3624
tv373 = 3624
tv129 = 3624
tv552 = 3624
tv154 = 3624
tv546 = 3624
tv539 = 3624
tv556 = 3624
tv442 = 3624
tv533 = 3632
tv548 = 3632
tv551 = 3632
tv66 = 3632
tv479 = 3632
tv460 = 3632
tv467 = 3632
tv476 = 3632
tv493 = 3632
tv507 = 3632
tv523 = 3632
tv528 = 3632
tv463 = 3640
tv379 = 3640
tv547 = 3640
tv513 = 3640
tv417 = 3640
tv520 = 3640
tv243 = 3640
tv324 = 3640
tv440 = 3640
tv549 = 3648
tv346 = 3648
tv469 = 3648
tv540 = 3648
tv419 = 3648
tv509 = 3648
tv553 = 3648
tv555 = 3648
tv465 = 3656
tv481 = 3656
tv525 = 3656
tv495 = 3656
tv530 = 3656
tv515 = 3656
tv415 = 3664
tv438 = 3664
tv371 = 3664
tv541 = 3664
tv151 = 3664
tv483 = 3672
tv497 = 3672
tv550 = 3672
tv535 = 3680
tv542 = 3680
tv517 = 3680
tv499 = 3688
tv485 = 3688
tv536 = 3696
tv543 = 3696
tv501 = 3704
tv487 = 3704
tv241 = 3712
tv322 = 3712
tv537 = 3720
tv544 = 3720
tv503 = 3728
tv489 = 3728
tv538 = 3736
tv545 = 3736
tv491 = 3744
tv505 = 3744
__$ArrayPad$ = 3752
this$ = 3792
__$ReturnUdt$ = 3800
indent$ = 3808
?dtor$33@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA PROC ; `Json::Value::stringify'::`1'::dtor$33
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR $T48[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$33@?0??stringify@Value@Json@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z@4HA ENDP ; `Json::Value::stringify'::`1'::dtor$33
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Value.h
;	COMDAT ??4Value@Json@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 224
other$ = 232
??4Value@Json@@QEAAAEAV01@$$QEAV01@@Z PROC		; Json::Value::operator=, COMDAT

; 159  : 		Value& operator=(Value&& other) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__6DE13511_Value@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 160  : 			if (this != &other) {

	mov	rax, QWORD PTR other$[rbp]
	cmp	QWORD PTR this$[rbp], rax
	je	SHORT $LN2@operator

; 161  : 				this->~Value();

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rbp]
	call	??_GValue@Json@@QEAAPEAXI@Z
	npad	1

; 162  : 				m_type = other.m_type;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR other$[rbp]
	mov	ecx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], ecx

; 163  : 				m_value = std::move(other.m_value);

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR other$[rbp]
	lea	rdi, QWORD PTR [rax+8]
	lea	rsi, QWORD PTR [rcx+8]
	mov	ecx, 16
	rep movsb

; 164  : 				other.m_type = Type::Null;

	mov	rax, QWORD PTR other$[rbp]
	mov	DWORD PTR [rax], 6
$LN2@operator:

; 165  : 			}
; 166  : 			return *this;

	mov	rax, QWORD PTR this$[rbp]

; 167  : 		}

	lea	rsp, QWORD PTR [rbp+192]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??4Value@Json@@QEAAAEAV01@$$QEAV01@@Z ENDP		; Json::Value::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Value.h
;	COMDAT ??1Value@Json@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 200
$T2 = 232
$T3 = 264
tv65 = 276
tv73 = 280
tv81 = 280
tv89 = 280
this$ = 320
??1Value@Json@@QEAA@XZ PROC				; Json::Value::~Value, COMDAT

; 98   : 		~Value() {

$LN16:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__6DE13511_Value@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 99   : 			switch (m_type) {

	mov	rax, QWORD PTR this$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 0
	je	SHORT $LN4@Value
	cmp	DWORD PTR tv65[rbp], 4
	je	SHORT $LN5@Value
	cmp	DWORD PTR tv65[rbp], 5
	je	$LN6@Value
	jmp	$LN2@Value
$LN4@Value:

; 100  : 			case Type::Array:
; 101  : 				delete std::get<std::vector<Value>*>(m_value);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$get@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@PEAV12@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::vector<Json::Value,std::allocator<Json::Value> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T1[rbp], rax
	cmp	QWORD PTR $T1[rbp], 0
	je	SHORT $LN9@Value
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rbp]
	call	??_G?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@QEAAPEAXI@Z
	mov	QWORD PTR tv73[rbp], rax
	jmp	SHORT $LN10@Value
$LN9@Value:
	mov	QWORD PTR tv73[rbp], 0
$LN10@Value:

; 102  : 				break;

	jmp	$LN2@Value
$LN5@Value:

; 103  : 			case Type::Object:
; 104  : 				delete std::get<std::unordered_map<std::string, Value>*>(m_value);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$get@PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV12@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T2[rbp], rax
	cmp	QWORD PTR $T2[rbp], 0
	je	SHORT $LN11@Value
	mov	edx, 1
	mov	rcx, QWORD PTR $T2[rbp]
	call	??_G?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@QEAAPEAXI@Z
	mov	QWORD PTR tv81[rbp], rax
	jmp	SHORT $LN12@Value
$LN11@Value:
	mov	QWORD PTR tv81[rbp], 0
$LN12@Value:

; 105  : 				break;

	jmp	SHORT $LN2@Value
$LN6@Value:

; 106  : 			case Type::String:
; 107  : 				delete std::get<std::string*>(m_value);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$get@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV12@@std@@YA?A_TAEAV?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@0@@Z ; std::get<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR $T3[rbp], rax
	cmp	QWORD PTR $T3[rbp], 0
	je	SHORT $LN13@Value
	mov	edx, 1
	mov	rcx, QWORD PTR $T3[rbp]
	call	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
	mov	QWORD PTR tv89[rbp], rax
	jmp	SHORT $LN2@Value
$LN13@Value:
	mov	QWORD PTR tv89[rbp], 0
$LN2@Value:

; 108  : 				break;
; 109  : 			default:
; 110  : 				break;
; 111  : 			};
; 112  : 		}

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
??1Value@Json@@QEAA@XZ ENDP				; Json::Value::~Value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Value.h
;	COMDAT ??0Value@Json@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0Value@Json@@QEAA@XZ PROC				; Json::Value::Value, COMDAT

; 36   : 		Value() : m_type(Type::Null) {};

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__6DE13511_Value@h
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	DWORD PTR [rax], 6
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??$?0PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@$0A@@?$variant@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEAA@XZ ; std::variant<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::variant<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::vector<Json::Value,std::allocator<Json::Value> > *,0>
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0Value@Json@@QEAA@XZ ENDP				; Json::Value::Value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 224
?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ PROC ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index, COMDAT

; 766  :     _NODISCARD constexpr size_t index() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 767  :         // index of the contained alternative or variant_npos if valueless_by_exception
; 768  :         return static_cast<size_t>(_Which);

	mov	rax, QWORD PTR this$[rbp]
	movsx	rax, BYTE PTR [rax+8]

; 769  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?index@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEBA_KXZ ENDP ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::index
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ PROC ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage, COMDAT

; 738  :     _NODISCARD constexpr const _Storage_t& _Storage() const& noexcept { // access this variant's storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 739  :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 740  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ENDP ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ PROC ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage, COMDAT

; 735  :     _NODISCARD constexpr _Storage_t& _Storage() & noexcept { // access this variant's storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 736  :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 737  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Storage@?$_Variant_base@PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAV?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@2@XZ ENDP ; std::_Variant_base<std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Storage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ PROC ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get, COMDAT

; 361  :     _NODISCARD constexpr const _First& _Get() const& noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 362  :         return _Head;

	mov	rax, QWORD PTR this$[rbp]

; 363  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ ENDP ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ PROC ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get, COMDAT

; 358  :     _NODISCARD constexpr _First& _Get() & noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 359  :         return _Head;

	mov	rax, QWORD PTR this$[rbp]

; 360  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get@?$_Variant_storage_@$00PEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@std@@_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$vector@VValue@Json@@V?$allocator@VValue@Json@@@std@@@2@XZ ENDP ; std::_Variant_storage_<1,std::vector<Json::Value,std::allocator<Json::Value> > *,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$00_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEB_NXZ
_TEXT	SEGMENT
this$ = 224
?_Get@?$_Variant_storage_@$00_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEB_NXZ PROC ; std::_Variant_storage_<1,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get, COMDAT

; 361  :     _NODISCARD constexpr const _First& _Get() const& noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 362  :         return _Head;

	mov	rax, QWORD PTR this$[rbp]

; 363  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get@?$_Variant_storage_@$00_NHNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEB_NXZ ENDP ; std::_Variant_storage_<1,bool,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$00HNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBHXZ
_TEXT	SEGMENT
this$ = 224
?_Get@?$_Variant_storage_@$00HNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBHXZ PROC ; std::_Variant_storage_<1,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get, COMDAT

; 361  :     _NODISCARD constexpr const _First& _Get() const& noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 362  :         return _Head;

	mov	rax, QWORD PTR this$[rbp]

; 363  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get@?$_Variant_storage_@$00HNPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBHXZ ENDP ; std::_Variant_storage_<1,int,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$00NPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBNXZ
_TEXT	SEGMENT
this$ = 224
?_Get@?$_Variant_storage_@$00NPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBNXZ PROC ; std::_Variant_storage_<1,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get, COMDAT

; 361  :     _NODISCARD constexpr const _First& _Get() const& noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 362  :         return _Head;

	mov	rax, QWORD PTR this$[rbp]

; 363  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get@?$_Variant_storage_@$00NPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBNXZ ENDP ; std::_Variant_storage_<1,double,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ PROC ; std::_Variant_storage_<1,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get, COMDAT

; 361  :     _NODISCARD constexpr const _First& _Get() const& noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 362  :         return _Head;

	mov	rax, QWORD PTR this$[rbp]

; 363  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGBAAEBQEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ ENDP ; std::_Variant_storage_<1,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ PROC ; std::_Variant_storage_<1,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get, COMDAT

; 358  :     _NODISCARD constexpr _First& _Get() & noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 359  :         return _Head;

	mov	rax, QWORD PTR this$[rbp]

; 360  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get@?$_Variant_storage_@$00PEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@std@@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@QEGAAAEAPEAV?$unordered_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VValue@Json@@@std@@@2@@2@XZ ENDP ; std::_Variant_storage_<1,std::unordered_map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Json::Value,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Json::Value> > > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGBAAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGBAAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Variant_storage_<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get, COMDAT

; 361  :     _NODISCARD constexpr const _First& _Get() const& noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 362  :         return _Head;

	mov	rax, QWORD PTR this$[rbp]

; 363  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGBAAEBQEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Variant_storage_<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\variant
;	COMDAT ?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGAAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGAAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Variant_storage_<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get, COMDAT

; 358  :     _NODISCARD constexpr _First& _Get() & noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5C102AE6_variant
	call	__CheckForDebuggerJustMyCode
	npad	1

; 359  :         return _Head;

	mov	rax, QWORD PTR this$[rbp]

; 360  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get@?$_Variant_storage_@$00PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QEGAAAEAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Variant_storage_<1,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
_TEXT	SEGMENT
$T1 = 196
__$ReturnUdt$ = 256
_Left$ = 264
_Right$ = 272
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3333 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	DWORD PTR $T1[rbp], 0
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 3334 :     return _STD move(_Left.append(_Right));

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR _Left$[rbp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rbp]
	or	eax, 1
	mov	DWORD PTR $T1[rbp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 3335 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$yd	SEGMENT
??__F?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic atexit destructor for 'Json::Detail::Parser::falseLiteral'', COMDAT
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Detail::Parser::falseLiteral
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??__F?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic atexit destructor for 'Json::Detail::Parser::falseLiteral''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??__E?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$di	SEGMENT
??__E?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic initializer for 'Json::Detail::Parser::falseLiteral'', COMDAT

; 38   : 		static inline const std::string falseLiteral = "false";

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9AC28836_Parser@h
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_05LAPONLG@false@
	lea	rcx, OFFSET FLAT:?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Detail::Parser::falseLiteral
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, OFFSET FLAT:??__F?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Detail::Parser::falseLiteral''
	call	atexit
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??__E?falseLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic initializer for 'Json::Detail::Parser::falseLiteral''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$yd	SEGMENT
??__F?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic atexit destructor for 'Json::Detail::Parser::trueLiteral'', COMDAT
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Detail::Parser::trueLiteral
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??__F?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic atexit destructor for 'Json::Detail::Parser::trueLiteral''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??__E?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$di	SEGMENT
??__E?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic initializer for 'Json::Detail::Parser::trueLiteral'', COMDAT

; 37   : 		static inline const std::string trueLiteral = "true";

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9AC28836_Parser@h
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_04LOAJBDKD@true@
	lea	rcx, OFFSET FLAT:?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Detail::Parser::trueLiteral
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, OFFSET FLAT:??__F?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Detail::Parser::trueLiteral''
	call	atexit
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??__E?trueLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic initializer for 'Json::Detail::Parser::trueLiteral''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$yd	SEGMENT
??__F?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic atexit destructor for 'Json::Detail::Parser::nullLiteral'', COMDAT
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Detail::Parser::nullLiteral
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??__F?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic atexit destructor for 'Json::Detail::Parser::nullLiteral''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\include\JsonParser\Parser.h
;	COMDAT ??__E?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ
text$di	SEGMENT
??__E?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ PROC ; `dynamic initializer for 'Json::Detail::Parser::nullLiteral'', COMDAT

; 36   : 		static inline const std::string nullLiteral = "null";

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9AC28836_Parser@h
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rdx, OFFSET FLAT:??_C@_04MLLLIHIP@null@
	lea	rcx, OFFSET FLAT:?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; Json::Detail::Parser::nullLiteral
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, OFFSET FLAT:??__F?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Detail::Parser::nullLiteral''
	call	atexit
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??__E?nullLiteral@Parser@Detail@Json@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B@@YAXXZ ENDP ; `dynamic initializer for 'Json::Detail::Parser::nullLiteral''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 224
_Ptr$ = 232
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1159 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1160 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1161 :     using _Ty = typename _Alloc::value_type;
; 1162 :     _Ptr->~_Ty();
; 1163 :     _STD _Deallocate_plain(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
	npad	1

; 1164 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 200
_Location$ = 256
<_Args_0>$ = 264
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 508  :     noexcept(noexcept(::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 509  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rbp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR <_Args_0>$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rbp]
	call	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 510  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1532 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__680F61A7_type_traits
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1534 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
_TEXT	SEGMENT
_Ptr$ = 224
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 72   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 73   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rbp]

; 74   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
$T1 = 200
tv65 = 216
_Left$ = 256
_Right$ = 264
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 75   :         noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__DE82222C_utility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rbp]
	mov	rcx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rbp]
	mov	QWORD PTR tv65[rbp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rbp]
	mov	QWORD PTR tv65[rbp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rbp]
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]

; 78   : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 200
_Obj$ = 256
<_Args_0>$ = 264
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 515  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 516  : #if _HAS_CXX20
; 517  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Construct_

; 518  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, rax
	call	??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &>
	npad	1

; 519  :     } else

	jmp	SHORT $LN3@Construct_
$LN2@Construct_:

; 520  : #endif // _HAS_CXX20
; 521  :     {
; 522  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN3@Construct_:

; 523  :     }
; 524  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$construct_at@D$$V@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
$T1 = 200
$T2 = 232
_Location$ = 288
??$construct_at@D$$V@std@@YAPEADQEAD@Z PROC		; std::construct_at<char>, COMDAT

; 508  :     noexcept(noexcept(::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 509  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rbp], 1
	mov	rdx, QWORD PTR _Location$[rbp]
	mov	rcx, QWORD PTR $T1[rbp]
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T2[rbp], rax
	mov	rdi, QWORD PTR $T2[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR $T1[rbp]
	rep stosb
	mov	rax, QWORD PTR $T2[rbp]

; 510  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??$construct_at@D$$V@std@@YAPEADQEAD@Z ENDP		; std::construct_at<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 224
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 72   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 73   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rbp]

; 74   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 224
_Count$ = 232
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2314 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2315 : #if _HAS_CXX23
; 2316 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2317 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2318 :         _Count                  = _Allocated;
; 2319 :         return _Ptr;
; 2320 :     } else
; 2321 : #endif // _HAS_CXX23
; 2322 :     {
; 2323 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2324 :     }
; 2325 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Fancy_ptr$ = 8
_Ptr$1 = 40
_Idx$2 = 72
_Al$ = 320
_Capacity$ = 328
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 873  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 874  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 875  :         ++_Capacity; // Take null terminator into consideration

	mov	rax, QWORD PTR _Capacity$[rbp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Capacity$[rbp]
	mov	QWORD PTR [rcx], rax

; 876  : 
; 877  :         pointer _Fancy_ptr = nullptr;

	mov	QWORD PTR _Fancy_ptr$[rbp], 0

; 878  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 879  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	rdx, QWORD PTR _Capacity$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	QWORD PTR _Fancy_ptr$[rbp], rax

; 880  :         } else {
; 881  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 882  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 883  :         }
; 884  : 
; 885  : #if _HAS_CXX20
; 886  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 887  :         // but likely more impactful to throughput.
; 888  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Allocate_f

; 889  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);

	mov	rcx, QWORD PTR _Fancy_ptr$[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Ptr$1[rbp], rax

; 890  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {

	mov	QWORD PTR _Idx$2[rbp], 0
	jmp	SHORT $LN4@Allocate_f
$LN2@Allocate_f:
	mov	rax, QWORD PTR _Idx$2[rbp]
	inc	rax
	mov	QWORD PTR _Idx$2[rbp], rax
$LN4@Allocate_f:
	mov	rax, QWORD PTR _Capacity$[rbp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Idx$2[rbp], rax
	jae	SHORT $LN3@Allocate_f

; 891  :                 _STD construct_at(_Ptr + _Idx);

	mov	rax, QWORD PTR _Idx$2[rbp]
	mov	rcx, QWORD PTR _Ptr$1[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$construct_at@D$$V@std@@YAPEADQEAD@Z	; std::construct_at<char>
	npad	1

; 892  :             }

	jmp	SHORT $LN2@Allocate_f
$LN3@Allocate_f:
$LN5@Allocate_f:

; 893  :         }
; 894  : #endif // _HAS_CXX20
; 895  :         --_Capacity;

	mov	rax, QWORD PTR _Capacity$[rbp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR _Capacity$[rbp]
	mov	QWORD PTR [rcx], rax

; 896  :         return _Fancy_ptr;

	mov	rax, QWORD PTR _Fancy_ptr$[rbp]

; 897  :     }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 224
_First2$ = 232
_Count$ = 240
??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z PROC ; std::_Traits_copy_batch<std::char_traits<char>,char>, COMDAT

; 532  :     _In_reads_(_Count) const _UElem* const _First2, const size_t _Count) noexcept {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 533  :     _STL_INTERNAL_STATIC_ASSERT(_Is_any_of_v<_UElem, _Traits_ch_t<_Traits>, volatile _Traits_ch_t<_Traits>>);
; 534  : 
; 535  :     if constexpr (is_volatile_v<_UElem>) {
; 536  :         for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 537  :             _Traits::assign(_First1[_Idx], _Traits_ch_t<_Traits>{_First2[_Idx]});
; 538  :         }
; 539  :     } else {
; 540  :         (void) _Traits::copy(_First1, _First2, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _First2$[rbp]
	mov	rcx, QWORD PTR _First1$[rbp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 541  :     }
; 542  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ENDP ; std::_Traits_copy_batch<std::char_traits<char>,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT

; 1507 :     _CONSTEXPR20 ~_Container_proxy_ptr12() {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1508 :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Container_

; 1509 :             _Delete_plain_internal(_Al, _Ptr);

	mov	rax, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	npad	1
$LN2@Container_:

; 1510 :         }
; 1511 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = 200
this$ = 256
_Al_$ = 264
_Mycont$ = 272
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT

; 1493 :     _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rcx, QWORD PTR this$[rbp]
	call	??0_Basic_container_proxy_ptr12@std@@IEAA@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Al_$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 1494 :         // create a new _Container_proxy pointing at _Mycont
; 1495 :         _Ptr = _Unfancy(_Al_.allocate(1));

	mov	edx, 1
	mov	rcx, QWORD PTR _Al_$[rbp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	rcx, rax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rcx], rax

; 1496 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

	mov	rcx, QWORD PTR _Mycont$[rbp]
	call	??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ; std::addressof<std::_Container_base12>
	mov	QWORD PTR $T1[rbp], rax
	lea	rdx, QWORD PTR $T1[rbp]
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	npad	1

; 1497 :         _Mycont._Myproxy = _Ptr;

	mov	rax, QWORD PTR _Mycont$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1498 :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT

; 982  :     constexpr allocator(const allocator<_Other>&) noexcept {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Count$ = 232
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 992  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 993  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 994  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rbp]
	call	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z	; std::_Get_size_of_n<16>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 995  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 986  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 987  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rbp], 0
	jne	SHORT $LN2@deallocate
	cmp	QWORD PTR _Count$[rbp], 0
	je	SHORT $LN2@deallocate
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 987				; 000003dbH
	lea	rdx, OFFSET FLAT:??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN4@deallocate
	int	3
	xor	eax, eax
$LN4@deallocate:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@deallocate:

; 988  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rbp], 16
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 990  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 224
_Al$ = 232
??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z PROC ; std::_Get_proxy_allocator<std::allocator<char> >, COMDAT

; 1525 :     noexcept(noexcept(static_cast<_Rebind_alloc_t<_Alloc, _Container_proxy>>(_Al))) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1526 :     return static_cast<_Rebind_alloc_t<_Alloc, _Container_proxy>>(_Al);

	mov	rdx, QWORD PTR _Al$[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	npad	1
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 1527 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ENDP ; std::_Get_proxy_allocator<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 8
_Al$ = 40
_Alproxy$ = 68
_Proxy$ = 104
_New_capacity$ = 152
_New_ptr$ = 184
$T7 = 404
$T8 = 436
__$ArrayPad$ = 456
this$ = 496
_Arg$ = 504
_Count$ = 512
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 921  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 504				; 000001f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+536]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 922  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 923  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 924  : 
; 925  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 926  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 927  :         } else {
; 928  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cvptr<_Char_or_ptr>::value);
; 929  :         }
; 930  : 
; 931  :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rbp], rax
	jbe	SHORT $LN2@Construct

; 932  :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Construct:

; 933  :         }
; 934  : 
; 935  :         auto& _Al     = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rbp], rax

; 936  :         auto _Alproxy = _STD _Get_proxy_allocator(_Al);

	mov	rdx, QWORD PTR _Al$[rbp]
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
	npad	1

; 937  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rbp]
	lea	rdx, QWORD PTR _Alproxy$[rbp]
	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1

; 938  : 
; 939  :         if (_Count <= _Small_string_capacity) {

	cmp	QWORD PTR _Count$[rbp], 15
	ja	SHORT $LN3@Construct

; 940  :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 941  :             _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	QWORD PTR [rax+32], 15

; 942  : 
; 943  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 944  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 945  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 946  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 947  :                 _STD _Traits_copy_batch<_Traits>(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Arg$[rbp]
	mov	rcx, rax
	call	??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ; std::_Traits_copy_batch<std::char_traits<char>,char>
	npad	1

; 948  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T7[rbp], 0
	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	lea	rax, QWORD PTR [rax+rcx+8]
	lea	rdx, QWORD PTR $T7[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 949  :             } else { // _Strat == _Construct_strategy::_From_string
; 950  : #ifdef _INSERT_STRING_ANNOTATION
; 951  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 952  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 953  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 954  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 955  :             }
; 956  : 
; 957  :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 958  :             return;

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
	jmp	$LN4@Construct
$LN3@Construct:

; 959  :         }
; 960  : 
; 961  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	edx, 15
	mov	rcx, QWORD PTR _Count$[rbp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rbp], rax

; 962  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rbp], rax

; 963  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	lea	rdx, QWORD PTR _New_ptr$[rbp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1

; 964  : 
; 965  :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Count$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 966  :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_capacity$[rbp]
	mov	QWORD PTR [rax+32], rcx

; 967  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 968  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 969  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 970  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 971  :             _STD _Traits_copy_batch<_Traits>(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Arg$[rbp]
	mov	rcx, rax
	call	??$_Traits_copy_batch@U?$char_traits@D@std@@D@std@@YAXQEADQEBD_K@Z ; std::_Traits_copy_batch<std::char_traits<char>,char>
	npad	1

; 972  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T8[rbp], 0
	mov	rcx, QWORD PTR _New_ptr$[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rbp]
	lea	rdx, QWORD PTR $T8[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 973  :         } else { // _Strat == _Construct_strategy::_From_string
; 974  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 975  :         }
; 976  : 
; 977  :         _ASAN_STRING_CREATE(*this);
; 978  :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 979  :     }

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN4@Construct:
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+472]
	pop	rdi
	pop	rbp
	ret	0
$LN6@Construct:
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 8
_Al$ = 40
_Alproxy$ = 68
_Proxy$ = 104
_New_capacity$ = 152
_New_ptr$ = 184
$T7 = 404
$T8 = 436
__$ArrayPad$ = 456
this$ = 496
_Arg$ = 504
_Count$ = 512
?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 224
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1132 :     noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1133 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1134 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1135 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1136 : 
; 1137 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1138 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1139 :             _Xlength_error("size is too long for _Size_type");
; 1140 :         }
; 1141 :     }
; 1142 : 
; 1143 :     return static_cast<_Size_type>(_Len);

	mov	rax, QWORD PTR _Len$[rbp]

; 1144 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1551 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rcx, QWORD PTR this$[rbp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 8
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 863  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN4:
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__DE82222C_utility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 864  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 865  :     if constexpr (is_signed_v<_Ty>) {
; 866  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rbp], -1

; 867  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 868  :     } else {
; 869  :         return static_cast<_Ty>(-1);
; 870  :     }
; 871  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
_TEXT	SEGMENT
_First$ = 224
_Last$ = 232
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1418 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1419 :     // check that [_First, _Last) forms an iterator range
; 1420 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1421 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1422 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");

	mov	rax, QWORD PTR _First$[rbp]
	mov	rcx, QWORD PTR _Last$[rbp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jbe	SHORT $LN2@Adl_verify
	lea	rax, OFFSET FLAT:??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 1422				; 0000058eH
	lea	rdx, OFFSET FLAT:??_C@_0GB@HOPEEJK@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN4@Adl_verify
	int	3
	xor	eax, eax
$LN4@Adl_verify:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@Adl_verify:
$LN3@Adl_verify:

; 1423 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1424 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1425 :         _Verify_range(_First, _Last);
; 1426 :     }
; 1427 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gruntime_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gruntime_error@std@@UEAAPEAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1runtime_error@std@@UEAA@XZ
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gruntime_error@std@@UEAAPEAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0runtime_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
__that$ = 232
??0runtime_error@std@@QEAA@AEBV01@@Z PROC		; std::runtime_error::runtime_error, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdx, QWORD PTR __that$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0runtime_error@std@@QEAA@AEBV01@@Z ENDP		; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1runtime_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1runtime_error@std@@UEAA@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1runtime_error@std@@UEAA@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\stdexcept
;	COMDAT ??0runtime_error@std@@QEAA@PEBD@Z
_TEXT	SEGMENT
this$ = 224
_Message$ = 232
??0runtime_error@std@@QEAA@PEBD@Z PROC			; std::runtime_error::runtime_error, COMDAT

; 106  :     explicit runtime_error(const char* _Message) : _Mybase(_Message) {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__24B6FA99_stdexcept
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rdx, QWORD PTR _Message$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0exception@std@@QEAA@QEBD@Z		; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0runtime_error@std@@QEAA@PEBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z
_TEXT	SEGMENT
_Len$ = 8
$T5 = 324
tv69 = 344
tv76 = 344
__$ReturnUdt$ = 384
_Val$ = 392
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z PROC ; std::to_string, COMDAT

; 487  : _EXPORT_STD _NODISCARD inline string to_string(double _Val) {

$LN5:
	vmovsd	QWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 42					; 0000002aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	mov	DWORD PTR $T5[rbp], 0
	lea	rcx, OFFSET FLAT:__A5C9CFE5_string
	call	__CheckForDebuggerJustMyCode
	npad	1

; 488  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	vmovsd	xmm1, QWORD PTR _Val$[rbp]
	vmovq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	cdqe
	mov	QWORD PTR _Len$[rbp], rax

; 489  :     string _Str(_Len, '\0');

	xor	r8d, r8d
	mov	rdx, QWORD PTR _Len$[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv69[rbp], rax
	mov	eax, DWORD PTR $T5[rbp]
	or	eax, 1
	mov	DWORD PTR $T5[rbp], eax

; 490  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	mov	rax, QWORD PTR _Len$[rbp]
	inc	rax
	mov	QWORD PTR tv76[rbp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	vmovsd	xmm3, QWORD PTR _Val$[rbp]
	vmovq	r9, xmm3
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	mov	rcx, QWORD PTR tv76[rbp]
	mov	rdx, rcx
	mov	rcx, rax
	call	sprintf_s
	npad	1

; 491  :     return _Str;

	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 492  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@N@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\string
;	COMDAT ??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
_TEXT	SEGMENT
_Buff$ = 8
_Buff_end$ = 56
_RNext$ = 88
_UVal$4 = 116
$T5 = 340
$T6 = 372
__$ArrayPad$ = 392
__$ReturnUdt$ = 432
_Val$ = 440
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z PROC ; std::_Integral_to_string<char,int>, COMDAT

; 441  : _NODISCARD basic_string<_Elem> _Integral_to_string(const _Ty _Val) {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 440				; 000001b8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+472]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	mov	DWORD PTR $T6[rbp], 0
	lea	rcx, OFFSET FLAT:__A5C9CFE5_string
	call	__CheckForDebuggerJustMyCode
	npad	1

; 442  :     // convert _Val to string
; 443  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 444  :     _Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 445  :     _Elem* const _Buff_end = _STD end(_Buff);

	lea	rcx, QWORD PTR _Buff$[rbp]
	call	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z	; std::end<char,21>
	mov	QWORD PTR _Buff_end$[rbp], rax

; 446  :     _Elem* _RNext          = _Buff_end;

	mov	rax, QWORD PTR _Buff_end$[rbp]
	mov	QWORD PTR _RNext$[rbp], rax

; 447  : 
; 448  :     if constexpr (is_signed_v<_Ty>) {
; 449  :         const auto _UVal = static_cast<make_unsigned_t<_Ty>>(_Val);

	mov	eax, DWORD PTR _Val$[rbp]
	mov	DWORD PTR _UVal$4[rbp], eax

; 450  :         if (_Val < 0) {

	cmp	DWORD PTR _Val$[rbp], 0
	jge	SHORT $LN2@Integral_t

; 451  :             _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);

	xor	eax, eax
	sub	eax, DWORD PTR _UVal$4[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR _RNext$[rbp]
	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
	mov	QWORD PTR _RNext$[rbp], rax

; 452  :             *--_RNext = '-';

	mov	rax, QWORD PTR _RNext$[rbp]
	dec	rax
	mov	QWORD PTR _RNext$[rbp], rax
	mov	rax, QWORD PTR _RNext$[rbp]
	mov	BYTE PTR [rax], 45			; 0000002dH

; 453  :         } else {

	jmp	SHORT $LN3@Integral_t
$LN2@Integral_t:

; 454  :             _RNext = _UIntegral_to_buff(_RNext, _UVal);

	mov	edx, DWORD PTR _UVal$4[rbp]
	mov	rcx, QWORD PTR _RNext$[rbp]
	call	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ; std::_UIntegral_to_buff<char,unsigned int>
	mov	QWORD PTR _RNext$[rbp], rax
$LN3@Integral_t:

; 455  :         }
; 456  :     } else {
; 457  :         _RNext = _UIntegral_to_buff(_RNext, _Val);
; 458  :     }
; 459  : 
; 460  :     return basic_string<_Elem>(_RNext, _Buff_end);

	lea	rcx, QWORD PTR $T5[rbp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	r9, rax
	mov	r8, QWORD PTR _Buff_end$[rbp]
	mov	rdx, QWORD PTR _RNext$[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
	mov	eax, DWORD PTR $T6[rbp]
	or	eax, 1
	mov	DWORD PTR $T6[rbp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 461  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+408]
	pop	rdi
	pop	rbp
	ret	0
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ENDP ; std::_Integral_to_string<char,int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
$T1 = 196
__$ReturnUdt$ = 256
_Val$ = 264
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::to_string, COMDAT

; 463  : _EXPORT_STD _NODISCARD inline string to_string(int _Val) {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	DWORD PTR $T1[rbp], 0
	lea	rcx, OFFSET FLAT:__A5C9CFE5_string
	call	__CheckForDebuggerJustMyCode
	npad	1

; 464  :     return _Integral_to_string<char>(_Val);

	mov	edx, DWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
	mov	eax, DWORD PTR $T1[rbp]
	or	eax, 1
	mov	DWORD PTR $T1[rbp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rbp]

; 465  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1562 :     constexpr const _Ty1& _Get_first() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1563 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1564 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1558 :     constexpr _Ty1& _Get_first() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1559 :         return *this;

	mov	rax, QWORD PTR this$[rbp]

; 1560 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3196 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 3197 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3198 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 224
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3192 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 3193 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3194 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
tv79 = 192
this$ = 240
_Right$ = 248
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 3188 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 3189 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv79[rbp], rax
	mov	rax, QWORD PTR _Right$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv79[rbp]
	call	?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
	npad	1

; 3190 :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 8
_Al$1 = 40
$T2 = 260
this$ = 320
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3166 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 3167 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 3168 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 3169 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3170 :             _ASAN_STRING_REMOVE(*this);
; 3171 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$1[rbp], rax

; 3172 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	r8, QWORD PTR [rax+32]
	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Al$1[rbp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
	npad	1

; 3173 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3174 :         }
; 3175 : 
; 3176 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	QWORD PTR [rax+24], 0

; 3177 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	QWORD PTR [rax+32], 15

; 3178 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3179 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[rbp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rbp]
	lea	rax, QWORD PTR [rcx+rax+8]
	lea	rdx, QWORD PTR $T2[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3180 :     }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 192
tv74 = 200
this$ = 240
_Requested$ = 248
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2897 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2898 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	QWORD PTR tv76[rbp], rax
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv74[rbp], rax
	mov	r8, QWORD PTR tv76[rbp]
	mov	rdx, QWORD PTR tv74[rbp]
	mov	rcx, QWORD PTR _Requested$[rbp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 2899 :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 8
$T4 = 232
__$ArrayPad$ = 248
_Requested$ = 288
_Old$ = 296
_Max$ = 304
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2884 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2885 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, QWORD PTR _Requested$[rbp]
	or	rax, 15
	mov	QWORD PTR _Masked$[rbp], rax

; 2886 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rbp]
	cmp	QWORD PTR _Masked$[rbp], rax
	jbe	SHORT $LN2@Calculate_

; 2887 :             return _Max;

	mov	rax, QWORD PTR _Max$[rbp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2888 :         }
; 2889 : 
; 2890 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rbp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rbp], rax
	jbe	SHORT $LN3@Calculate_

; 2891 :             return _Max;

	mov	rax, QWORD PTR _Max$[rbp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2892 :         }
; 2893 : 
; 2894 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rbp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T4[rbp], rax
	lea	rdx, QWORD PTR $T4[rbp]
	lea	rcx, QWORD PTR _Masked$[rbp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 2895 :     }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
_Alloc_max$ = 8
_Storage_max$ = 40
$T4 = 264
$T5 = 296
$T6 = 328
__$ArrayPad$ = 344
this$ = 384
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2284 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 42					; 0000002aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2285 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR _Alloc_max$[rbp], rax

; 2286 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T4[rbp], 16
	lea	rdx, QWORD PTR $T4[rbp]
	lea	rcx, QWORD PTR _Alloc_max$[rbp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rbp], rax

; 2287 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2288 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	QWORD PTR $T5[rbp], -2
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T6[rbp], rax
	lea	rdx, QWORD PTR $T5[rbp]
	lea	rcx, QWORD PTR $T6[rbp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 2289 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2290 :         );
; 2291 :     }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 224
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 2280 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2281 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+24]

; 2282 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 224
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 2266 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2267 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2268 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
this$ = 224
_Off$ = 232
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 2174 :     _NODISCARD _CONSTEXPR20 reference operator[](const size_type _Off) noexcept /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2175 : #if _MSVC_STL_HARDENING_BASIC_STRING || _ITERATOR_DEBUG_LEVEL != 0
; 2176 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR _Off$[rbp], rax
	jbe	SHORT $LN2@operator
	lea	rax, OFFSET FLAT:??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 2176				; 00000880H
	lea	rdx, OFFSET FLAT:??_C@_0GA@IMMHHOBA@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN4@operator
	int	3
	xor	eax, eax
$LN4@operator:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@operator:

; 2177 : #endif
; 2178 : 
; 2179 :         return _Mypair._Myval2._Myptr()[_Off];

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _Off$[rbp]

; 2180 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1565 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1566 :         return _Append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>

; 1567 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
tv78 = 192
tv76 = 200
this$ = 240
_Right$ = 248
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1532 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1533 :         return _Append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rbp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv78[rbp], rax
	mov	rax, QWORD PTR _Right$[rbp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv76[rbp], rax
	mov	r8, QWORD PTR tv78[rbp]
	mov	rdx, QWORD PTR tv76[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Append@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Append<char>

; 1534 :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
_Right$ = 232
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 1512 :     _CONSTEXPR20 basic_string& operator+=(const basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1513 :         return append(_Right);

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1514 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
_Alproxy$ = 4
_To_delete$ = 40
__$ArrayPad$ = 248
this$ = 288
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1432 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1433 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 1434 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1435 :         auto _Alproxy            = _STD _Get_proxy_allocator(_Getal());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
	npad	1

; 1436 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _To_delete$[rbp], rax

; 1437 :         _Mypair._Myval2._Myproxy = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax], 0

; 1438 :         _Delete_plain_internal(_Alproxy, _To_delete);

	mov	rdx, QWORD PTR _To_delete$[rbp]
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	npad	1

; 1439 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1440 :     }

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
_My_data$ = 8
_Right_data$ = 40
_My_data_mem$1 = 72
_Right_data_mem$2 = 104
$T3 = 324
$T4 = 356
tv164 = 376
this$ = 416
_Right$ = 424
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 1308 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1309 :         // assign by stealing _Right's buffer
; 1310 :         // pre: this != &_Right
; 1311 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1312 :         // pre: *this owns no memory, iterators orphaned
; 1313 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1314 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 1315 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rbp]
	mov	QWORD PTR _Right_data$[rbp], rax

; 1316 : 
; 1317 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1318 :         if constexpr (_Can_memcpy_val) {
; 1319 : #if _HAS_CXX20
; 1320 :             if (!_STD is_constant_evaluated())

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	jne	$LN2@Take_conte

; 1321 : #endif // _HAS_CXX20
; 1322 :             {
; 1323 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1324 :                 if (_Right_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _Right_data$[rbp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Take_conte

; 1325 :                     // take ownership of _Right's iterators along with its buffer
; 1326 :                     _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
	npad	1

; 1327 :                 } else {

	jmp	SHORT $LN4@Take_conte
$LN3@Take_conte:

; 1328 :                     _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
	npad	1
$LN4@Take_conte:

; 1329 :                 }
; 1330 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1331 : 
; 1332 :                 const auto _My_data_mem =

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	rax, 8
	mov	QWORD PTR _My_data_mem$1[rbp], rax

; 1333 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1334 :                 const auto _Right_data_mem =

	mov	rax, QWORD PTR _Right$[rbp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	rax, 8
	mov	QWORD PTR _Right_data_mem$2[rbp], rax

; 1335 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1336 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR _Right_data_mem$2[rbp]
	mov	rcx, QWORD PTR _My_data_mem$1[rbp]
	call	memcpy
	npad	1

; 1337 : 
; 1338 :                 _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rbp]
	mov	QWORD PTR [rax+24], 0

; 1339 :                 _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rbp]
	mov	QWORD PTR [rax+32], 15

; 1340 :                 _Right_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _Right_data$[rbp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 1341 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T3[rbp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rbp]
	lea	rax, QWORD PTR [rcx+rax+8]
	lea	rdx, QWORD PTR $T3[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 1342 :                 return;

	jmp	$LN1@Take_conte
$LN2@Take_conte:

; 1343 :             }
; 1344 :         }
; 1345 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1346 : 
; 1347 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

	mov	rcx, QWORD PTR _Right_data$[rbp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Take_conte

; 1348 :             _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
	npad	1

; 1349 : 
; 1350 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	rax, QWORD PTR _Right_data$[rbp]
	add	rax, 8
	mov	rcx, QWORD PTR _My_data$[rbp]
	add	rcx, 8
	mov	rdx, rax
	call	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
	npad	1

; 1351 :             _Right_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _Right_data$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1

; 1352 :         } else { // copy small string buffer

	jmp	SHORT $LN6@Take_conte
$LN5@Take_conte:

; 1353 :             _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 1354 : 
; 1355 :             _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 1356 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	rax, QWORD PTR _Right_data$[rbp]
	mov	rax, QWORD PTR [rax+24]
	inc	rax
	mov	rcx, QWORD PTR _Right_data$[rbp]
	add	rcx, 8
	mov	rdx, QWORD PTR _My_data$[rbp]
	add	rdx, 8
	mov	QWORD PTR tv164[rbp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv164[rbp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1
$LN6@Take_conte:

; 1357 :         }
; 1358 : 
; 1359 :         _My_data._Myres  = _Right_data._Myres;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Right_data$[rbp]
	mov	rcx, QWORD PTR [rcx+32]
	mov	QWORD PTR [rax+32], rcx

; 1360 :         _My_data._Mysize = _Right_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _Right_data$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 1361 : 
; 1362 :         _Right_data._Mysize = 0;

	mov	rax, QWORD PTR _Right_data$[rbp]
	mov	QWORD PTR [rax+24], 0

; 1363 :         _Right_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _Right_data$[rbp]
	mov	QWORD PTR [rax+32], 15

; 1364 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T4[rbp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Right_data$[rbp]
	lea	rax, QWORD PTR [rcx+rax+8]
	lea	rdx, QWORD PTR $T4[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1
$LN1@Take_conte:

; 1365 :     }

	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z
_TEXT	SEGMENT
_My_data$ = 8
_Left_data$ = 40
_Right_data$ = 72
_Left_size$ = 104
_Right_size$ = 136
_Left_capacity$ = 168
_Right_capacity$ = 200
_New_size$ = 232
_Fits_in_left$ = 260
_Ptr$7 = 296
_Fits_in_right$ = 324
_Ptr$8 = 360
_Max$ = 392
_New_capacity$ = 424
_Alproxy$ = 452
_Proxy$ = 488
_Fancyptr$ = 536
_Ptr$ = 568
$T9 = 980
$T10 = 1012
$T11 = 1044
$T12 = 1076
tv133 = 1092
tv162 = 1092
tv246 = 1096
tv153 = 1096
tv75 = 1096
tv173 = 1096
tv171 = 1104
tv73 = 1104
__$ArrayPad$ = 1112
this$ = 1152
__formal$ = 1160
_Left$ = 1168
_Right$ = 1176
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1130 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

$LN13:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 1160				; 00000488H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 186				; 000000baH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+1192]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv75[rbp], rax
	mov	rcx, QWORD PTR _Left$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR tv73[rbp], rax
	movzx	eax, BYTE PTR $T9[rbp]
	mov	BYTE PTR $T10[rbp], al
	mov	r8, QWORD PTR tv73[rbp]
	movzx	edx, BYTE PTR $T10[rbp]
	mov	rcx, QWORD PTR tv75[rbp]
	call	??$?0AEAV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> &>
	npad	1

; 1131 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 1132 :         auto& _Left_data  = _Left._Mypair._Myval2;

	mov	rax, QWORD PTR _Left$[rbp]
	mov	QWORD PTR _Left_data$[rbp], rax

; 1133 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rbp]
	mov	QWORD PTR _Right_data$[rbp], rax

; 1134 :         _Left_data._Orphan_all();

	mov	rcx, QWORD PTR _Left_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 1135 :         _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rbp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 1136 :         const auto _Left_size  = _Left_data._Mysize;

	mov	rax, QWORD PTR _Left_data$[rbp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Left_size$[rbp], rax

; 1137 :         const auto _Right_size = _Right_data._Mysize;

	mov	rax, QWORD PTR _Right_data$[rbp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Right_size$[rbp], rax

; 1138 : 
; 1139 :         const auto _Left_capacity  = _Left_data._Myres;

	mov	rax, QWORD PTR _Left_data$[rbp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR _Left_capacity$[rbp], rax

; 1140 :         const auto _Right_capacity = _Right_data._Myres;

	mov	rax, QWORD PTR _Right_data$[rbp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR _Right_capacity$[rbp], rax

; 1141 :         // overflow is OK due to max_size() checks:
; 1142 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);

	mov	rax, QWORD PTR _Right_size$[rbp]
	mov	rcx, QWORD PTR _Left_size$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rbp], rax

; 1143 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;

	mov	rax, QWORD PTR _Left_size$[rbp]
	mov	rcx, QWORD PTR _Left_capacity$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Right_size$[rbp], rax
	ja	SHORT $LN6@basic_stri
	mov	BYTE PTR tv133[rbp], 1
	jmp	SHORT $LN7@basic_stri
$LN6@basic_stri:
	mov	BYTE PTR tv133[rbp], 0
$LN7@basic_stri:
	movzx	eax, BYTE PTR tv133[rbp]
	mov	BYTE PTR _Fits_in_left$[rbp], al

; 1144 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {

	movzx	eax, BYTE PTR _Fits_in_left$[rbp]
	test	eax, eax
	je	$LN2@basic_stri
	mov	rax, QWORD PTR _Left_capacity$[rbp]
	cmp	QWORD PTR _Right_capacity$[rbp], rax
	ja	$LN2@basic_stri

; 1145 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 1146 :             _My_data._Alloc_proxy(_STD _Get_proxy_allocator(_Getal())); // throws, hereafter nothrow in this block

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T11[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _My_data$[rbp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 1147 :             _Take_contents(_Left);

	mov	rdx, QWORD PTR _Left$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 1148 :             const auto _Ptr = _My_data._Myptr();

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Ptr$7[rbp], rax

; 1149 :             _ASAN_STRING_MODIFY(*this, _Left_size, _New_size);
; 1150 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

	mov	rax, QWORD PTR _Right_size$[rbp]
	inc	rax
	mov	QWORD PTR tv153[rbp], rax
	mov	rcx, QWORD PTR _Right_data$[rbp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, QWORD PTR _Left_size$[rbp]
	mov	rdx, QWORD PTR _Ptr$7[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, QWORD PTR tv153[rbp]
	mov	r8, rdx
	mov	rdx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1151 :             _My_data._Mysize = _New_size;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_size$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 1152 :             return;

	jmp	$LN1@basic_stri
$LN2@basic_stri:

; 1153 :         }
; 1154 : 
; 1155 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;

	mov	rax, QWORD PTR _Right_size$[rbp]
	mov	rcx, QWORD PTR _Right_capacity$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Left_size$[rbp], rax
	ja	SHORT $LN8@basic_stri
	mov	BYTE PTR tv162[rbp], 1
	jmp	SHORT $LN9@basic_stri
$LN8@basic_stri:
	mov	BYTE PTR tv162[rbp], 0
$LN9@basic_stri:
	movzx	eax, BYTE PTR tv162[rbp]
	mov	BYTE PTR _Fits_in_right$[rbp], al

; 1156 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {

	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR tv173[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR tv171[rbp], rax
	mov	rdx, QWORD PTR tv173[rbp]
	mov	rcx, QWORD PTR tv171[rbp]
	call	??$_Allocators_equal@V?$allocator@D@std@@@std@@YA_NAEBV?$allocator@D@0@0@Z ; std::_Allocators_equal<std::allocator<char> >
	movzx	eax, al
	test	eax, eax
	je	$LN3@basic_stri
	movzx	eax, BYTE PTR _Fits_in_right$[rbp]
	test	eax, eax
	je	$LN3@basic_stri

; 1157 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 1158 :             // At this point, we have tested:
; 1159 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 1160 :             // therefore: (by De Morgan's Laws)
; 1161 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 1162 :             // therefore: (by the distributive property)
; 1163 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 1164 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 1165 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_mode_engaged()
; 1166 :             _STL_INTERNAL_CHECK(_Right_data._Large_mode_engaged());
; 1167 :             _My_data._Alloc_proxy(_STD _Get_proxy_allocator(_Getal())); // throws, hereafter nothrow in this block

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T12[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _My_data$[rbp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 1168 :             _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 1169 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Ptr$8[rbp], rax

; 1170 :             _ASAN_STRING_MODIFY(*this, _Right_size, _New_size);
; 1171 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);

	mov	rax, QWORD PTR _Right_size$[rbp]
	inc	rax
	mov	rcx, QWORD PTR _Left_size$[rbp]
	mov	rdx, QWORD PTR _Ptr$8[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$8[rbp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move
	npad	1

; 1172 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);

	mov	rcx, QWORD PTR _Left_data$[rbp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	r8, QWORD PTR _Left_size$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$8[rbp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1173 :             _My_data._Mysize = _New_size;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_size$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 1174 :             return;

	jmp	$LN1@basic_stri
$LN3@basic_stri:

; 1175 :         }
; 1176 : 
; 1177 :         // can't use either buffer, reallocate
; 1178 :         const auto _Max = max_size();

	mov	rcx, QWORD PTR this$[rbp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	QWORD PTR _Max$[rbp], rax

; 1179 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	sub	rax, QWORD PTR _Left_size$[rbp]
	cmp	rax, QWORD PTR _Right_size$[rbp]
	jae	SHORT $LN4@basic_stri

; 1180 :             _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN4@basic_stri:

; 1181 :         }
; 1182 : 
; 1183 :         size_type _New_capacity = _Calculate_growth(_New_size, _Small_string_capacity, _Max);

	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	mov	edx, 15
	mov	rcx, QWORD PTR _New_size$[rbp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rbp], rax

; 1184 :         auto _Alproxy           = _STD _Get_proxy_allocator(_Getal());

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR _Alproxy$[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
	npad	1

; 1185 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws

	mov	r8, QWORD PTR _My_data$[rbp]
	lea	rdx, QWORD PTR _Alproxy$[rbp]
	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAV?$allocator@U_Container_proxy@std@@@1@AEAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1

; 1186 :         const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); // throws

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	lea	rdx, QWORD PTR _New_capacity$[rbp]
	mov	rcx, rax
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _Fancyptr$[rbp], rax

; 1187 :         // nothrow hereafter
; 1188 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

	mov	rax, QWORD PTR _My_data$[rbp]
	add	rax, 8
	lea	rdx, QWORD PTR _Fancyptr$[rbp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1

; 1189 :         _My_data._Mysize = _New_size;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_size$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 1190 :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	rcx, QWORD PTR _New_capacity$[rbp]
	mov	QWORD PTR [rax+32], rcx

; 1191 :         const auto _Ptr  = _Unfancy(_Fancyptr);

	mov	rcx, QWORD PTR _Fancyptr$[rbp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Ptr$[rbp], rax

; 1192 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);

	mov	rcx, QWORD PTR _Left_data$[rbp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	r8, QWORD PTR _Left_size$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1193 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

	mov	rax, QWORD PTR _Right_size$[rbp]
	inc	rax
	mov	QWORD PTR tv246[rbp], rax
	mov	rcx, QWORD PTR _Right_data$[rbp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, QWORD PTR _Left_size$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, QWORD PTR tv246[rbp]
	mov	r8, rdx
	mov	rdx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1

; 1194 :         _ASAN_STRING_CREATE(*this);
; 1195 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ; std::_Basic_container_proxy_ptr12::_Release
	npad	1

; 1196 :     }

	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	npad	1
$LN1@basic_stri:
	mov	rax, QWORD PTR this$[rbp]
	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+1128]
	pop	rdi
	pop	rbp
	ret	0
$LN12@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 8
_Left_data$ = 40
_Right_data$ = 72
_Left_size$ = 104
_Right_size$ = 136
_Left_capacity$ = 168
_Right_capacity$ = 200
_New_size$ = 232
_Fits_in_left$ = 260
_Ptr$7 = 296
_Fits_in_right$ = 324
_Ptr$8 = 360
_Max$ = 392
_New_capacity$ = 424
_Alproxy$ = 452
_Proxy$ = 488
_Fancyptr$ = 536
_Ptr$ = 568
$T9 = 980
$T10 = 1012
$T11 = 1044
$T12 = 1076
tv133 = 1092
tv162 = 1092
tv246 = 1096
tv153 = 1096
tv75 = 1096
tv173 = 1096
tv171 = 1104
tv73 = 1104
__$ArrayPad$ = 1112
this$ = 1152
__formal$ = 1160
_Left$ = 1168
_Right$ = 1176
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
_My_data$ = 8
_Left_data$ = 40
_Right_data$ = 72
_Left_size$ = 104
_Right_size$ = 136
_Left_capacity$ = 168
_Right_capacity$ = 200
_New_size$ = 232
_Fits_in_left$ = 260
_Ptr$7 = 296
_Fits_in_right$ = 324
_Ptr$8 = 360
_Max$ = 392
_New_capacity$ = 424
_Alproxy$ = 452
_Proxy$ = 488
_Fancyptr$ = 536
_Ptr$ = 568
$T9 = 980
$T10 = 1012
$T11 = 1044
$T12 = 1076
tv133 = 1092
tv162 = 1092
tv246 = 1096
tv153 = 1096
tv75 = 1096
tv173 = 1096
tv171 = 1104
tv73 = 1104
__$ArrayPad$ = 1112
this$ = 1152
__formal$ = 1160
_Left$ = 1168
_Right$ = 1176
?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	lea	rcx, QWORD PTR _Proxy$[rbp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 196
$T2 = 228
$T3 = 260
tv75 = 280
tv92 = 280
tv73 = 288
this$ = 336
_Right$ = 344
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1078 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 344				; 00000158H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv75[rbp], rax
	mov	rcx, QWORD PTR _Right$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR tv73[rbp], rax
	movzx	eax, BYTE PTR $T1[rbp]
	mov	BYTE PTR $T2[rbp], al
	mov	r8, QWORD PTR tv73[rbp]
	movzx	edx, BYTE PTR $T2[rbp]
	mov	rcx, QWORD PTR tv75[rbp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 1079 :         _Mypair._Myval2._Alloc_proxy(_STD _Get_proxy_allocator(_Getal()));

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv92[rbp], rax
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T3[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
	mov	rdx, rax
	mov	rcx, QWORD PTR tv92[rbp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 1080 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
	npad	1

; 1081 :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+312]
	pop	rdi
	pop	rbp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
_My_data$ = 8
$T1 = 228
$T2 = 260
this$ = 320
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 905  :     _CONSTEXPR20 void _Construct_empty() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 906  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR _My_data$[rbp], rax

; 907  :         _My_data._Alloc_proxy(_STD _Get_proxy_allocator(_Getal()));

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rbp]
	call	??$_Get_proxy_allocator@V?$allocator@D@std@@@std@@YA?AV?$allocator@U_Container_proxy@std@@@0@AEBV?$allocator@D@0@@Z ; std::_Get_proxy_allocator<std::allocator<char> >
	mov	rdx, rax
	mov	rcx, QWORD PTR _My_data$[rbp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 908  : 
; 909  :         // initialize basic_string data members
; 910  :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	QWORD PTR [rax+24], 0

; 911  :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rbp]
	mov	QWORD PTR [rax+32], 15

; 912  :         _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rbp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 913  : 
; 914  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 915  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[rbp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rbp]
	lea	rax, QWORD PTR [rcx+rax+8]
	lea	rdx, QWORD PTR $T2[rbp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 916  :     }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 224
_Old_ptr$ = 232
_Capacity$ = 240
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 900  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 901  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 902  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rbp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 903  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
_TEXT	SEGMENT
$T1 = 196
tv69 = 216
this$ = 256
_Count$ = 264
_Ch$ = 272
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 835  :         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch

$LN4:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv69[rbp], rax
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR tv69[rbp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 836  :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	movzx	edx, BYTE PTR _Ch$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
	npad	1

; 837  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 196
tv69 = 216
this$ = 256
_Count$ = 264
_Ch$ = 272
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 196
tv69 = 216
this$ = 256
_Ptr$ = 264
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 818  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR tv69[rbp], rax
	movzx	edx, BYTE PTR $T1[rbp]
	mov	rcx, QWORD PTR tv69[rbp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 819  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64,unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 820  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT text$x
text$x	SEGMENT
$T1 = 196
tv69 = 216
this$ = 256
_Ptr$ = 264
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H
	lea	rbp, QWORD PTR [rdx+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Idx$1 = 8
this$ = 256
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 500  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 501  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Switch_to_

; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {

	mov	QWORD PTR _Idx$1[rbp], 0
	jmp	SHORT $LN4@Switch_to_
$LN2@Switch_to_:
	mov	rax, QWORD PTR _Idx$1[rbp]
	inc	rax
	mov	QWORD PTR _Idx$1[rbp], rax
$LN4@Switch_to_:
	cmp	QWORD PTR _Idx$1[rbp], 16
	jae	SHORT $LN5@Switch_to_

; 507  :                     _Buf[_Idx] = value_type();

	mov	rax, QWORD PTR _Idx$1[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax], 0

; 508  :                 }

	jmp	SHORT $LN2@Switch_to_
$LN5@Switch_to_:

; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	rdi, QWORD PTR this$[rbp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Idx$1 = 8
this$ = 256
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 456  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 457  :         // start the lifetime of the array elements
; 458  : #if _HAS_CXX20
; 459  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Activate_S

; 460  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {

	mov	QWORD PTR _Idx$1[rbp], 0
	jmp	SHORT $LN4@Activate_S
$LN2@Activate_S:
	mov	rax, QWORD PTR _Idx$1[rbp]
	inc	rax
	mov	QWORD PTR _Idx$1[rbp], rax
$LN4@Activate_S:
	cmp	QWORD PTR _Idx$1[rbp], 16
	jae	SHORT $LN5@Activate_S

; 461  :                 _Bx._Buf[_Idx] = value_type();

	mov	rax, QWORD PTR _Idx$1[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax+8], 0

; 462  :             }

	jmp	SHORT $LN2@Activate_S
$LN5@Activate_S:

; 463  :         }
; 464  : #endif // _HAS_CXX20
; 465  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 192
this$ = 240
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 452  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 453  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax+32], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rbp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rbp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rbp]

; 454  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 8
this$ = 256
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 443  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 444  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	QWORD PTR _Result$[rbp], rax

; 445  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 446  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rbp], rax
$LN2@Myptr:

; 447  :         }
; 448  : 
; 449  :         return _Result;

	mov	rax, QWORD PTR _Result$[rbp]

; 450  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 8
this$ = 256
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 434  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 435  :         value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	QWORD PTR _Result$[rbp], rax

; 436  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 437  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rbp], rax
$LN2@Myptr:

; 438  :         }
; 439  : 
; 440  :         return _Result;

	mov	rax, QWORD PTR _Result$[rbp]

; 441  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rcx, QWORD PTR this$[rbp]
	call	??0_Container_base12@std@@QEAA@XZ	; std::_Container_base12::_Container_base12
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
	npad	1

; 403  : 
; 404  : #if _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 405  :     _CONSTEXPR20 ~_String_val() noexcept {
; 406  :         if constexpr (is_pointer_v<pointer>) {
; 407  :             if (!_STD _Is_constant_evaluated()) {
; 408  :                 const auto _Tombstone{reinterpret_cast<pointer>(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
; 409  :                 _Bx._Ptr = _Tombstone;
; 410  :                 _Mysize  = 0;
; 411  :                 _Myres   = (_Small_string_capacity + 1) | _Alloc_mask; // first capacity when entering large mode
; 412  : 
; 413  :                 // The capacity indicates whether we're in small mode or large mode; see _Large_mode_engaged().
; 414  :                 // The string would be usable in small mode, so we need large mode for the tombstone to be effective.
; 415  :                 // `_Small_string_capacity + 1` would be sufficient to make _Large_mode_engaged() return true. However,
; 416  :                 // basic_string uses a "roundup mask" when allocating; see _Calculate_growth(). So to avoid confusing
; 417  :                 // the SSO logic, we use the first capacity that would normally be used when entering large mode.
; 418  :             }
; 419  :         }
; 420  :     }
; 421  : #endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES
; 422  : 
; 423  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 424  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 425  :     // roundup mask for allocated buffers, [0, 15]
; 426  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 427  :                                            : sizeof(value_type) <= 2 ? 7
; 428  :                                            : sizeof(value_type) <= 4 ? 3
; 429  :                                            : sizeof(value_type) <= 8 ? 1
; 430  :                                                                      : 0;
; 431  :     // capacity in small mode
; 432  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 433  : 
; 434  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 435  :         value_type* _Result = _Bx._Buf;
; 436  :         if (_Large_mode_engaged()) {
; 437  :             _Result = _Unfancy(_Bx._Ptr);
; 438  :         }
; 439  : 
; 440  :         return _Result;
; 441  :     }
; 442  : 
; 443  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 444  :         const value_type* _Result = _Bx._Buf;
; 445  :         if (_Large_mode_engaged()) {
; 446  :             _Result = _Unfancy(_Bx._Ptr);
; 447  :         }
; 448  : 
; 449  :         return _Result;
; 450  :     }
; 451  : 
; 452  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 453  :         return _Myres > _Small_string_capacity;
; 454  :     }
; 455  : 
; 456  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 457  :         // start the lifetime of the array elements
; 458  : #if _HAS_CXX20
; 459  :         if (_STD is_constant_evaluated()) {
; 460  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 461  :                 _Bx._Buf[_Idx] = value_type();
; 462  :             }
; 463  :         }
; 464  : #endif // _HAS_CXX20
; 465  :     }
; 466  : 
; 467  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 468  :         // checks whether _Off is in the bounds of [0, size()]
; 469  :         if (_Mysize < _Off) {
; 470  :             _Xran();
; 471  :         }
; 472  :     }
; 473  : 
; 474  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 475  :         // checks whether _Off is in the bounds of [0, size())
; 476  :         if (_Mysize <= _Off) {
; 477  :             _Xran();
; 478  :         }
; 479  :     }
; 480  : 
; 481  :     [[noreturn]] static void _Xran() {
; 482  :         _Xout_of_range("invalid string position");
; 483  :     }
; 484  : 
; 485  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 486  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 487  :         return (_STD min)(_Size, _Mysize - _Off);
; 488  :     }
; 489  : 
; 490  :     union _Bxty { // storage for small buffer or pointer to larger one
; 491  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 492  :         // renaming `_String_val` (and fixing the visualizer).
; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 494  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 495  : 
; 496  :         value_type _Buf[_BUF_SIZE];
; 497  :         pointer _Ptr;
; 498  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 499  : 
; 500  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 501  :             _STD _Destroy_in_place(_Ptr);
; 502  : 
; 503  : #if _HAS_CXX20
; 504  :             // start the lifetime of the array elements
; 505  :             if (_STD is_constant_evaluated()) {
; 506  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 507  :                     _Buf[_Idx] = value_type();
; 508  :                 }
; 509  :             }
; 510  : #endif // _HAS_CXX20
; 511  :         }
; 512  :     };
; 513  :     _Bxty _Bx;
; 514  : 
; 515  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 516  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 517  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+24], 0

; 518  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+32], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 224
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 749  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 750  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 751  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 224
_Count$ = 232
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 992  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 993  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 994  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rbp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 995  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 224
_Ptr$ = 232
_Count$ = 240
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 986  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 987  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rbp], 0
	jne	SHORT $LN2@deallocate
	cmp	QWORD PTR _Count$[rbp], 0
	je	SHORT $LN2@deallocate
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 987				; 000003dbH
	lea	rdx, OFFSET FLAT:??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN4@deallocate
	int	3
	xor	eax, eax
$LN4@deallocate:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@deallocate:

; 988  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 989  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR _Ptr$[rbp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 990  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 978  :     constexpr allocator() noexcept {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 573  : [[noreturn]] inline void _Xlen_string() {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C0C4C773_xstring
	call	__CheckForDebuggerJustMyCode
	npad	1

; 574  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlen_strin:

; 575  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = 200
_Obj$ = 256
<_Args_0>$ = 264
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 515  :     noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C78B1955_xutility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 516  : #if _HAS_CXX20
; 517  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Construct_

; 518  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
	mov	rdx, QWORD PTR <_Args_0>$[rbp]
	mov	rcx, rax
	call	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *>
	npad	1

; 519  :     } else

	jmp	SHORT $LN3@Construct_
$LN2@Construct_:

; 520  : #endif // _HAS_CXX20
; 521  :     {
; 522  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rbp]
	call	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
	mov	rdx, rax
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR <_Args_0>$[rbp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR $T1[rbp]
	call	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
	npad	1
$LN3@Construct_:

; 523  :     }
; 524  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\type_traits
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 224
??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 1532 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__680F61A7_type_traits
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1533 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rbp]

; 1534 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??$addressof@U_Container_base12@std@@@std@@YAPEAU_Container_base12@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0_Basic_container_proxy_ptr12@std@@IEAA@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT

; 1477 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1470 :     _Container_proxy* _Ptr = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax], 0

; 1477 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0_Basic_container_proxy_ptr12@std@@IEAA@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ PROC ; std::_Basic_container_proxy_ptr12::_Release, COMDAT

; 1472 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1473 :         _Ptr = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax], 0

; 1474 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Release@_Basic_container_proxy_ptr12@std@@QEAAXXZ ENDP ; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 8
_Val$ = 256
_New_val$ = 264
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 771  :     noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__DE82222C_utility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 772  :     // assign _New_val to _Val, return previous _Val
; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rbp], rax

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rbp]
	mov	rcx, QWORD PTR _New_val$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 775  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rbp]

; 776  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z
_TEXT	SEGMENT
_Lock$ = 4
__$ArrayPad$ = 216
this$ = 256
_Right$ = 264
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_locked, COMDAT

; 1258 :     void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 10
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1259 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	edx, 3
	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
	npad	1

; 1260 :         _Swap_proxy_and_iterators_unlocked(_Right);

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
	npad	1

; 1261 :     }

	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
	npad	1
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 4
__$ArrayPad$ = 216
this$ = 256
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT

; 1253 :     void _Orphan_all_locked_v3() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 10
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1254 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	edx, 3
	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
	npad	1

; 1255 :         _Orphan_all_unlocked_v3();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
	npad	1

; 1256 :     }

	lea	rcx, QWORD PTR _Lock$[rbp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
	npad	1
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z
_TEXT	SEGMENT
_Temp$ = 8
this$ = 256
_Right$ = 264
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked, COMDAT

; 1417 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1418 :     _Container_proxy* _Temp = _Myproxy;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Temp$[rbp], rax

; 1419 :     _Myproxy                = _Right._Myproxy;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 1420 :     _Right._Myproxy         = _Temp;

	mov	rax, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR _Temp$[rbp]
	mov	QWORD PTR [rax], rcx

; 1421 : 
; 1422 :     if (_Myproxy) {

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Swap_proxy

; 1423 :         _Myproxy->_Mycont = this;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax], rcx
$LN2@Swap_proxy:

; 1424 :     }
; 1425 : 
; 1426 :     if (_Right._Myproxy) {

	mov	rax, QWORD PTR _Right$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@Swap_proxy

; 1427 :         _Right._Myproxy->_Mycont = &_Right;

	mov	rax, QWORD PTR _Right$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Right$[rbp]
	mov	QWORD PTR [rax], rcx
$LN3@Swap_proxy:

; 1428 :     }
; 1429 : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$1 = 8
$T2 = 228
this$ = 288
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT

; 1393 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1394 :     if (!_Myproxy) { // no proxy, already done

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@Orphan_all

; 1395 :         return;

	jmp	SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1396 :     }
; 1397 : 
; 1398 :     // proxy allocated, drain it
; 1399 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

	mov	QWORD PTR $T2[rbp], 0
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 8
	lea	rdx, QWORD PTR $T2[rbp]
	mov	rcx, rax
	call	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
	mov	QWORD PTR _Pnext$1[rbp], rax
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:
	mov	rax, QWORD PTR _Pnext$1[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnext$1[rbp], rax
$LN4@Orphan_all:
	cmp	QWORD PTR _Pnext$1[rbp], 0
	je	SHORT $LN1@Orphan_all

; 1400 :         _Pnext->_Myproxy = nullptr;

	mov	rax, QWORD PTR _Pnext$1[rbp]
	mov	QWORD PTR [rax], 0

; 1401 :     }

	jmp	SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 1402 : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 224
_Right$ = 232
?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators, COMDAT

; 1431 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1432 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1433 : #if _HAS_CXX20
; 1434 :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Swap_proxy

; 1435 :         _Swap_proxy_and_iterators_unlocked(_Right);

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
	npad	1

; 1436 :     } else

	jmp	SHORT $LN3@Swap_proxy
$LN2@Swap_proxy:

; 1437 : #endif // _HAS_CXX20
; 1438 :     {
; 1439 :         _Swap_proxy_and_iterators_locked(_Right);

	mov	rdx, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AEAAXAEAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
	npad	1
$LN3@Swap_proxy:

; 1440 :     }
; 1441 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1442 :     _Swap_proxy_and_iterators_unlocked(_Right);
; 1443 : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
; 1444 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Swap_proxy_and_iterators@_Container_base12@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 224
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 1404 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1405 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1406 : #if _HAS_CXX20
; 1407 :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Orphan_all

; 1408 :         _Orphan_all_unlocked_v3();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
	npad	1

; 1409 :     } else

	jmp	SHORT $LN3@Orphan_all
$LN2@Orphan_all:

; 1410 : #endif // _HAS_CXX20
; 1411 :     {
; 1412 :         _Orphan_all_locked_v3();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
	npad	1
$LN3@Orphan_all:

; 1413 :     }
; 1414 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1415 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??0_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT

; 1222 :     _CONSTEXPR20 _Container_base12() noexcept = default;

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1223 : 
; 1224 :     _Container_base12(const _Container_base12&)            = delete;
; 1225 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1226 : 
; 1227 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1228 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1229 : 
; 1230 :     template <class _Alloc>
; 1231 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1232 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1233 :         _Construct_in_place(*_New_proxy, this);
; 1234 :         _Myproxy            = _New_proxy;
; 1235 :         _New_proxy->_Mycont = this;
; 1236 :     }
; 1237 : 
; 1238 :     template <class _Alloc>
; 1239 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1240 :         // pre: no iterators refer to the existing proxy
; 1241 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1242 :         _Construct_in_place(*_New_proxy, this);
; 1243 :         _New_proxy->_Mycont = this;
; 1244 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1245 :     }
; 1246 : 
; 1247 :     _Container_proxy* _Myproxy = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax], 0

; 1222 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 224
_Mycont_$ = 232
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT

; 1214 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Mycont_$[rbp]
	mov	QWORD PTR [rax], rcx

; 1215 : 
; 1216 :     const _Container_base12* _Mycont       = nullptr;
; 1217 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

	mov	rax, QWORD PTR this$[rbp]
	mov	QWORD PTR [rax+8], 0

; 1214 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 224
__formal$ = 232
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1203 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr_user$ = 8
_Ptr_container$ = 40
_Min_back_shift$ = 72
_Back_shift$ = 104
_Ptr$ = 352
_Bytes$ = 360
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 204  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 205  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 206  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 47					; 0000002fH
	mov	rcx, QWORD PTR _Bytes$[rbp]
	mov	QWORD PTR [rcx], rax

; 207  : 
; 208  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rbp], rax

; 209  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rbp], rax

; 210  : 
; 211  :     // If the following asserts, it likely means that we are performing
; 212  :     // an aligned delete on memory coming from an unaligned allocation.
; 213  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 8
	imul	rax, rax, -2
	mov	rcx, QWORD PTR _Ptr_user$[rbp]
	mov	rdx, -361700864190383366		; fafafafafafafafaH
	cmp	QWORD PTR [rcx+rax], rdx
	je	SHORT $LN2@Adjust_man
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
	add	eax, 9
	lea	rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rcx
	xor	r9d, r9d
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN6@Adjust_man
	int	3
	xor	eax, eax
$LN6@Adjust_man:
	mov	ecx, 5
	int	41					; 00000029H
$LN2@Adjust_man:

; 214  : 
; 215  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 216  :     // in range [_Min_back_shift, _Non_user_size]
; 217  : #ifdef _DEBUG
; 218  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rbp], 16

; 219  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 220  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 221  : #endif // ^^^ !defined(_DEBUG) ^^^
; 222  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Ptr_container$[rbp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rbp], rax

; 223  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rbp], 16
	jb	SHORT $LN4@Adjust_man
	cmp	QWORD PTR _Back_shift$[rbp], 47		; 0000002fH
	jbe	SHORT $LN3@Adjust_man
$LN4@Adjust_man:
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z@4JA
	add	eax, 19
	lea	rcx, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rcx
	xor	r9d, r9d
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_0GA@HFAKHCPJ@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN7@Adjust_man
	int	3
	xor	eax, eax
$LN7@Adjust_man:
	mov	ecx, 5
	int	41					; 00000029H
$LN3@Adjust_man:

; 224  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR _Ptr_container$[rbp]
	mov	QWORD PTR [rax], rcx
$LN5@Adjust_man:

; 225  : }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 224
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 139  :     __declspec(allocator) static _CLANG_CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 140  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rbp]
	call	??2@YAPEAX_K@Z				; operator new

; 141  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 200
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 111  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B41741EF_xmemory
	call	__CheckForDebuggerJustMyCode
	npad	1

; 112  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rbp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rbp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 113  : }

	lea	rsp, QWORD PTR [rbp+248]
	pop	rdi
	pop	rbp
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\exception
;	COMDAT ?_Throw_bad_variant_access@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 200
?_Throw_bad_variant_access@std@@YAXXZ PROC		; std::_Throw_bad_variant_access, COMDAT

; 416  : [[noreturn]] inline void _Throw_bad_variant_access() {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ADF8C0C4_exception
	call	__CheckForDebuggerJustMyCode
	npad	1

; 417  :     _THROW(bad_variant_access{});

	lea	rax, QWORD PTR $T1[rbp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 24
	rep stosb
	lea	rcx, QWORD PTR $T1[rbp]
	call	??0bad_variant_access@std@@QEAA@XZ	; std::bad_variant_access::bad_variant_access
	lea	rdx, OFFSET FLAT:_TI2?AVbad_variant_access@std@@
	lea	rcx, QWORD PTR $T1[rbp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 418  : }

	lea	rsp, QWORD PTR [rbp+248]
	pop	rdi
	pop	rbp
	ret	0
?_Throw_bad_variant_access@std@@YAXXZ ENDP		; std::_Throw_bad_variant_access
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_variant_access@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gbad_variant_access@std@@UEAAPEAXI@Z PROC		; std::bad_variant_access::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_variant_access@std@@UEAA@XZ
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gbad_variant_access@std@@UEAAPEAXI@Z ENDP		; std::bad_variant_access::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_variant_access@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
__that$ = 232
??0bad_variant_access@std@@QEAA@AEBV01@@Z PROC		; std::bad_variant_access::bad_variant_access, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdx, QWORD PTR __that$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_variant_access@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_variant_access@std@@QEAA@AEBV01@@Z ENDP		; std::bad_variant_access::bad_variant_access
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_variant_access@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1bad_variant_access@std@@UEAA@XZ PROC			; std::bad_variant_access::~bad_variant_access, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1bad_variant_access@std@@UEAA@XZ ENDP			; std::bad_variant_access::~bad_variant_access
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\exception
;	COMDAT ?what@bad_variant_access@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 224
?what@bad_variant_access@std@@UEBAPEBDXZ PROC		; std::bad_variant_access::what, COMDAT

; 404  :     _NODISCARD const char* __CLR_OR_THIS_CALL what() const noexcept override {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ADF8C0C4_exception
	call	__CheckForDebuggerJustMyCode
	npad	1

; 405  :         return "bad variant access";

	lea	rax, OFFSET FLAT:??_C@_0BD@FGIAGBIG@bad?5variant?5access@

; 406  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?what@bad_variant_access@std@@UEBAPEBDXZ ENDP		; std::bad_variant_access::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\exception
;	COMDAT ??0bad_variant_access@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0bad_variant_access@std@@QEAA@XZ PROC			; std::bad_variant_access::bad_variant_access, COMDAT

; 402  :     bad_variant_access() noexcept = default;

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ADF8C0C4_exception
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rcx, QWORD PTR this$[rbp]
	call	??0exception@std@@QEAA@XZ		; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_variant_access@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_variant_access@std@@QEAA@XZ ENDP			; std::bad_variant_access::bad_variant_access
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
__that$ = 232
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdx, QWORD PTR __that$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4A687918_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rbp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc
	npad	1

; 144  :     {

	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
__that$ = 232
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdx, QWORD PTR __that$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 224
_Message$ = 232
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4A687918_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception
	npad	1

; 133  :     {

	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 224
__flags$ = 232
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rcx, QWORD PTR this$[rbp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	mov	eax, DWORD PTR __flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 192
this$ = 240
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4A687918_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rbp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rbp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rbp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rbp]

; 97   :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 224
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4A687918_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 224
_Other$ = 232
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4A687918_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rbp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 224
_Message$ = 232
__formal$ = 240
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4A687918_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR _Message$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
_InitData$ = 8
__$ArrayPad$ = 232
this$ = 272
_Message$ = 280
??0exception@std@@QEAA@QEBD@Z PROC			; std::exception::exception, COMDAT

; 60   :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 14
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+312]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__4A687918_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 59   :         : _Data()

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 61   :         __std_exception_data _InitData = { _Message, true };

	mov	rax, QWORD PTR _Message$[rbp]
	mov	QWORD PTR _InitData$[rbp], rax
	mov	BYTE PTR _InitData$[rbp+8], 1

; 62   :         __std_exception_copy(&_InitData, &_Data);

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, QWORD PTR _InitData$[rbp]
	call	__std_exception_copy
	npad	1

; 63   :     }

	mov	rax, QWORD PTR this$[rbp]
	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:??0exception@std@@QEAA@QEBD@Z$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+248]
	pop	rdi
	pop	rbp
	ret	0
??0exception@std@@QEAA@QEBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 224
??0exception@std@@QEAA@XZ PROC				; std::exception::exception, COMDAT

; 55   :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4A687918_vcruntime_exception@h
	call	__CheckForDebuggerJustMyCode
	npad	1
	mov	rax, QWORD PTR this$[rbp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 54   :         : _Data()

	mov	rax, QWORD PTR this$[rbp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 56   :     }

	mov	rax, QWORD PTR this$[rbp]
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??0exception@std@@QEAA@XZ ENDP				; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
$T1 = 200
tv65 = 216
_Left$ = 256
_Right$ = 264
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 99   :         noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__DE82222C_utility
	call	__CheckForDebuggerJustMyCode
	npad	1

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rbp]
	mov	rcx, QWORD PTR _Left$[rbp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rbp]
	mov	QWORD PTR tv65[rbp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rbp]
	mov	QWORD PTR tv65[rbp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rbp]
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]

; 102  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 598  :     _NODISCARD static constexpr int_type eof() noexcept {

$LN4:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__FEA281E8___msvc_string_view@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 599  :         return static_cast<int_type>(EOF);

	mov	eax, -1

; 600  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
tv65 = 192
_Left$ = 240
_Right$ = 248
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 590  :     _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__FEA281E8___msvc_string_view@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 591  :         return _Left == _Right;

	mov	eax, DWORD PTR _Right$[rbp]
	cmp	DWORD PTR _Left$[rbp], eax
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[rbp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[rbp], 0
$LN4@eq_int_typ:
	movzx	eax, BYTE PTR tv65[rbp]

; 592  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 224
_Right$ = 232
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 570  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__FEA281E8___msvc_string_view@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 571  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rbp]
	mov	rcx, QWORD PTR _Right$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 572  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 224
_Count$ = 232
_Ch$ = 240
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 559  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__FEA281E8___msvc_string_view@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 560  :         // assign _Count * _Ch to [_First, ...)
; 561  : #if _HAS_CXX20
; 562  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 563  :             return _Primary_char_traits::assign(_First, _Count, _Ch);

	movzx	r8d, BYTE PTR _Ch$[rbp]
	mov	rdx, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR _First$[rbp]
	call	?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Char_traits<char,int>::assign
	jmp	SHORT $LN1@assign
$LN2@assign:

; 564  :         }
; 565  : #endif // _HAS_CXX20
; 566  : 
; 567  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR _Ch$[rbp]
	mov	r8, QWORD PTR _Count$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR _First$[rbp]
	call	memset
$LN1@assign:

; 568  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 224
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 517  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__FEA281E8___msvc_string_view@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 518  :         // find length of null-terminated string
; 519  : #if _HAS_CXX17
; 520  : #ifdef __cpp_char8_t
; 521  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 522  : #if _HAS_U8_INTRINSICS
; 523  :             return __builtin_u8strlen(_First);
; 524  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 525  :             return _Primary_char_traits::length(_First);
; 526  : #endif // ^^^ no u8 intrinsics ^^^
; 527  :         } else
; 528  : #endif // defined(__cpp_char8_t)
; 529  :         {
; 530  :             return __builtin_strlen(_First);

	mov	rcx, QWORD PTR _First$[rbp]
	call	strlen

; 531  :         }
; 532  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 533  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 534  : #endif // ^^^ !_HAS_CXX17 ^^^
; 535  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_Next$1 = 8
_First$ = 256
_Count$ = 264
_Ch$ = 272
?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 298  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN7:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__FEA281E8___msvc_string_view@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 299  :         // assign _Count * _Ch to [_First, ...)
; 300  :         for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

	mov	rax, QWORD PTR _First$[rbp]
	mov	QWORD PTR _Next$1[rbp], rax
	jmp	SHORT $LN4@assign
$LN2@assign:
	mov	rax, QWORD PTR _Count$[rbp]
	dec	rax
	mov	QWORD PTR _Count$[rbp], rax
	mov	rax, QWORD PTR _Next$1[rbp]
	inc	rax
	mov	QWORD PTR _Next$1[rbp], rax
$LN4@assign:
	cmp	QWORD PTR _Count$[rbp], 0
	jbe	SHORT $LN3@assign

; 301  :             *_Next = _Ch;

	mov	rax, QWORD PTR _Next$1[rbp]
	movzx	ecx, BYTE PTR _Ch$[rbp]
	mov	BYTE PTR [rax], cl

; 302  :         }

	jmp	SHORT $LN2@assign
$LN3@assign:

; 303  : 
; 304  :         return _First;

	mov	rax, QWORD PTR _First$[rbp]

; 305  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?assign@?$_Char_traits@DH@std@@SAPEADQEAD_KD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_Loop_forward$1 = 4
_Src$2 = 40
_Idx$3 = 72
_Idx$4 = 104
_First1$ = 352
_First2$ = 360
_Count$ = 368
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 215  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN17:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 360				; 00000168H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__FEA281E8___msvc_string_view@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 216  :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 217  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 218  :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 219  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 220  : #if _HAS_CXX20
; 221  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	$LN11@move

; 222  :             // dest: [_First1, _First1 + _Count)
; 223  :             // src: [_First2, _First2 + _Count)
; 224  :             // We need to handle overlapping ranges.
; 225  :             // If _First1 is in the src range, we need a backward loop.
; 226  :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 227  : 
; 228  :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 229  :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 230  :             bool _Loop_forward = true;

	mov	BYTE PTR _Loop_forward$1[rbp], 1

; 231  : 
; 232  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {

	mov	rax, QWORD PTR _First2$[rbp]
	mov	QWORD PTR _Src$2[rbp], rax
	jmp	SHORT $LN4@move
$LN2@move:
	mov	rax, QWORD PTR _Src$2[rbp]
	inc	rax
	mov	QWORD PTR _Src$2[rbp], rax
$LN4@move:
	mov	rax, QWORD PTR _Count$[rbp]
	mov	rcx, QWORD PTR _First2$[rbp]
	add	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Src$2[rbp], rax
	je	SHORT $LN3@move

; 233  :                 if (_First1 == _Src) {

	mov	rax, QWORD PTR _Src$2[rbp]
	cmp	QWORD PTR _First1$[rbp], rax
	jne	SHORT $LN12@move

; 234  :                     _Loop_forward = false;

	mov	BYTE PTR _Loop_forward$1[rbp], 0

; 235  :                     break;

	jmp	SHORT $LN3@move
$LN12@move:

; 236  :                 }
; 237  :             }

	jmp	SHORT $LN2@move
$LN3@move:

; 238  : 
; 239  :             if (_Loop_forward) {

	movzx	eax, BYTE PTR _Loop_forward$1[rbp]
	test	eax, eax
	je	SHORT $LN13@move

; 240  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {

	mov	QWORD PTR _Idx$3[rbp], 0
	jmp	SHORT $LN7@move
$LN5@move:
	mov	rax, QWORD PTR _Idx$3[rbp]
	inc	rax
	mov	QWORD PTR _Idx$3[rbp], rax
$LN7@move:
	mov	rax, QWORD PTR _Count$[rbp]
	cmp	QWORD PTR _Idx$3[rbp], rax
	je	SHORT $LN6@move

; 241  :                     _First1[_Idx] = _First2[_Idx];

	mov	rax, QWORD PTR _Idx$3[rbp]
	mov	rcx, QWORD PTR _First1$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Idx$3[rbp]
	mov	rdx, QWORD PTR _First2$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 242  :                 }

	jmp	SHORT $LN5@move
$LN6@move:

; 243  :             } else {

	jmp	SHORT $LN14@move
$LN13@move:

; 244  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {

	mov	rax, QWORD PTR _Count$[rbp]
	mov	QWORD PTR _Idx$4[rbp], rax
	jmp	SHORT $LN10@move
$LN8@move:
	mov	rax, QWORD PTR _Idx$4[rbp]
	dec	rax
	mov	QWORD PTR _Idx$4[rbp], rax
$LN10@move:
	cmp	QWORD PTR _Idx$4[rbp], 0
	je	SHORT $LN14@move

; 245  :                     _First1[_Idx - 1] = _First2[_Idx - 1];

	mov	rax, QWORD PTR _Idx$4[rbp]
	mov	rcx, QWORD PTR _First1$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Idx$4[rbp]
	mov	rdx, QWORD PTR _First2$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	movzx	ecx, BYTE PTR [rcx-1]
	mov	BYTE PTR [rax-1], cl

; 246  :                 }

	jmp	SHORT $LN8@move
$LN14@move:

; 247  :             }
; 248  : 
; 249  :             return _First1;

	mov	rax, QWORD PTR _First1$[rbp]
	jmp	SHORT $LN1@move
$LN11@move:

; 250  :         }
; 251  : #endif // _HAS_CXX20
; 252  : 
; 253  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _First2$[rbp]
	mov	rcx, QWORD PTR _First1$[rbp]
	call	memmove
	npad	1

; 254  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 255  : 
; 256  :         return _First1;

	mov	rax, QWORD PTR _First1$[rbp]
$LN1@move:

; 257  :     }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_Idx$1 = 8
_First1$ = 256
_First2$ = 264
_Count$ = 272
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 184  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__FEA281E8___msvc_string_view@hpp
	call	__CheckForDebuggerJustMyCode
	npad	1

; 185  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 186  : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 187  :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 188  : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 189  : #if _HAS_CXX20
; 190  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@copy

; 191  :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 192  :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {

	mov	QWORD PTR _Idx$1[rbp], 0
	jmp	SHORT $LN4@copy
$LN2@copy:
	mov	rax, QWORD PTR _Idx$1[rbp]
	inc	rax
	mov	QWORD PTR _Idx$1[rbp], rax
$LN4@copy:
	mov	rax, QWORD PTR _Count$[rbp]
	cmp	QWORD PTR _Idx$1[rbp], rax
	je	SHORT $LN3@copy

; 193  :                 _First1[_Idx] = _First2[_Idx];

	mov	rax, QWORD PTR _Idx$1[rbp]
	mov	rcx, QWORD PTR _First1$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Idx$1[rbp]
	mov	rdx, QWORD PTR _First2$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 194  :             }

	jmp	SHORT $LN2@copy
$LN3@copy:

; 195  : 
; 196  :             return _First1;

	mov	rax, QWORD PTR _First1$[rbp]
	jmp	SHORT $LN1@copy
$LN5@copy:

; 197  :         }
; 198  : #endif // _HAS_CXX20
; 199  : 
; 200  :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _First2$[rbp]
	mov	rcx, QWORD PTR _First1$[rbp]
	call	memcpy
	npad	1

; 201  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 202  : 
; 203  :         return _First1;

	mov	rax, QWORD PTR _First1$[rbp]
$LN1@copy:

; 204  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 182  : _EXPORT_STD _NODISCARD constexpr bool is_constant_evaluated() noexcept {

$LN4:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__62CE13B5_xtr1common
	call	__CheckForDebuggerJustMyCode
	npad	1

; 183  :     return __builtin_is_constant_evaluated();

	xor	al, al

; 184  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _scprintf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 280
_Format$ = 320
_scprintf PROC						; COMDAT

; 2083 :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 26
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__B3FE3303_stdio@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 2084 :         int _Result;
; 2085 :         va_list _ArgList;
; 2086 :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rbp+8]
	mov	QWORD PTR _ArgList$[rbp], rax

; 2087 :         _Result = _vscprintf_l(_Format, NULL, _ArgList);

	mov	r8, QWORD PTR _ArgList$[rbp]
	xor	edx, edx
	mov	rcx, QWORD PTR _Format$[rbp]
	call	_vscprintf_l
	mov	DWORD PTR _Result$[rbp], eax

; 2088 :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rbp], 0

; 2089 :         return _Result;

	mov	eax, DWORD PTR _Result$[rbp]

; 2090 :     }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_scprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
_scprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT sprintf_s
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 280
_Buffer$ = 320
_BufferCount$ = 328
_Format$ = 336
sprintf_s PROC						; COMDAT

; 1823 :         {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 344				; 00000158H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rdi, QWORD PTR [rsp+48]
	mov	ecx, 26
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+376]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__B3FE3303_stdio@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rbp+8]
	mov	QWORD PTR _ArgList$[rbp], rax

; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR _Format$[rbp]
	mov	rdx, QWORD PTR _BufferCount$[rbp]
	mov	rcx, QWORD PTR _Buffer$[rbp]
	call	_vsprintf_s_l
	mov	DWORD PTR _Result$[rbp], eax

; 1828 :             __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rbp], 0

; 1829 :             return _Result;

	mov	eax, DWORD PTR _Result$[rbp]

; 1830 :         }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:sprintf_s$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vscprintf_l
_TEXT	SEGMENT
_Result$ = 4
tv74 = 212
_Format$ = 256
_Locale$ = 264
_ArgList$ = 272
_vscprintf_l PROC					; COMDAT

; 1651 :     {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B3FE3303_stdio@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1652 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 2
	mov	rcx, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rbp]
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rbp], eax

; 1653 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1654 :             NULL, 0, _Format, _Locale, _ArgList);
; 1655 : 
; 1656 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rbp], 0
	jge	SHORT $LN3@vscprintf_
	mov	DWORD PTR tv74[rbp], -1
	jmp	SHORT $LN4@vscprintf_
$LN3@vscprintf_:
	mov	eax, DWORD PTR _Result$[rbp]
	mov	DWORD PTR tv74[rbp], eax
$LN4@vscprintf_:
	mov	eax, DWORD PTR tv74[rbp]

; 1657 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_vscprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _vsprintf_s_l
_TEXT	SEGMENT
_Result$ = 4
tv73 = 212
_Buffer$ = 256
_BufferCount$ = 264
_Format$ = 272
_Locale$ = 280
_ArgList$ = 288
_vsprintf_s_l PROC					; COMDAT

; 1490 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__B3FE3303_stdio@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rbp]
	mov	r8, QWORD PTR _BufferCount$[rbp]
	mov	rdx, QWORD PTR _Buffer$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vsprintf_s
	mov	DWORD PTR _Result$[rbp], eax

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rbp], 0
	jge	SHORT $LN3@vsprintf_s
	mov	DWORD PTR tv73[rbp], -1
	jmp	SHORT $LN4@vsprintf_s
$LN3@vsprintf_s:
	mov	eax, DWORD PTR _Result$[rbp]
	mov	DWORD PTR tv73[rbp], eax
$LN4@vsprintf_s:
	mov	eax, DWORD PTR tv73[rbp]

; 1496 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__60B45B40_corecrt_stdio_config@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\18\Community\VC\Tools\MSVC\14.50.35717\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 224
_Where$ = 232
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__9A5272F0_vcruntime_new@h
	call	__CheckForDebuggerJustMyCode
	npad	1

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rbp]

; 167  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
__formal$ = 240
?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3FD16450_Main@cpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX_KW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3FD16450_Main@cpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAXW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 224
__formal$ = 232
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3FD16450_Main@cpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\unik\C_code\libraries\JsonParser\tests\Main.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 224
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3FD16450_Main@cpp
	call	__CheckForDebuggerJustMyCode
	npad	1
	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
